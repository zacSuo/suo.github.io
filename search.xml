<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3个解法：子数组异或查询</title>
      <link href="/2020/01/05/tech/math-arrayXor/"/>
      <url>/2020/01/05/tech/math-arrayXor/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</p><p>对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。</p><p>并返回一个包含给定查询 queries 所有结果的数组。</p><p>示例 1：</p><p>输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8]<br>解释：<br>数组中元素的二进制表示形式是：<br>1 = 0001<br>3 = 0011<br>4 = 0100<br>8 = 1000<br>查询的 XOR 值为：<br>[0,1] = 1 xor 3 = 2<br>[1,2] = 3 xor 4 = 7<br>[0,3] = 1 xor 3 xor 4 xor 8 = 14<br>[3,3] = 8<br>示例 2：</p><p>输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]<br>输出：[8,0,4,4]</p><p>提示：</p><p>1 &lt;= arr.length &lt;= 3 <em> 10^4<br>1 &lt;= arr[i] &lt;= 10^9<br>1 &lt;= queries.length &lt;= 3 </em> 10^4<br>queries[i].length == 2<br>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</p><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><p>思路：<br>最直接的思路，就是直接对区间执行两层循环，进行遍历，但实际执行最后一个测试用例时超时，代码及测试用例如下（测试用例有525kb，应该是一个29898个数据的数组和2万4千多个[0，29898]，太长了，文档中只放了一部分），可以通过这个地址查看这个极限测试用例：<a href="/files/tech/testCase20200105.txt?_blank">/files/tech/testCase20200105.txt</a>：<br>空间复杂度：O(1)<br>时间复杂度：O(k*m)，k为queries数组个数，m为数据差值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">XorQueries</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> [] r = <span class="keyword">new</span> <span class="keyword">int</span>[queries.Length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.Length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=queries[i][<span class="number">0</span>];j&lt;=queries[i][<span class="number">1</span>];j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t = t^ arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            r[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">64038788,905710003,961785464,588745940,342531091,30097968,737396012,134887383,51163244,155478113,866300423,933134785,734680393,698721082,581135646,988184934,232804274,641391582,......[0,29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>],[<span class="number">0</span>,<span class="number">29898</span>]]</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><p>思路：<br>由于解法一超时，想办法看看能否减少重复计算，当前算法使用空间换时间多思路，先将所有值计算出来，然后查找时候直接索引查找。但是，这种做法对内存消耗太大，对解法一超时的测试用例，当前解法超出了内存空间。事实上，程序在提交的时候，还没运行到最后一个测试用例，已经内存超出了，测试用例有668Kb，点击链接查看：<a href="/files/tech/testCase202001051.txt?_blank">/files/tech/testCase202001051.txt</a>。<br>1，行表示当前计算的数据个数<br>2，列表示当前计算多起始索引<br>因此，最终只需要获取数据数和索引即可，代码如下：</p><p>空间复杂度：O(N^2^)，N为arr数组数据<br>时间复杂度：O(N^2^ + k)，k为queries数组个数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">XorQueries</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len = queries.Length, lenA = arr.Length;</span><br><span class="line">        <span class="keyword">int</span> [,] t = <span class="keyword">new</span> <span class="keyword">int</span>[lenA,lenA];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA;i++)</span><br><span class="line">        &#123;<span class="comment">//首行</span></span><br><span class="line">            t[<span class="number">0</span>,i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lenA;i++)</span><br><span class="line">        &#123;<span class="comment">//之后行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;lenA-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                t[i,j] = t[i<span class="number">-1</span>,j] ^ arr[j+i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] r = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> rIdx=queries[i][<span class="number">1</span>] - queries[i][<span class="number">0</span>];</span><br><span class="line">            r[i] = t[rIdx,queries[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><p>思路：<br>使用前缀和的思路，即首先通过前缀累积，然后通过索引对应第值进行相减得到区间值，不过本算是多和改为异或，即进行前缀异或算法，索引N存储前N个数的异或值，并通过两个位置的和相减得到区间值。<br>对于异或来讲，加法和减法都是执行异或操作，即A xor A = 0或者 A xor B xor A = B。<br>代码如下：<br>空间复杂度：O(N)，N为arr数组数据<br>时间复杂度：O(N+k)，k为queries数组个数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">XorQueries</span>(<span class="params"><span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> len=queries.Length, lenA = arr.Length;</span><br><span class="line">        <span class="keyword">int</span> [] t = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>];</span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i] = t[i<span class="number">-1</span>] ^ arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> [] r = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r[i] = t[queries[i][<span class="number">1</span>]+<span class="number">1</span>] ^ t[queries[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center><img src="/img/tech/20200105130424152.png" title="解法三"></center>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 异或 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自主导航 - 实验教学方案</title>
      <link href="/2020/01/01/proj/vejoeRos/"/>
      <url>/2020/01/01/proj/vejoeRos/</url>
      
        <content type="html"><![CDATA[<p>本实验箱以大载重的全向麦轮车为载体，基于ROS系统作为开发平台，使用双驱和四驱两种不同的结构作为机器人本体，最终通过地面二维码实现导航机器人的精确方向和距离控制，可以选择任一种作为实验设备。</p><center><img src="/img/proj/20200106175221269.png" width="250" height="200" title="四驱AGV"><img src="/img/proj/20200106175342519.png" width="250" height="220" title="两驱AGV"></center><h2 id="机械结构"><a href="#机械结构" class="headerlink" title="机械结构"></a>机械结构</h2><ol><li>四驱麦轮AGV<ul><li>4个直径152.4mm的麦克纳姆轮</li><li>12V 直流行星减速电机 × 4</li><li>外壳为碳钢板，底盘为铝合金材质</li><li>共轴摆式悬挂系统</li><li>双层车体</li></ul></li><li>两驱运输AGV<ul><li>悬挂减震结构</li><li>125mm的橡胶车轮</li><li>12V 直流直角减速电机 × 2</li><li>自动充电模块</li></ul></li></ol><h2 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h2><ol><li>ROS系统<ul><li>B4+树莓派，四核A72CPU，2GB，64位LPDDR4</li></ul></li><li>STM32主控板<ul><li>STM32F746NGH6主控芯片</li><li>支持CAN总线，FSMC总线，IIC总线，UART接口</li><li>支持组态LCD显示模块</li><li>32M RAM，支持USB2.0通信</li></ul></li><li>电机驱动<ul><li>STM32F1系列主芯片</li><li>10AH锂电池</li><li>具备过流、过压保护</li><li>支持CAN总线通信</li><li>带编码器直流减速电机</li><li>四驱AGV四块，两驱AGV两块</li></ul></li><li>二维码导航传感器<ul><li>图像分辨率达到752 x 480</li><li>最大采集60fps，最大解码速率达到45个/秒</li><li>有4个独立控制照明LED，和2个LED瞄准器</li></ul></li><li>惯性导航：<ol><li>四驱AGV<ul><li>MPU9250九轴陀螺仪，精度0.1度</li><li>支持UART和I2C通信协议</li><li>输出可达200HZ，内置卡尔曼滤波融合算法</li></ul></li><li>两驱AGV<ul><li>MPU6050六轴陀螺仪，精度0.1度</li><li>支持SPI和I2C通信协议</li></ul></li></ol></li><li>避障传感器（四驱AGV）<ul><li>HC-SR04超声波传感器</li><li>红外避障传感器</li></ul></li><li>TFT液晶屏（四驱AGV）<ul><li>2.2寸串口TFT液晶屏，240 * 320分辨率</li></ul></li><li>尺寸：<ul><li>600mm * 556mm，高度约700mm（四驱AGV）</li><li>500mm * 500mm，高度约155mm（两驱AGV）</li></ul></li></ol><h2 id="实验支持"><a href="#实验支持" class="headerlink" title="实验支持"></a>实验支持</h2><h4 id="ROS基础开发"><a href="#ROS基础开发" class="headerlink" title="ROS基础开发"></a>ROS基础开发</h4><pre><code>1. ROS系统安装配置2. ROS系统内通信3. ROS自定义程序执行4. ROS仿真环境搭建</code></pre><h4 id="ROS应用开发"><a href="#ROS应用开发" class="headerlink" title="ROS应用开发"></a>ROS应用开发</h4><pre><code>1. 开机自动配置2. 拍照录像3. 为不同USB口指定名称4. 小车运动控制5. 距离角度控制6. 读取二维码信息7. 二维码校准8. 收发Zigbee信息9. 小车按照指定路线行走</code></pre><h4 id="嵌入式基础开发"><a href="#嵌入式基础开发" class="headerlink" title="嵌入式基础开发"></a>嵌入式基础开发</h4><pre><code>1. 定时器实验2. GPIO的配置与Flash读写实验3. 中断和串口操作实验4. SPI通信实验5. DMA控制器实验6. I²C通信实验7. AD变换实验8. ADC采样实验9. OLED实验10. PWM实验</code></pre><h4 id="嵌入式进阶开发"><a href="#嵌入式进阶开发" class="headerlink" title="嵌入式进阶开发"></a>嵌入式进阶开发</h4><pre><code>1. 串口屏通信实验2. CAN总线通信基本实验3. 麦克纳姆轮运动学实验4. 惯性导航实验5. ROS通信基本实验6. CAN 多节点通信实验</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 麦克纳姆轮 </tag>
            
            <tag> ROS机器人 </tag>
            
            <tag> 四驱AGV </tag>
            
            <tag> 两驱AGV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能控制 - 实验教学方案</title>
      <link href="/2020/01/01/proj/vejoeArm/"/>
      <url>/2020/01/01/proj/vejoeArm/</url>
      
        <content type="html"><![CDATA[<p>本实验箱以三轴高精度机械臂为载体，首先在功能上通过3个不同的配件体现其应用扩展性，其次，对主控芯片，一方面通过嵌入式的基础组件进行学习，另一方面也引入了当前广泛应用的实时操作系统Free RTOS，学生基于当前平台，既可以学习基础开发示例，也可以进行高阶二次开发。</p><center><img src="/img/proj/20200106174926405.png" title="全向麦轮车"></center><h2 id="机械结构"><a href="#机械结构" class="headerlink" title="机械结构"></a>机械结构</h2><ol><li>结构与材料<ul><li>铝合金材料加表面氧化处理</li><li>旋转底座</li><li>3轴结构</li></ul></li><li>物理参数<ul><li>机械臂尺寸：160<em>280</em>443mm</li><li>机械臂重量约1.6kg</li><li>可夹取物体重量约500g</li></ul></li></ol><h2 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h2><ol><li>控制芯片<ul><li>主控芯片：STM32F407ZGT6</li></ul></li><li>通信接口<ul><li>2路串口通信接口</li><li>2路舵机接口</li><li>1路蓝牙（CC2540）通信接口</li><li>8路输入信号接口</li><li>3路42步进电机驱动接口</li><li>7路驱动（500MA）输出信号接口</li><li>3路编码器信号接口</li><li>1路CAN总线接口</li><li>1路Zigbee（CC2530）通信接口</li></ul></li><li>核心器件<ul><li>24V适配器</li><li>3个高精度轴承（平面轴承51109，无空程）</li><li>3个42步进高精度减速电机（42步进电机，步距角1.8度，精度5%）</li><li>3个500线光电编码器</li><li>高精度CNC机械臂</li><li>高精度行星减速箱（长度38.5，减速比1:13.7，齿轮额定许用负载40，齿轮许用瞬时负载60）</li></ul></li><li>配件参数<ul><li>舵机夹取套件（TBSN-K15耐烧舵机扭力15KG.cm，合金机械爪）</li><li>写字配件（带压力自动调节装置）</li><li>气动吸盘套件（12V电压，3W功率，可吹气）</li><li>铝合金工具箱（50CM<em>42CM</em>22.5CM）</li></ul></li></ol><h2 id="实验支撑"><a href="#实验支撑" class="headerlink" title="实验支撑"></a>实验支撑</h2><h4 id="嵌入式基础实验"><a href="#嵌入式基础实验" class="headerlink" title="嵌入式基础实验"></a>嵌入式基础实验</h4><pre><code>1. GPIO实验2. Delay实验3. OLED实验4. Timer实验5. 编码器实验</code></pre><h4 id="步进电机控制实验"><a href="#步进电机控制实验" class="headerlink" title="步进电机控制实验"></a>步进电机控制实验</h4><pre><code>1. 步进电机基础控制2. 步进电机进阶控制之一3. 步进电机进阶控制之二4. 点到点控制实验</code></pre><h4 id="FPGA-基础开发实验"><a href="#FPGA-基础开发实验" class="headerlink" title="FPGA 基础开发实验"></a>FPGA 基础开发实验</h4><pre><code>1. FPGA GPIO输入输出实验2. FPGA TCL脚本实验3. FPGA 外设接口实验4. FPGA FSMC接口实验5. FPGA SDRAM读写实验6. FPGA FIFO实验</code></pre><h4 id="Free-RTOS基础开发实验"><a href="#Free-RTOS基础开发实验" class="headerlink" title="Free RTOS基础开发实验"></a>Free RTOS基础开发实验</h4><pre><code>1. rtos内核安装配置实验2. rtos任务管理实验3. rtos任务调度实验4. rtos消息和事件实验5. rtos信号量实验6. rtos低功耗模式实验</code></pre><h4 id="综合控制应用实验"><a href="#综合控制应用实验" class="headerlink" title="综合控制应用实验"></a>综合控制应用实验</h4><pre><code>1. 机械臂听写实验（写字配件：英文听写、数值心算）2. 舵机实验（舵机夹取套件）3. 吸盘实验（气动吸盘套件）</code></pre><center><img src="/img/proj/2020010617494082.png" title="全向麦轮车"></center>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高精度机械臂 </tag>
            
            <tag> 步进电机 </tag>
            
            <tag> 步进伺服 </tag>
            
            <tag> STM32 </tag>
            
            <tag> 407系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式基础 - 实验教学方案</title>
      <link href="/2020/01/01/proj/vejoeBal/"/>
      <url>/2020/01/01/proj/vejoeBal/</url>
      
        <content type="html"><![CDATA[<p>以双轮自平衡机器人为载体，进行嵌入式基础知识的说明和介绍。</p><center><img src="/img/proj/20200106170059798.png" title="双轮自平衡机器人"></center><h2 id="机械结构"><a href="#机械结构" class="headerlink" title="机械结构"></a>机械结构</h2><ol><li>结构与材料<ul><li>航模级减震轮胎</li><li>电机固定支架</li><li>车轮联轴器</li><li>4mm亚克力固定板</li></ul></li><li>物理参数<ul><li>尺寸：190<em>135</em>66mm</li><li>重量：约900克</li></ul></li></ol><h2 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h2><ol><li>控制芯片<ul><li>主控芯片：STM32F103RCT6</li><li>独立可插拔电机驱动芯片：TB6612</li></ul></li><li>传感器<ul><li>MPU6050陀螺仪传感器，角速度感测范围±250、±500、±1000与±2000°/sec (dps)</li><li>HC-SR04超声波传感器，量程2CM-400CM，精度3MM.</li><li>声波采样传感器（电容式，9MM*7MM，灵敏度52DB）</li><li>循迹传感器（TSL1401线阵，线性CCD摄像头、铝合金支架）</li></ul></li><li>通信接口<ul><li>1路CAN总线接口</li><li>预留1路串口</li><li>蓝牙（CC2540）无线通信接口</li><li>线性CCD模块接口</li></ul></li><li>器件<ul><li>2600MAH大容量锂电池（3S）</li><li>4.32W直流电机</li><li>0.96寸OLED液晶屏模块</li></ul></li><li>性能参数<ul><li>自平衡续航时间大于20个小时</li><li>高速运动续航时间约45分钟</li><li>霍尔编码器分辨率0.23°</li></ul></li><li>配件参数<ul><li>B3AC智能充电器（输入电压110-240V，最大充电电流2.4A，可充2S/3S）</li><li>循迹S线路径演示纸配件（50CM*250CM，PVC材质加增强网格）</li><li>迷宫挡板配件（42CM*35CM，透明）</li><li>铝合金工具箱（34 CM <em>27 CM </em>14.5CM）</li></ul></li></ol><h2 id="实验支撑"><a href="#实验支撑" class="headerlink" title="实验支撑"></a>实验支撑</h2><h4 id="嵌入式程序设计实验"><a href="#嵌入式程序设计实验" class="headerlink" title="嵌入式程序设计实验"></a>嵌入式程序设计实验</h4><ol><li><a href="https://www.zhenxiangsimple.com/2019/09/24/tech/c-serial/">中断和串口操作实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/27/tech/c-iic/">I2C总线实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/25/tech/c-spi/">SPI通信模块</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/19/tech/c-timer/">定时器实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/23/tech/c-gpio-flash/">GPIO的配置与Flash读写实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/26/tech/c-dma/">DMA控制器实验</a></li><li>OLED显示实验</li><li>PWM输出实验</li><li>ADC采样实验</li><li>AD变换实验</li></ol><h4 id="传感器应用实验"><a href="#传感器应用实验" class="headerlink" title="传感器应用实验"></a>传感器应用实验</h4><ol><li><a href="https://www.zhenxiangsimple.com/2019/09/17/tech/c-ultra/">超声波传感器实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/10/tech/c-hall/">霍尔传感器实验</a></li><li><a href="https://www.zhenxiangsimple.com/2019/09/18/tech/c-gyro/">陀螺仪传感器实验</a></li><li>语音信号的采集和频谱分析</li><li>语音数值滤波系统设计</li><li>卡尔曼滤波实验</li><li>加速度计的倾角估计实验</li><li>陀螺仪进行倾角估计实验</li><li>卡尔曼滤波的倾角估计实验</li></ol><h4 id="综合控制应用实验"><a href="#综合控制应用实验" class="headerlink" title="综合控制应用实验"></a>综合控制应用实验</h4><ol><li>电流PID控制实验</li><li>速度PID控制实验</li><li>位置PID控制实验</li><li>基于图像的循迹实验</li><li>走迷宫实验</li><li>上位机绘制串口数据折线图</li><li>语音控制小车实验</li></ol><center><img src="/img/proj/20200106170949302.png" title="机器人套装"></center>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 嵌入式基础 </tag>
            
            <tag> 平衡车 </tag>
            
            <tag> 自平衡机器人 </tag>
            
            <tag> 103系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式进阶 - 实验教学方案</title>
      <link href="/2020/01/01/proj/vejoeMac/"/>
      <url>/2020/01/01/proj/vejoeMac/</url>
      
        <content type="html"><![CDATA[<p>本实验箱以全向麦轮车为载体，将ARM和FPGA集成为一个实验平台进行联合实验，使用了更高配置的主控芯片，并引入实时多任务操作系统UCOS，便于学生基于当前实验平台进行更高阶的实验设计和应用开发。</p><center><img src="/img/proj/20200106173913262.png" title="全向麦轮车"></center><h2 id="机械结构"><a href="#机械结构" class="headerlink" title="机械结构"></a>机械结构</h2><ol><li>结构与材料<ul><li>铝合金底板</li><li>共轴摆式悬挂系统</li><li>4mm亚克力固定板</li><li>60mm带轴承麦轮*4</li></ul></li><li>物理参数<ul><li>尺寸267*230mm</li><li>重量约2.2kg</li><li>负载6kg<h2 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h2></li></ul></li><li>芯片<ul><li>主控芯片：STM32F407IGT6</li><li>MPU9250姿态传感器</li></ul></li><li>通信接口<ul><li>1路CAN总线通信接口</li><li>2路串口通信接口</li><li>1路蓝牙（CC2540）通信接口</li><li>1路Zigbee（CC2530）通信接口</li><li>2路232通信接口</li><li>4路42步进电机驱动接口</li></ul></li><li>核心器件<ul><li>3000MAH大容量锂电池（4S）</li><li>基于CAN总线的大功率直流电机驱动器（100W）</li><li>MG513编码器减速电机*4（减速比1:30，编码器分辨率22）</li><li>麦轮车主控板</li></ul></li><li>配件参数<ul><li>B6AC充电器（支持充放电、最大充电电流6A(80W)，最大放电电流2A(10W)，T型充电头，内置电源适配器、带背光液晶显示器、可充2S/3S/4S/5S/6S锂电池）</li><li>铝合金工具箱（55CM<em>37CM</em>22CM）</li></ul></li></ol><h2 id="实验支撑"><a href="#实验支撑" class="headerlink" title="实验支撑"></a>实验支撑</h2><h4 id="FPGA基础开发"><a href="#FPGA基础开发" class="headerlink" title="FPGA基础开发"></a>FPGA基础开发</h4><ol><li>FPGA GPIO输入输出实验</li><li>FPGA TCL脚本实验</li><li>FPGA Uart实验</li><li>FPGA FSMC接口实验</li><li>FPGA SDRAM读写实验</li><li>FPGA FIFO实验</li></ol><h4 id="UCOS实验"><a href="#UCOS实验" class="headerlink" title="UCOS实验"></a>UCOS实验</h4><ol><li>UCOS入门与单任务实验</li><li>UCOS任务处理相关实验</li><li>UCOS时间管理与软定时器实验</li><li>UCOS信号量相关实验</li><li>UCOS消息队列实验</li></ol><h4 id="嵌入式系统实验"><a href="#嵌入式系统实验" class="headerlink" title="嵌入式系统实验"></a>嵌入式系统实验</h4><ol><li>GPIO实验</li><li>KEY实验</li><li>EXTI实验</li><li>DELAY实验</li><li>USART实验</li><li>PWM实验</li><li>ADC实验</li><li>RTC实验</li><li>DMA实验</li><li>TIMER实验</li></ol><h4 id="综合控制应用实验"><a href="#综合控制应用实验" class="headerlink" title="综合控制应用实验"></a>综合控制应用实验</h4><ol><li>远程监控和巡视</li><li>多车编队实验</li><li>按照手绘曲线运动</li><li>颜色追踪与动作模式识别</li><li>动作模式识别与控制实验</li><li>运动控制（语音和APP控制）</li></ol><center><img src="/img/proj/20200106173955480.png" title="机器人套装"></center>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> 407系列 </tag>
            
            <tag> 嵌入式进阶 </tag>
            
            <tag> 麦克纳姆轮 </tag>
            
            <tag> 全向AGV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4个解法：判断回文数</title>
      <link href="/2020/01/01/tech/math-Palindrome/"/>
      <url>/2020/01/01/tech/math-Palindrome/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例 1:</p><p>输入: 121<br>输出: true<br>示例 2:</p><p>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br>示例 3:</p><p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><hr><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><center><img src="/img/tech/20200101130116460.jpg" title="解法一"></center><br>1. 直接将数值反转<br>2. 对比两个值是否相等<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> t = x,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = c*<span class="number">10</span> + t%<span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><em><br>## 解法二<br><center><img src="/img/tech/20200101130116462.png" title="解法二"></center><br> 1. 基于解法一的改版<br> 2. 不用将全部位置反转，仅反转一半数值<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x&gt;<span class="number">0</span> &amp;&amp; x%<span class="number">10</span> == <span class="number">0</span>))   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;c)</span><br><span class="line">        &#123;</span><br><span class="line">            c = c*<span class="number">10</span> + x%<span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == x || x == c/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></em></strong><br>## 解法三<br><center><img src="/img/tech/2020010113183960.png" title="解法三"></center><br>这是我的第一种写法。<br>1. 从两端向中间，依次对比单个数值是否相等<br>2. 拿掉相等的数值后，最后剩余长度如果不超过1，即为true<br><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>,idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//获取最高位</span></span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;len &gt; <span class="number">0</span>;len -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x%<span class="number">10</span> == x/((<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,len<span class="number">-1</span>)))</span><br><span class="line">            &#123;</span><br><span class="line">                x %= (<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>,len - <span class="number">1</span>);</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>***<br>## 解法四<br>转换为字符串，通过字符串的直接对比，或通过下标索引对比<br><center><img src="/img/tech/20200101131626921.png" title="解法四"></center><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPalindrome</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">string</span> xStr = x.ToString ();</span><br><span class="line">        <span class="keyword">char</span>[] xArray = xStr.ToCharArray();</span><br><span class="line">        Array.Reverse(xArray);</span><br><span class="line">        <span class="keyword">string</span> tStr = <span class="keyword">string</span>.Join(<span class="keyword">string</span>.Empty,xArray);</span><br><span class="line">        <span class="keyword">return</span> xStr.Equals(tStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 回文数 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3个解法：口算难题</title>
      <link href="/2019/12/30/tech/math-stringCalc/"/>
      <url>/2019/12/30/tech/math-stringCalc/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个方程，左边用 words 表示，右边用 result 表示。</p><p>你需要根据以下规则检查方程是否可解：</p><p>每个字符都会被解码成一位数字（0 - 9）。<br>每对不同的字符必须映射到不同的数字。<br>每个 words[i] 和 result 都会被解码成一个没有前导零的数字。<br>左侧数字之和（words）等于右侧数字（result）。<br>如果方程可解，返回 True，否则返回 False。</p><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>示例 1：</p><p>输入：words = [“SEND”,”MORE”], result = “MONEY”<br>输出：true<br>解释：映射 ‘S’-&gt; 9, ‘E’-&gt;5, ‘N’-&gt;6, ‘D’-&gt;7, ‘M’-&gt;1, ‘O’-&gt;0, ‘R’-&gt;8, ‘Y’-&gt;’2’<br>所以 “SEND” + “MORE” = “MONEY” ,  9567 + 1085 = 10652<br>示例 2：</p><p>输入：words = [“SIX”,”SEVEN”,”SEVEN”], result = “TWENTY”<br>输出：true<br>解释：映射 ‘S’-&gt; 6, ‘I’-&gt;5, ‘X’-&gt;0, ‘E’-&gt;8, ‘V’-&gt;7, ‘N’-&gt;2, ‘T’-&gt;1, ‘W’-&gt;’3’, ‘Y’-&gt;4<br>所以 “SIX” + “SEVEN” + “SEVEN” = “TWENTY” ,  650 + 68782 + 68782 = 138214<br>示例 3：</p><p>输入：words = [“THIS”,”IS”,”TOO”], result = “FUNNY”<br>输出：true<br>示例 4：</p><p>输入：words = [“LEET”,”CODE”], result = “POINT”<br>输出：false</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>2 &lt;= words.length &lt;= 5<br>1 &lt;= words[i].length, results.length &lt;= 7<br>words[i], result 只含有大写英文字母<br>表达式中使用的不同字符数最大为 10</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果将字符当作一个变量，整个算式就相当于一个多元一次方程，题目就可以看做是，求解10以内整数的多元一次方程，那么求解步骤就分为两步：</p><ol><li>将字符串整理为多元一次方程，即把字符本身当作变量，而字符所在位置的10进制和当作参数</li><li>求解多元一次方程，这个地方就需要想办法减少计算了，下面给了三个解法，用于求解多元一次方程。<center><img src="/img/tech/20191231141306551.png" title="思路"></center></li></ol><hr><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p> 基于第二个解法，做了一个优化，将字典用数组替换掉，由于方案本身并不关心具体某个字母是由哪个数值来代表，只要分别为不同的字母使用不同的数组索引即可，这样做减少的步骤是，将通过字典查找值的方式，使用数组索引代替，源码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSolvable</span>(<span class="params"><span class="keyword">string</span>[] words, <span class="keyword">string</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span>[] used = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">10</span>];</span><br><span class="line">        Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; sList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理为多元一次方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getFunction(words[i], sList,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getFunction(result, sList, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//获取变量总数</span></span><br><span class="line">        <span class="keyword">int</span>[]vArray = sList.Values.ToArray&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="comment">//求解方程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findSolution(<span class="number">0</span>, <span class="number">0</span>, vArray,used);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFunction</span>(<span class="params"><span class="keyword">string</span> str, Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chList, <span class="keyword">int</span> dir</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;<span class="comment">//计算多元一次方程的常量</span></span><br><span class="line">        <span class="keyword">int</span> tmpIdx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = str.Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (chList.ContainsKey(str[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                chList[str[j]] += tmpIdx * dir;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                chList[str[j]] = tmpIdx * dir;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIdx *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">findSolution</span>(<span class="params"><span class="keyword">int</span> idx, <span class="keyword">int</span> sum, <span class="keyword">int</span>[] vArray, <span class="keyword">bool</span>[] used</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;<span class="comment">//实际求解</span></span><br><span class="line">        <span class="keyword">if</span> (idx == vArray.Length)</span><br><span class="line">            <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[j])</span><br><span class="line">            &#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (findSolution(idx + <span class="number">1</span>, sum + j * vArray[idx],vArray,used))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>当前解法基于下面的第三种解法做了下面3个角度的优化，来减少运算内容，从而减少时间复杂度。不过，这个解法通过了大部分测试用例，但提交还是提示超时，但单独执行超时的最后一个测试用例显示150ms，可能还有个全部测试用例的整体执行时间约束：</p><ol><li>直接将等式两边值都合并到左边，只是等式右边符号设为负数，减少了查看变量个数的步骤（getKeys函数）；</li><li>求解过程的判断直接求和，判断整体是否为0，不需要再进行对比计算（checkEqual函数）；</li><li>不需要先记录下来每个变量是多少，然后再进行计算，而是在查询的时候直接计算（kList[kArray[idx]] = j;语句）</li></ol><center><img src="/img/tech/20191231141323361.png" title="解法二"></center><blockquote><p>[“YOUVE”,”NEVER”,”BEEN”,”TO”]<br>“EUROPE”</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; sList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">bool</span>[] used = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span>[] kArray;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSolvable</span>(<span class="params"><span class="keyword">string</span>[] words, <span class="keyword">string</span> result</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//整理为多元一次方程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            getFunction(words[i], sList,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getFunction(result, sList, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//获取变量总数</span></span><br><span class="line">        kArray = sList.Keys.ToArray&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">        <span class="comment">//求解方程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findSolution(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFunction</span>(<span class="params"><span class="keyword">string</span> str, Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chList, <span class="keyword">int</span> dir</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;<span class="comment">//计算多元一次方程的常量</span></span><br><span class="line">        <span class="keyword">int</span> tmpIdx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = str.Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (chList.ContainsKey(str[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                chList[str[j]] += tmpIdx * dir;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                chList[str[j]] = tmpIdx * dir;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIdx *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">findSolution</span>(<span class="params"><span class="keyword">int</span> idx,<span class="keyword">int</span> sum</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;<span class="comment">//实际求解</span></span><br><span class="line">        <span class="keyword">if</span> (idx == kArray.Length)</span><br><span class="line">            <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[j])</span><br><span class="line">            &#123;</span><br><span class="line">                used[j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (findSolution(idx + <span class="number">1</span>, sum + j * sList[kArray[idx]]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                used[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h2><p>这个是我第一次的写法，仅通过少量的测试用例，未通过的测试用例是因为超时了，后面通过解法2和解法3分别对其算法和数据结构做了优化，超时测试用例及实现源码如下：</p><p><center><img src="/img/tech/2019123114132862.png" title="解法三"></center></p><blockquote><p>[“LEET”,”CODE”]<br>“POINT”</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">        Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; sList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">        Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; rList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">        Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; kList = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">bool</span>[] used = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">char</span>[] kArray;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsSolvable</span>(<span class="params"><span class="keyword">string</span>[] words, <span class="keyword">string</span> result</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//整理为多元一次方程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                getFunction(words[i], sList);</span><br><span class="line">            &#125;</span><br><span class="line">            getFunction(result, rList);</span><br><span class="line">            <span class="comment">//获取变量总数</span></span><br><span class="line">            getKeys(kList, sList);</span><br><span class="line">            getKeys(kList, rList);</span><br><span class="line">            kArray = kList.Keys.ToArray&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">            <span class="comment">//求解方程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.findSolution(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFunction</span>(<span class="params"><span class="keyword">string</span> str, Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chList</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;<span class="comment">//计算多元一次方程的常量</span></span><br><span class="line">            <span class="keyword">int</span> tmpIdx = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = str.Length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (chList.ContainsKey(str[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    chList[str[j]] += tmpIdx;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    chList[str[j]] = tmpIdx;</span><br><span class="line">                &#125;</span><br><span class="line">                tmpIdx *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getKeys</span>(<span class="params">Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; kList, Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; sList</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;<span class="comment">//获取多元变量本身</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">char</span> k <span class="keyword">in</span> sList.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!kList.ContainsKey(k))</span><br><span class="line">                &#123;</span><br><span class="line">                    kList.Add(k, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">checkEqual</span>(<span class="params">Dictionary&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; kList</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;<span class="comment">//判断方程两边是否相等</span></span><br><span class="line">            <span class="keyword">int</span> sInt = <span class="number">0</span>, rInt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">char</span> c <span class="keyword">in</span> sList.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                sInt += sList[c] * kList[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">char</span> c <span class="keyword">in</span> rList.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                rInt += rList[c] * kList[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rInt == sInt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">findSolution</span>(<span class="params"><span class="keyword">int</span> idx</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;<span class="comment">//实际求解</span></span><br><span class="line">            <span class="keyword">if</span> (idx == kArray.Length)</span><br><span class="line">                <span class="keyword">return</span> checkEqual(kList);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    kList[kArray[idx]] = j;</span><br><span class="line">                    used[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (findSolution(idx+<span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    used[j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 多元一次方程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2个解法：最大得分的路径数目</title>
      <link href="/2019/12/29/tech/math-scorePath/"/>
      <url>/2019/12/29/tech/math-scorePath/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个正方形字符数组 board ，你从数组最右下方的字符 ‘S’ 出发。</p><p>你的目标是到达数组最左上角的字符 ‘E’ ，数组剩余的部分为数字字符 1, 2, …, 9 或者障碍 ‘X’。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p><p>一条路径的 「得分」 定义为：路径上所有数字的和。</p><p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。</p><p>如果没有任何路径可以到达终点，请返回 [0, 0] 。</p><p>示例 1：</p><p>输入：board = [“E23”,”2X2”,”12S”]<br>输出：[7,1]<br>示例 2：</p><p>输入：board = [“E12”,”1X1”,”21S”]<br>输出：[4,2]<br>示例 3：</p><p>输入：board = [“E11”,”XXX”,”11S”]<br>输出：[0,0]</p><p>提示：</p><p>2 &lt;= board.length == board[i].length &lt;= 100</p><h1 id="解法一（循环）"><a href="#解法一（循环）" class="headerlink" title="解法一（循环）"></a>解法一（循环）</h1><p>解法思路：直接使用循环，因为每个节点依赖于上一个节点，因此从最右下角的节点分别沿着横纵两个方向，一步一步移动到数组开始的左上角。</p><p>本算法使用三维数组，在第三维保存对应索引位置的初始值、得分、路径数量和是否可达四个信息，实现算法如下（比赛之后实现的）：</p><p>时间复杂度为O(n^2)，空间复杂度O(n^2)（由于使用三维数组存储）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> [,,] intBoard;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">PathsWithMaxScore</span>(<span class="params">IList&lt;<span class="keyword">string</span>&gt; board</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 链表转存到数组中</span></span><br><span class="line">        <span class="keyword">int</span> row=board.Count,column=board[<span class="number">0</span>].Length;</span><br><span class="line">        intBoard = <span class="keyword">new</span> <span class="keyword">long</span> [row,column,<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;column;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] &gt;= <span class="string">'0'</span> &amp;&amp; board[i][j] &lt;= <span class="string">'9'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    intBoard[i,j,<span class="number">0</span>] = Convert.ToInt64(board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'E'</span> || board[i][j] == <span class="string">'S'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    intBoard[i,j,<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    intBoard[i,j,<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                intBoard[i,j,<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                intBoard[i,j,<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        intBoard[row<span class="number">-1</span>,column<span class="number">-1</span>,<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//第一条路径</span></span><br><span class="line">        intBoard[row<span class="number">-1</span>,column<span class="number">-1</span>,<span class="number">3</span>] = <span class="number">1</span>;<span class="comment">//起点可达</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=column<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intBoard[i,j,<span class="number">0</span>] == <span class="number">-1</span>) <span class="keyword">continue</span>;<span class="comment">//不能访问</span></span><br><span class="line">                <span class="keyword">if</span>(intBoard[i,j,<span class="number">3</span>] == <span class="number">0</span>)  <span class="keyword">continue</span>;<span class="comment">//不可达</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    updateData(i<span class="number">-1</span>,j,intBoard[i,j,<span class="number">1</span>],intBoard[i,j,<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    updateData(i,j<span class="number">-1</span>,intBoard[i,j,<span class="number">1</span>],intBoard[i,j,<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>&amp;&amp;j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    updateData(i<span class="number">-1</span>,j<span class="number">-1</span>,intBoard[i,j,<span class="number">1</span>],intBoard[i,j,<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;(<span class="keyword">int</span>)intBoard[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],(<span class="keyword">int</span>)intBoard[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateData</span>(<span class="params"><span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">long</span> lastMaxVal,<span class="keyword">long</span> lastMaxCount</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(intBoard[r,c,<span class="number">3</span>] == <span class="number">0</span> || intBoard[r,c,<span class="number">1</span>] &lt; intBoard[r,c,<span class="number">0</span>] + lastMaxVal)</span><br><span class="line">        &#123;</span><br><span class="line">            intBoard[r,c,<span class="number">1</span>] = intBoard[r,c,<span class="number">0</span>] + lastMaxVal;        </span><br><span class="line">            intBoard[r,c,<span class="number">2</span>] = lastMaxCount;</span><br><span class="line">            intBoard[r,c,<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(intBoard[r,c,<span class="number">1</span>] == intBoard[r,c,<span class="number">0</span>] + lastMaxVal)</span><br><span class="line">        &#123;</span><br><span class="line">            intBoard[r,c,<span class="number">1</span>] = intBoard[r,c,<span class="number">0</span>] + lastMaxVal; </span><br><span class="line">            intBoard[r,c,<span class="number">2</span>] += lastMaxCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(intBoard[r,c,<span class="number">2</span>] &gt;= <span class="number">1000000007</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            intBoard[r,c,<span class="number">2</span>] %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二（递归）"><a href="#解法二（递归）" class="headerlink" title="解法二（递归）"></a>解法二（递归）</h1><p>解法思路：由于满足递归三要素：1.任务可以分解（可以向左上遍历），2.分解后和原任务实现原理一样（都是向左上遍历），3.结束条件明确（到[0,0]位置），因此选择通过递归实现。</p><ol><li>为了增加访问效率，最开始申请一个数组，代替使用链表索引的方式访问</li><li>通过递归将所有通路的得分，存储到一个新的结果链表中</li><li>对结果链表中的得分进行统计，最终输出结果</li></ol><p>问题：方案本身可行，但时间复杂度有点高，有优化的空间，在参加比赛过程中，通过了一多半的测试用例，最终卡在了一个测试用例上，因为超时了，超时的测试用例及实现代码如下：</p><blockquote><p>[“E4789338X943596124X2676X552X587877X456943458X29735”,”611684759486631913932337237231351921X2152919376427”,”4499519117827344997451XX34X46693XX7181343557483669”,”414951X685152X89829782685X4912581351X3216914721551”,”X387271851925X3629265X99195X5897581179XX369637813X”,”1X8X2682518937289551X98X7983XX34993116413343558825”,”X92X12119593186X675113X682143777XX8981619298251984”,”X671798198463X5314971262X9392393XXX544537813812728”,”81856146535454X3678775784456289257XX8221X2488XXX68”,”77X3592XX94844399282X2X6336122XX7X18244862821X26XX”,”28885X948512X3585X27824186222X73X9X56441X9X4689517”,”344X495X682875968X82X9877379XX386748175X6293X44159”,”1924352186149295919715X27X555626X17798524189528625”,”3435681879X49727366745492X648X5952772978787143263X”,”412933788234154913356X2X9X144818X21XX5629259785133”,”489644765X456XX44XX2X5387637879X662941398337817381”,”7617826679176XX173173537173164967296764519X3427693”,”7X69X5466277665871135253486758156766536X5436X16728”,”318152574426X696X18X833396113X31862234511611X89691”,”X147492241256344555237X94772X9X5136226469551942X29”,”X29846X49419853778154XX636X35XX5232391787617416258”,”8885851X996538X163323347235993741926591X72X1761X14”,”226X8136988863232963682217521777419144333838517835”,”3197757518X241117949451X423XX55861XX6161938551X752”,”49X149355329X617X51X21965452X962X42762X25968X73754”,”X1176483834957794897816132X5X942366794665183797399”,”48294674492176X1X663644X58X17729X4482638X92X482422”,”51X16X157889846864X1436338776687677X44895154219626”,”782XX82XX432848434721692X55564975938X2649681569663”,”26792517214X8863X9896XX64619817916123168945761X526”,”X7XX319393797X184679X421943743279X1486126364341595”,”11425763X68563511X2496983325426X151456X5X459542989”,”89872654932254X5525587692326476X65562X59X635129314”,”6X944371656471737X9673645X4145X821X942995885X86522”,”64XX328X8243XX3445X6412955X87X42355234X73223243421”,”944391299X158X962X9X259552884441434XX9349X5XX79855”,”98422711429356771336494176X56X2584376X2354X72X5416”,”7135X7X9X3X699929714X61664916968X1896X5X1985386642”,”22969X77414X2154167176388X3313X918X1558161XX413862”,”4X141958614412616921588565488847635X837996835937X6”,”X416X64649X955369739187781488XX77129X6966899351X74”,”9X2349175X345X7469265842X591X4748167996963X63X7211”,”3117349374592412365636726147X52469X8921X1888159627”,”254513X73629359514989286822X7X89391797X357546X9145”,”8882877128738295914941X56995X243888XX595873XX99217”,”X947591X382X19613453263544415821689719794546655278”,”51X4565271954965486X492693X731844471486X149X7166X5”,”731X1816268181645946X2123376981X13X834338226X28X36”,”6X72X3599546159X378191718821X746789239488712584143”,”5982153336X61729X66339596838X77751396645929982913S”]</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; scoreList;</span><br><span class="line">    <span class="keyword">int</span> idx =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">PathsWithMaxScore</span>(<span class="params">IList&lt;<span class="keyword">string</span>&gt; board</span>)</span> &#123;</span><br><span class="line">        scoreList = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="comment">//1. 链表转存到数组中</span></span><br><span class="line">        <span class="keyword">int</span> row=board.Count,column=board[<span class="number">0</span>].Length;</span><br><span class="line">        <span class="keyword">int</span> [,] intBoard = <span class="keyword">new</span> <span class="keyword">int</span> [row,column];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;column;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                intBoard[i,j] = Convert.ToInt32(board[i][j] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        getPaths(intBoard, row- <span class="number">1</span>, column- <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(scoreList.Count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 3. 对结果进行统计</span></span><br><span class="line">        <span class="keyword">int</span> maxScore = scoreList[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;scoreList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scoreList[i] &gt; maxScore)</span><br><span class="line">            &#123;</span><br><span class="line">                maxScore = scoreList[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;scoreList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scoreList[i] == maxScore)</span><br><span class="line">            &#123;</span><br><span class="line">               count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span> []&#123;maxScore,count&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPaths</span>(<span class="params"><span class="keyword">int</span> [,] board,<span class="keyword">int</span> row,<span class="keyword">int</span> colum,<span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> &amp;&amp; colum == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scoreList.Add(count);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board[row,colum] == <span class="number">40</span>)<span class="comment">//遇到X即退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[row,colum] != <span class="number">35</span>)&#123;<span class="comment">//不是起点S则累计</span></span><br><span class="line">            count += board[row,colum];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//向左递归</span></span><br><span class="line">            getPaths(board,row<span class="number">-1</span>,colum,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(colum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//向上递归</span></span><br><span class="line">            getPaths(board,row,colum - <span class="number">1</span>,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;<span class="number">0</span> &amp;&amp; colum &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;<span class="comment">//向左上递归</span></span><br><span class="line">            getPaths(board,row<span class="number">-1</span>,colum - <span class="number">1</span>,count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 循环 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 非递归 </tag>
            
            <tag> 泛型集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式攻防进阶（C#举例）</title>
      <link href="/2019/12/24/tech/design-single/"/>
      <url>/2019/12/24/tech/design-single/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><hr><p>单例模式本身是避免类的对象多次实例化，但总会有各种花式破解之术，以懒汉式单例模式为例进行举例说明。</p><h2 id="一般写法"><a href="#一般写法" class="headerlink" title="一般写法"></a>一般写法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 懒汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> objLock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo demoItem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (objLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    demoItem = <span class="keyword">new</span> Demo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一次攻防（编译器优化）"><a href="#第一次攻防（编译器优化）" class="headerlink" title="第一次攻防（编译器优化）"></a>第一次攻防（编译器优化）</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demoItem = <span class="keyword">new</span> Demo();</span><br></pre></td></tr></table></figure><h4 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h4><p>当通过上面过程实例化的时候，其执行过程不是原子性的，至少会经过如下三个步骤：</p><ol><li>分配内存</li><li>执行构造方法</li><li>指向地址</li></ol><p>由于指令重排，导致线程执行下面实例化的时候，可能跳过第二步执行了第三步，如果此时另一个线程进来，发现Demo已经不为空直接返回，并且后面使用了返回的Demo，由于第一个线程还未执行第二步，因此会导致Demo的实例不完整，可能会出现意想不到的错误。</p><h4 id="完善"><a href="#完善" class="headerlink" title="完善"></a>完善</h4><p>可以通过为变量增加Volatile声明，volatile 关键字指示一个字段可以由多个同时执行的线程修改，声明为 volatile 的字段不受编译器优化（假定由单个线程访问）的限制，这样可以确保该字段在任何时间呈现的都是最新的值。结果如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 懒汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> objLock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo demoItem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (objLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    demoItem = <span class="keyword">new</span> Demo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二次攻防（反射）"><a href="#第二次攻防（反射）" class="headerlink" title="第二次攻防（反射）"></a>第二次攻防（反射）</h2><h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>如果通过反射实例化，这可以轻松避开上面的单例，示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Demo item1 = Demo.getInstance();</span><br><span class="line">        </span><br><span class="line">        Type t = Type.GetType(<span class="string">"single.Demo"</span>);</span><br><span class="line">        ConstructorInfo[] tInfoArray= t.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        Demo item2 = (Demo)tInfoArray[<span class="number">0</span>].Invoke(<span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line">        Console.WriteLine(item1.GetHashCode());</span><br><span class="line">        Console.WriteLine(item2.GetHashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.StackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下，从打印结果可以看出，生成了两个不同的实例：<br><img src="/img/tech/20191224105355840.png" width="200px" height="100px"></p><h4 id="防守"><a href="#防守" class="headerlink" title="防守"></a>防守</h4><p>对于这种情况，只需要在构造函数中增加限制即可，在私有构造函数中如果Demo实例不为空，表示已经被创建了，如果通过正常的GetInstance调用，是不会出现问题的，因此可以直接抛出异常。修改后的代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 懒汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> objLock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (objLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (demoItem != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不要试图用反射破坏单例模式"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo demoItem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (objLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    demoItem = <span class="keyword">new</span> Demo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20191224104940895.png" width="200px" height="100px"></p><h2 id="第三次攻防（双反射）"><a href="#第三次攻防（双反射）" class="headerlink" title="第三次攻防（双反射）"></a>第三次攻防（双反射）</h2><h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><p>上面的方案可以解决反射前已经创建实例的情况，但是如果两次都是通过反射来进行实例化，则可以绕过该判断，调用代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Demo item1 = Demo.getInstance();</span></span><br><span class="line">        </span><br><span class="line">        Type t = Type.GetType(<span class="string">"single.Demo"</span>);</span><br><span class="line">        ConstructorInfo[] tInfoArray= t.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        Demo item2 = (Demo)tInfoArray[<span class="number">0</span>].Invoke(<span class="literal">null</span>);</span><br><span class="line">        Demo item3 = (Demo)tInfoArray[<span class="number">0</span>].Invoke(<span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line">        Console.WriteLine(item3.GetHashCode());</span><br><span class="line">        Console.WriteLine(item2.GetHashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.StackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20191224105303949.png" width="200px" height="100px"></p><h4 id="防守-1"><a href="#防守-1" class="headerlink" title="防守"></a>防守</h4><p>对于全部通过反射来绕过私有构造函数中的判断，可以增加额外的标志位进行检测和判断，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 懒汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> InstanceFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> objLock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">lock</span> (objLock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (InstanceFlag == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                InstanceFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不要试图用反射破坏单例模式"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo demoItem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (objLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    demoItem = <span class="keyword">new</span> Demo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20191224110232312.png" width="200px" height="100px"></p><h2 id="第四次攻防（反射再反射）"><a href="#第四次攻防（反射再反射）" class="headerlink" title="第四次攻防（反射再反射）"></a>第四次攻防（反射再反射）</h2><h4 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击"></a>攻击</h4><p>尽管通过标志位可以避免直接通过反射实例化多个实体，但是标志位本身是可以通过反射进行修改的，因此可以通过反射修改标志位的值来进行攻击，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Demo item1 = Demo.getInstance();</span></span><br><span class="line">        </span><br><span class="line">        Type t = Type.GetType(<span class="string">"single.Demo"</span>);</span><br><span class="line">        ConstructorInfo[] tInfoArray = t.GetConstructors(BindingFlags.NonPublic | BindingFlags.Instance);</span><br><span class="line">        Demo item2 = (Demo)tInfoArray[<span class="number">0</span>].Invoke(<span class="literal">null</span>);</span><br><span class="line">        FieldInfo field = t.GetField(<span class="string">"InstanceFlag"</span>,BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Static);</span><br><span class="line">        field.SetValue(t, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        Demo item3 = (Demo)tInfoArray[<span class="number">0</span>].Invoke(<span class="literal">null</span>); </span><br><span class="line"></span><br><span class="line">        Console.WriteLine(item3.GetHashCode());</span><br><span class="line">        Console.WriteLine(item2.GetHashCode());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.StackTrace);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20191224112603431.png" width="200px" height="100px"></p><h4 id="防守-2"><a href="#防守-2" class="headerlink" title="防守"></a>防守</h4><p>目前也还没想到更好的方案应对该攻击，<strong>可能</strong>，并没有一个完美的方案去避免通过反射破坏单例模式，欢迎各位留言交流。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> C# </tag>
            
            <tag> 攻防 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础单例模式（C#举例）</title>
      <link href="/2019/12/24/tech/design-single-general/"/>
      <url>/2019/12/24/tech/design-single-general/</url>
      
        <content type="html"><![CDATA[<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>默认直接实例化的情况比较简单直接，缺点在于类一启动就申请了内存空间，即使没有被调用，因此有了第二种懒汉式写法，即在实际使用的时候才进行实例化来申请内存。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 饿汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo1</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo1 demoItem = <span class="keyword">new</span> Demo1();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Demo1 <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式的单例保证了线程安全，也可以进行慢加载，只有在用到的时候才进行初始化和申请内存，调用效率比较高。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 懒汉式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> objLock = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo2</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo2 demoItem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo2 <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (objLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (demoItem == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    demoItem = <span class="keyword">new</span> Demo2();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h2><p>这种写法通过在类中定义一个静态的内部类，在静态类中定义静态变量来进行访问，既保证了线程安全，也满足了慢加载。<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 内部静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo3</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">InnerHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Demo3 demoItem = <span class="keyword">new</span> Demo3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Demo3 <span class="title">getInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerHelper.demoItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尽管通过private可以阻挡常规的调用的多次实例化，但是在一些极端的情况下，可能会有一定的问题，具体过程请点击查看：<a href="https://www.zhenxiangsimple.com/2019/12/24/tech/design-single/">单例模式攻防进阶</a>（<a href="https://www.zhenxiangsimple.com/2019/12/24/tech/design-single/）。">https://www.zhenxiangsimple.com/2019/12/24/tech/design-single/）。</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> C# </tag>
            
            <tag> 懒汉式 </tag>
            
            <tag> 饿汉式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组一般从0开始，而不是习惯的1</title>
      <link href="/2019/12/19/tech/c-array/"/>
      <url>/2019/12/19/tech/c-array/</url>
      
        <content type="html"><![CDATA[<p>我们常用的开发语言，比如C语言，C#，Java，Nodejs，Swift等，他们的数组起始编号都是0，这个原因究竟是什么，已经很难回滚到历史开始的阶段进行追溯，不过，我们也可以做一些分析和猜测。</p><h1 id="1-索引更快速"><a href="#1-索引更快速" class="headerlink" title="1. 索引更快速"></a>1. 索引更快速</h1><p>数组本身的杀手锏技能，当通过索引随机访问时，对应的时间复杂度是O(1)，由于数组是线性表结构，而数组的索引访问时，其线性表结构决定访问时可以通过索引直接计算出目标索引对应的地址值，以0开头的索引可以直接用索引值本身来计算，跟1开头时相比少一次减一操作，作为最常用的数组，以0开头可以减少一次CPU的计算。<br>或者可以理解为，数组的索引本身指的是偏移量，相对于第一个索引位置的偏移量。</p><h1 id="2-历史遗留问题"><a href="#2-历史遗留问题" class="headerlink" title="2. 历史遗留问题"></a>2. 历史遗留问题</h1><p>C语言选择了以0开头，而作为最早被广泛学习和接受，或者说大学里面普及度相对较高的高级编程语言，其它C#，Java等实际工程中用到的编程语言，为了减少迁移成本，所以继续沿用了从0开头。</p><h1 id="3-其实也有例外"><a href="#3-其实也有例外" class="headerlink" title="3. 其实也有例外"></a>3. 其实也有例外</h1><p>当然，也不是所有编程语言都是从零开头的整数，其实也有语言不是这么设计的，比如Matlab的.m程序就是从1开始的，Python数组索引可以是负值，用负值表示方向，也只是范围读取（类似Matlab），当然Python默认也是从0开始。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《一本有趣又有料的科学书》</title>
      <link href="/2019/12/12/books/%E4%B8%80%E6%9C%AC%E6%9C%89%E8%B6%A3%E5%8F%88%E6%9C%89%E6%96%99%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B9%A6/"/>
      <url>/2019/12/12/books/%E4%B8%80%E6%9C%AC%E6%9C%89%E8%B6%A3%E5%8F%88%E6%9C%89%E6%96%99%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>最开始想读是因为看到说柴静和老罗都在推荐，然后买来很快翻完的一本书，内容还可以，可以当作休闲娱乐的书来翻一翻，其实没太搞懂他们为什么推荐，不知道是好玩，还是被套路了，还是说纯粹为了恰饭。</p><p>本书像一本成人版的十万个为什么，跟少儿版的比，对概念或知识的讲解相对更科学、更理性，有些内容的描述也需要一定的知识积累。</p><p>尽管本书解答的为什么比较少，一共47个冷门的知识点，有些东西还是比较好玩的，比如，男人为什么长乳头，好吧，也不说什么了，列下目录供参考。</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><pre><code>1. “一天”到底有多长 ?2. 为什么冥王星不是行星 ?3. 为什么欧洲国家的国旗大多是三色旗 ?4. 金属光泽从哪儿来 ?5. 旋涡和地球自转有没有关系 ?6. iPad 会让你的孩子近视吗 ?7. 进化论如何解释生物的拟态 ?8. 向日葵是怎样转头的 ?9. 为什么绝大多数海螺都向右旋转 ?10. 猫和狗的味觉怎样 ?11. 为什么哺乳动物很少有毒 ?12. 蛤蟆真的能冬眠一百万年吗 ?13. 真的有“脸盲症”这种病吗 ?14. 男人为什么长乳头 ?15. 为什么男人没有“阴道” ?16. 人为什么要换牙 ?17. 人的正常体温为什么是 37℃ ?18. 为什么年龄越大感觉时间过得越快 ?19. 恐龙是怎么分类的 ?20. 为什么同寝室女生的月经周期会趋同 ?21. 为什么游泳学会了不会忘 ?22. 为什么有的人一定要午睡 ?23. 为什么男人到中年容易脱发 ?24. 为什么大型草食动物要比大型肉食动物大 ?25. 吹多了空调真的容易感冒吗 ?26. 晒被子的味道是不是烤螨虫的味道 ?27. 卫生巾发明前，来例假怎么办 ?28. 为什么用黄色来表示色情 ?29. 为什么没有绿色的哺乳动物 ?30. 胎教是哪国发明的 ?31. 人为什么要穿内裤 ?32. 各国供电的电压和频率为什么不一样 ?33. 尼古拉·特斯拉真有那么神奇吗 ?34. 为什么鸡可以天天下蛋，而别的鸟不行 ?35. 地图为什么总是上北下南 ?36. 为什么火箭发射时要倒计时 ?37. 大象这么大，排便会不会很辛苦 ?38. 为什么大型动物的排便速度能够遥遥领先 ?39. 为什么近几年发现的大钻石那么多 ?40. 鞋带为何总会自己松开 ?41. 眼睛是怎么进化出来的 ?42. 舌头真的用不同部位负责不同味觉吗 ?43. 为什么会有疾病 ?44. 静脉血管为什么是蓝色的 ?45. 为何昆虫的成虫和幼虫完全不像 ?46. 为什么台风都有个名字 ?47. 大象的鼻子为什么这么长 ?</code></pre><center><img src="/img/books/一本有趣又有料的科学书.jpg" width="150" height="200" title="一本有趣又有料的科学书 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 为什么 </tag>
            
            <tag> 科普读物 </tag>
            
            <tag> 大象公会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《以眨眼干杯》</title>
      <link href="/2019/11/26/books/%E4%BB%A5%E7%9C%A8%E7%9C%BC%E5%B9%B2%E6%9D%AF/"/>
      <url>/2019/11/26/books/%E4%BB%A5%E7%9C%A8%E7%9C%BC%E5%B9%B2%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p>这本书是一部日本的长篇推理小说，是一个比较完整的故事，基于密室逃脱案件为起点，通过刑侦专家坚持不懈的刨根问底，最终真相大白于天下，其实看完也没太理解标题的名字和小说内容的关系。</p><p>整体故事情节还算比较紧凑，全篇基本以对话形式进行描述；最开始铺垫的比较多，中间展开也算是循序渐进，最后阶段基本真相大白，作者还是用简短文字进行了详细解释说明。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>第一次关注到东野圭吾，是在电影院看的一次电影“嫌疑人X的献身”，电影故事里展现了两位数学天才之间的智力较量，印象比较深的一句话就是“出一道别人解不出的题和解出这道题，哪个比较难?”，以此开始对东野圭吾有所了解，发现作者是一位高产的小说家。</p><p>东野圭吾的不少小说都已经拍摄成了电影，看完整本书就感觉是直接看电影一样，人物情节的描述和心里活动都比较具体详细，前期对一些人物性格的塑造也泼墨如水，刻画的形象让人印象深刻，可能也是这个原因，很多导演选择他的作品来拍摄影视剧。</p><p>尽管小说中的人物名字都是日本人的特点，但只要当作一个基本的代号就可以了，而且小说中名字只显示了两个字，可能日语本来就是这个习惯，可能作者为了便于小说推广故意为之，也可能是译者按照中文阅读习惯做的优化，跟冰与火之歌相比，名字更容易辨识和记忆。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>小说通过一个做礼仪小姐的拜金女【小田香子】视角来讲述，香子的同事【绘里】在参加完一个酒会后死在了化妆间，警察定案的结论是自杀，理由就是化妆间只有一个仅能从里锁上的门，而绘里死亡时候刚好是从里面锁上的，刑警推理的整个情节就像罪犯密室逃脱的推理故事。</p><p>刑警通过到绘里老家了解到她有个前男友，前男友是一个画家，也是自杀而死，写了一份遗书但遗书的字面信息很少，无法得到案件的有效信息，后来偶然机会发现了遗书背后的玄机，是一个磁带盒（2000左右比较流行听歌）和一幅个人画像，将嫌疑人画像隐藏在自杀前的一幅画里面，而把故事通过字迹写在磁带上，最终确定了嫌疑人。</p><p>过程中也引入了部分人，有的是增加了故事的趣味性或饱满性，有的是保证了案件的完整度或破案的突破口，比如绘里在东京的闺蜜【由加利】，也是一位礼仪小姐，最终因为案件被卷进来然后被杀了，即使把这个人从故事里去掉，也没什么太大影响，有这个人物会让故事更饱满和紧凑；比如礼仪小姐主管【江崎洋子】，一方面，她的协助将案情故事连起来了，另一方面，她的单纯也是破案的突破口。</p><center><img src="/img/books/以眨眼干杯.jpg" width="150" height="200" title="以眨眼干杯 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 东野圭吾 </tag>
            
            <tag> 密室逃脱 </tag>
            
            <tag> 日本 </tag>
            
            <tag> 犯罪小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式实验 之 I2C实验（IIC）</title>
      <link href="/2019/09/27/tech/c-iic/"/>
      <url>/2019/09/27/tech/c-iic/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><ul><li>掌握I2C协议的内容，了解I2C接口的特点。</li><li>了解陀螺仪MPU6050的用途及数据采集过程。</li><li>熟悉STM32F10xx系列微控制器的I2C配置，完成通过I2C读取陀螺仪MPU6050数据的实验。<h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2>I2C (Inter－Integrated Circuit)协议是由Phiilps公司开发的，由于它具引脚少，硬件实现简单，可扩展性强，不需要如USART、CAN的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。<h3 id="一、I2C总线协议："><a href="#一、I2C总线协议：" class="headerlink" title="一、I2C总线协议："></a>一、I2C总线协议：</h3>I2C总线在传送数据过程中共有三种类型信号，它们分别是：开始信号、结束信号和应答信号。</li><li>开始信号：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。</li><li>结束信号：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li><li>应答信号：接收数据的IC在接收到8bit数据后，向发送数据的IC发出特定的低电平脉冲，表示已收到数据。CPU向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。</li></ul><p>这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要。</p><h3 id="二、I2C接口特性"><a href="#二、I2C接口特性" class="headerlink" title="二、I2C接口特性"></a>二、I2C接口特性</h3><ol><li>STM32的中等容量和大容量型号的芯片均有多达2个的I2C总线接口。</li><li>能够工作于多主模式或从模式，分别为主接收器，主发送器，从接收器及从发。</li><li>支持标准模式100Kbit/s和快速模式400Kbit/s，不支持高速模式。</li><li>支持7位或10位寻址。</li><li>内置了硬件CRC发生器/校验器。</li><li>I2C的接收和发送都可以使用DMA操作。</li><li>支持系统管理总线(SMBus)总线2.0版。</li></ol><h3 id="三、MPU6050相关"><a href="#三、MPU6050相关" class="headerlink" title="三、MPU6050相关"></a>三、MPU6050相关</h3><p>MPU-6050为9轴运动处理传感器。它集成了3轴陀螺仪，3轴加速度计，以及一个可扩展的数字运动处理器DMP（Digital Motion Processor），可用I2C接口连接一个第三方的数字传感器，比如磁力计。MPU-6050对陀螺仪和加速度计分别用了三个16位的ADC，将其测量的模拟量转化为可输出的数字量。MPU-6050上所有设备寄存器之间的通信采用400kHz的I2C接口。另外，片上还内嵌了一个温度传感器和在工作环境下仅有±1%变动的振荡器。</p><h3 id="四、硬件连接和库函数介绍"><a href="#四、硬件连接和库函数介绍" class="headerlink" title="四、硬件连接和库函数介绍"></a>四、硬件连接和库函数介绍</h3><p><img src="https://img-blog.csdnimg.cn/20190927233059195.png" alt="在这里插入图片描述"><br>图1 硬件连接示意图<br>本实验中使用的库函数主要有unsigned char I2C_ReadOneByte(unsigned char I2C_Addr,unsigned char addr)，其功能为读取指定设备，指定寄存器的一个值，其参数分别为：<br>I2C_Addr：目标设备地址，在我们的实验中为陀螺仪和加速度计的地址。<br>Addr：寄存器地址，即存放陀螺仪信息和加速度计信息的寄存器地址</p><h3 id="五、软件流程图"><a href="#五、软件流程图" class="headerlink" title="五、软件流程图"></a>五、软件流程图</h3><p>本实验项目需要包涵oled.c显示屏库函数、MPU6050.c运动传感器库函数、delay.c延时库函数，本实验的实验流程图如图2所示：</p><p>图2 实验流程示意图</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>双轮自平衡机器人。如图3所示，平衡车所搭载的电路板上已经搭载MPU6050芯片。<br>ST-Link下载器（包含USB线与下载线）。如图4所示。</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Windows7/8/10，32bit/64bit</p><p><img src="https://img-blog.csdnimg.cn/20190927233119536.png" alt="在这里插入图片描述"><br>图3 双轮自平衡机器人<br><img src="https://img-blog.csdnimg.cn/20190927233128389.png" alt="在这里插入图片描述"><br>图4 ST-Link下载器与下载线</p><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>Keil 5<br>实验场地：<br>无</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="第一步-配置工程环境"><a href="#第一步-配置工程环境" class="headerlink" title="第一步 配置工程环境"></a>第一步 配置工程环境</h3><p>打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如图5所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。<br><img src="https://img-blog.csdnimg.cn/2019092723321339.png" alt="在这里插入图片描述"><br>图5工程模板对应的文件夹<br>在HARDWARE文件夹下右键导入已存在文件IOI2C.c和IOI2C.h文件，这两个文件保存在工程目录下MiniBalance_HARDWARE文件夹中IIC文件夹内，如图6所示。<br><img src="https://img-blog.csdnimg.cn/20190927233219505.png" alt="在这里插入图片描述"><br>图6 在HARDWARE文件夹下导入IOI2C.c和IOI2C.h文件</p><h3 id="第二步-编写IIC实现函数"><a href="#第二步-编写IIC实现函数" class="headerlink" title="第二步 编写IIC实现函数"></a>第二步 编写IIC实现函数</h3><p>打开刚刚导入程序中的IOI2C.h文件，可以发现文件里已经预定义了许多函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------IIC的操作函数---------------------------------*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;                        <span class="comment">//初始化IIC的IO口                int IIC_Start(void);                        //发送IIC 开始信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;                    <span class="comment">//发送IIC停止信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span>;             <span class="comment">//IIC发送一个字节</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_Read_Byte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ack)</span></span>;        <span class="comment">//IIC读取一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>;                 <span class="comment">//IIC等待ACK信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span>;                 <span class="comment">//IIC发送ACK信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span>;                    <span class="comment">//IIC不发送ACK信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Write_One_Byte</span><span class="params">(u8 daddr,u8 addr,u8 data)</span></span>; <span class="comment">//将一个字节写入指定设备,指定寄存器</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_Read_One_Byte</span><span class="params">(u8 daddr,u8 addr)</span></span>;  <span class="comment">//读取指定设备,指定寄存器中的一个字节</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">I2C_Readkey</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> I2C_Addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">I2C_ReadOneByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> I2C_Addr,<span class="keyword">unsigned</span> <span class="keyword">char</span> addr)</span></span>;<span class="comment">//读取指定设备,指定寄存器的一个值</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">IICwriteByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> dev, <span class="keyword">unsigned</span> <span class="keyword">char</span> reg, <span class="keyword">unsigned</span> <span class="keyword">char</span> data)</span></span>;<span class="comment">// 写入指定设备,指定寄存器一个字节</span></span><br><span class="line"><span class="function">u8 <span class="title">IICwriteBytes</span><span class="params">(u8 dev, u8 reg, u8 length, u8* data)</span></span>; <span class="comment">//将多个字节写入指定设备,指定寄存器</span></span><br><span class="line"><span class="function">u8 <span class="title">IICwriteBits</span><span class="params">(u8 dev,u8 reg,u8 bitStart,u8 length,u8 data)</span></span>;<span class="comment">//读,修改,写指定设备,指定寄存器一个字节中的多个位</span></span><br><span class="line"><span class="function">u8 <span class="title">IICwriteBit</span><span class="params">(u8 dev,u8 reg,u8 bitNum,u8 data)</span></span>;<span class="comment">//读,修改,写指定设备,指定寄存器一个字节中的1个位</span></span><br><span class="line"><span class="function">u8 <span class="title">IICreadBytes</span><span class="params">(u8 dev, u8 reg, u8 length, u8 *data)</span></span>;<span class="comment">//读取指定设备,指定寄存器的 length个值</span></span><br></pre></td></tr></table></figure></p><p>打开程序中的IOI2C.c文件,编写IIC的IO口初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"><span class="comment">//使能GPIOB端口时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"><span class="comment">//端口配置</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11;</span><br><span class="line"><span class="comment">//推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line"><span class="comment">//50M</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="comment">//根据设定的参数初始化GPIOB</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在IOI2C.c文件中，编写IIC_Start函数，产出IIC起始信号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();      <span class="comment">//sda线输出</span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!READ_SDA)  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line"> IIC_SDA=<span class="number">0</span>; <span class="comment">//开始:当CLK线即时钟线处于高电平时,数据线从高电平变为低电平</span></span><br><span class="line"><span class="keyword">if</span>(READ_SDA)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;      <span class="comment">//钳住I2C总线，准备发送或接收数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在IOI2C.c文件中，编写IIC_Stop函数，产出IIC停止信号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();          <span class="comment">//sda线输出</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;  <span class="comment">//停止:当CLK线即时钟线处于高电平时,数据线从低电平变为高电平</span></span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;          <span class="comment">//发送I2C总线结束信号</span></span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了减轻任务量，其他IIC操作函数已经编写完成，并在IOI2C.c中给出。<br><img src="https://img-blog.csdnimg.cn/20190927233348817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>表1  IOI2C.c中已编写函数</p><h3 id="第三步-编写main-c文件"><a href="#第三步-编写main-c文件" class="headerlink" title="第三步 编写main.c文件"></a>第三步 编写main.c文件</h3><p>将工程编译需要用到的头文件包含进来，并且定义相关变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ioi2c.h"</span>          <span class="comment">//IIC头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>            <span class="comment">//包含体统头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span>      <span class="comment">//包含系统寄存器定义声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> Accel_Y,Accel_Angle,Accel_Z,Gyro_X,Gyro_Z;  <span class="comment">//定义加速度计和陀螺仪变量</span></span><br><span class="line">在主函数中调用延时函数、IIC初始化函数、MPU6050初始化函数、OLED屏幕初始化函数。</span><br><span class="line">delay_init();               <span class="comment">//调用延时函数</span></span><br><span class="line">IIC_Init();             <span class="comment">//调用IIC初始化函数</span></span><br><span class="line">MPU6050_initialize();       <span class="comment">//调用MPU6050初始化函数</span></span><br><span class="line">OLED_Init();                <span class="comment">//调用OLED初始化函数</span></span><br></pre></td></tr></table></figure></p><p>在主函数中，加入主循环，并编写IIC读取程序，以读取陀螺仪加速度计信息。其中，使用的函数主要为<br>unsigned char I2C_ReadOneByte(unsigned char I2C_Addr,unsigned char addr)，其功能为读取指定设备，指定寄存器的一个值，<br>I2C_Addr：目标设备地址，在我们的实验中为陀螺仪和加速度计的地址。<br>Addr：寄存器地址，即存放陀螺仪信息和加速度计信息的寄存器地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)                <span class="comment">//进入主循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*----------------------------读取X轴陀螺仪信息-------------------------*/</span></span><br><span class="line"><span class="comment">// devAddr : MPU6050的设备地址</span></span><br><span class="line"><span class="comment">// MPU6050_RA_GYRO_XOUT_H :Gyro_X数值的寄存器地址</span></span><br><span class="line">Gyro_X=(I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_XOUT_H)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">+I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_XOUT_L);</span><br><span class="line"><span class="comment">/*----------------------------读取Z轴陀螺仪信息-------------------------*/</span></span><br><span class="line">Gyro_Z=(I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_ZOUT_H)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">+I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_ZOUT_L);</span><br><span class="line"><span class="comment">/*----------------------------读取Y轴加速度计信息-------------------------*/</span></span><br><span class="line">Accel_Y=(I2C_ReadOneByte(devAddr,MPU6050_RA_ACCEL_YOUT_H)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">+I2C_ReadOneByte(devAddr,MPU6050_RA_ACCEL_YOUT_L);</span><br><span class="line"><span class="comment">/*----------------------------读取Z轴加速度计信息-------------------------*/</span></span><br><span class="line">Accel_Z=(I2C_ReadOneByte(devAddr,MPU6050_RA_ACCEL_ZOUT_H)&lt;&lt;<span class="number">8</span>)</span><br><span class="line">+I2C_ReadOneByte(devAddr,MPU6050_RA_ACCEL_ZOUT_L);</span><br><span class="line"><span class="comment">/*----------------------------数据类型转换，-------------------------*/</span></span><br><span class="line">        <span class="keyword">if</span>(Gyro_X&gt;<span class="number">32768</span>)  Gyro_X-=<span class="number">65536</span>;</span><br><span class="line">        <span class="keyword">if</span>(Gyro_Z&gt;<span class="number">32768</span>)  Gyro_Z-=<span class="number">65536</span>;</span><br><span class="line">        <span class="keyword">if</span>(Accel_Y&gt;<span class="number">32768</span>)  Accel_Y-=<span class="number">65536</span>;</span><br><span class="line">        <span class="keyword">if</span>(Accel_Z&gt;<span class="number">32768</span>)  Accel_Z-=<span class="number">65536</span>; </span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>在main.c中，编写显示函数oled_show(),并在主循环中调用oled_show()函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OLED_ShowString(<span class="number">00</span>,<span class="number">10</span>,<span class="string">"Gyro_X"</span>);</span><br><span class="line">    OLED_ShowNumber(<span class="number">95</span>,<span class="number">10</span>,Gyro_X,<span class="number">5</span>,<span class="number">12</span>);</span><br><span class="line">    OLED_ShowString(<span class="number">00</span>,<span class="number">20</span>,<span class="string">"Gyro_Z"</span>);</span><br><span class="line">    OLED_ShowNumber(<span class="number">95</span>,<span class="number">20</span>,Gyro_Z,<span class="number">5</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    OLED_ShowString(<span class="number">00</span>,<span class="number">30</span>,<span class="string">"Accel_Y"</span>);</span><br><span class="line">    OLED_ShowNumber(<span class="number">95</span>,<span class="number">30</span>,Accel_Y,<span class="number">5</span>,<span class="number">12</span>);</span><br><span class="line">    OLED_ShowString(<span class="number">00</span>,<span class="number">40</span>,<span class="string">"Accel_Z"</span>);</span><br><span class="line">    OLED_ShowNumber(<span class="number">95</span>,<span class="number">40</span>,Accel_Z,<span class="number">5</span>,<span class="number">12</span>);</span><br><span class="line">    OLED_Refresh_Gram();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四步-编译并下载，观察实验现象"><a href="#第四步-编译并下载，观察实验现象" class="headerlink" title="第四步 编译并下载，观察实验现象"></a>第四步 编译并下载，观察实验现象</h3><p>本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图7所示。<br><img src="https://img-blog.csdnimg.cn/20190927233529293.png" alt="在这里插入图片描述"><br>图7 仿真器与下载线连接图<br>编译程序：点击如图8所示的编译按键。<br><img src="https://img-blog.csdnimg.cn/20190927233536872.png" alt="在这里插入图片描述"><br>图8  Keil编译环境下的编译按键<br>当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图9所示。<br><img src="https://img-blog.csdnimg.cn/20190927233549186.png" alt="在这里插入图片描述"><br>图9 编译通过后Build Output栏提示信息<br>下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如图1.10所示。<br><img src="https://img-blog.csdnimg.cn/20190927233555655.png" alt="在这里插入图片描述"><br>图10 Keil编译环境下的下载按键<br>观察实验现象，在小车的OLED显示屏上能够实时的显示出小车当前采集到的陀螺仪加速度计信息，微微晃动小车，可以看到显示屏上的数值有明显变化。<br><img src="https://img-blog.csdnimg.cn/2019092723360394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图11 平衡车上OLED显示屏</p><h2 id="【思考题】"><a href="#【思考题】" class="headerlink" title="【思考题】"></a>【思考题】</h2><h3 id="1、选择题"><a href="#1、选择题" class="headerlink" title="1、选择题"></a>1、选择题</h3><p>题目1：下面哪个结构体是设置I2C传输速率（C）<br>A：I2C_AcknowledgeAddress<br>B：I2C_DutyCycle<br>C：I2C_ClockSpeed<br>D：I2C_OwnAddress1</p><p>题目2：在I2C协议中，起始信号后产生的信号是哪种信号？（A）<br>A：地址位<br>B：传输方向选择位</p><h3 id="2、简答题"><a href="#2、简答题" class="headerlink" title="2、简答题"></a>2、简答题</h3><p>题目1：I2C有几种传输模式，速率分别是多少？<br>具有三种传输模式：标准模式传输速率为100kbit/s，快速模式为400kbit/s，高速模式下可达3.4Mbit/s，但目前大多I2C设备尚不支持高速模式。</p><h2 id="附录：I2C-库函数"><a href="#附录：I2C-库函数" class="headerlink" title="附录：I2C 库函数"></a>附录：I2C 库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190927233614453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> IIC </tag>
            
            <tag> I2C </tag>
            
            <tag> 通信协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式实验 之 DMA控制器实验</title>
      <link href="/2019/09/26/tech/c-dma/"/>
      <url>/2019/09/26/tech/c-dma/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><ul><li>掌握单片机DMA的工作原理，以及在STM32单片机上实现DMA传输的配置和流程；<ul><li>了解DMA传输方式相对与传统利用CPU传输方式的优势；</li><li>完成以 DMA 的方式给数据赋值并显示在OLED显示屏上的实验。<h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2>DMA (Direct Memory Access)，直接存储器存取，是一种可以大大减轻CPU 工作量的数据存取方式，因而被广泛地使用。外设工作的时候，除了转移数据，实质上是不需要内核进行干预的，而如果数据转移的工作现在也交给了另一个外设，那么在该外设进行工作的时候，内核同时还可以进行其它操作。而STM32 的 DMA 模块正是以类似外设的形式，添加到 Cortex 内核之外，进行数据转移工作的。<h3 id="一、DMA功能简介："><a href="#一、DMA功能简介：" class="headerlink" title="一、DMA功能简介："></a>一、DMA功能简介：</h3>单片机的硬件系统，通常主要由 CPU(内核)、外设、内存(SRAM)、总线等结构组成，在系统工作中，数据经常要在各项设备之间进行转移。通常情况下，在转移数据的过程中会占用 CPU 十分宝贵的资源，所以我们希望 CPU 更多地被用在数据运算或响应中断之中，而数据转移的工作交由其它部件完成。DMA 恰恰为 CPU 分担了这部分数据转移的工作。因为 DMA 的存在， CPU 被解放出来，它可以在 DMA 转移数据的过程中同时进行数据运算，响应中断，大大提高了系统的运行效率。</li></ul></li></ul><p>在 STM32 中，DMA 的传输模式分为3种：</p><ol><li>外设到存储器的传输。</li><li>存储器到存储器的传输。</li><li><p>存储器到外设的传输。</p><h3 id="二、DMA工作过程分析"><a href="#二、DMA工作过程分析" class="headerlink" title="二、DMA工作过程分析"></a>二、DMA工作过程分析</h3><p>由 DMA 控制器挂载在AHB(高级高性能总线)上，与内核共享数据总线。DMA控制器在收到一个传输命令后，开始访问源地址寄存器中储存的地址，并加载该地址对应的数据，然后将数据存储到目标地址寄存器中指定的地址上去。在完成一次数据转移后，DMA内记录数据总数的寄存器执行一次减一操作，然后根据预先设定的传输模式决定是否对源/目标地址进行位移操作。例如，若是从外设（GPIO或其他有固定接口的设备）到存储器的传输，则在执行一次操作后，只需目标地址进行位移，源地址不变；而若是从存储器到存储器的传输，则需要同时将源地址和目标地址进行位移。</p><h3 id="三、DMA库函数分析"><a href="#三、DMA库函数分析" class="headerlink" title="三、DMA库函数分析"></a>三、DMA库函数分析</h3><p>DMA_InitTypeDef结构体参数的配置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_PeripheralBaseAddr;        <span class="comment">// DMA 外设基地址 </span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_MemoryBaseAddr;        <span class="comment">//DMA 内存基地址 </span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_DIR; <span class="comment">//规定了外设是作为数据传输的目的地还是来源    </span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_BufferSize;                <span class="comment">// DMA 缓存的大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_PeripheralInc;             <span class="comment">// 外设地址寄存器递增与否 </span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_MemoryInc;             <span class="comment">// 内存地址寄存器递增与否       uint32_t DMA_PeripheralDataSize;       // 外设数据宽度</span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_MemoryDataSize;            <span class="comment">// 内存数据宽度</span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_Mode;                  <span class="comment">// 工作模式</span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_Priority;                  <span class="comment">// DMA 软件优先级 </span></span><br><span class="line"><span class="keyword">uint32_t</span> DMA_M2M;                   <span class="comment">//非否内存到内存传输</span></span><br><span class="line">&#125;DMA_InitTypeDef;</span><br></pre></td></tr></table></figure></li><li><p>DMA_PeripheralBaseAddr：外设地址，设定 DMA_CPAR 寄存器的值；一般设置为外设的数据寄存器地址，如果是存储器到存储器模式则设置为其中一个存储器地址。</p></li><li>DMA_Memory0BaseAddr：存储器地址，设定 DMA_CMAR 寄存器值；一般设置为我们自定义存储区的首地址。</li><li>DMA_DIR：传输方向选择，可选外设到存储器、存储器到外设。它设定DMA_CCR 寄存器的 DIR[1:0]位的值。 这里并没有存储器到存储器的方向选择，当使用存储器到存储器时，只需要把其中一个存储器当作外设使用即可。<br>4) DMA_BufferSize：设定待传输数据数目，初始化设定 DMA_CNDTR 寄存器的值。<br>5) DMA_PeripheralInc：如果配置为 DMA_PeripheralInc_Enable，使能外设地址自动递增功能，它设定 DMA_CCR 寄存器的 PINC 位的值；一般外设都是只有一个数据寄存器，所以一般不会使能该位。<br>6) DMA_MemoryInc：如果配置为 DMA_MemoryInc_Enable，使能存储器地址自动递增功能，它设定 DMA_CCR 寄存器的 MINC 位的值；我们自定义的存储区一般都是存放多个数据的，所以要使能存储器地址自动递增功能。<br>7) DMA_PeripheralDataSize： 外设数据宽度，可选字节(8 位)、半字(16位)和字(32位)，它设定 DMA_CCR 寄存器的 PSIZE[1:0]位的值。<br>8) DMA_MemoryDataSize：存储器数据宽度，可选字节(8 位)、半字(16 位)和字(32位)，它设定 DMA_CCR 寄存器的 MSIZE[1:0]位的值。 当外设和存储器之间传数据时，两边的数据宽度应该设置为一致大小。<br>9) DMA_Mode： DMA 传输模式选择，可选一次传输或者循环传输，它设定DMA_CCR 寄存器的 CIRC 位的值。 例程我们的 ADC 采集是持续循环进行的，所以使用循环传输模式。<br>10) DMA_Priority：软件设置通道的优先级，有 4 个可选优先级分别为非常高、高、中和低，它设定 DMA_CCR 寄存器的 PL[1:0]位的值。 DMA 通道优先级只有在多个 DMA 通道同时使用时才有意义，如果是单个通道，优先级可以随便设置。<br>11) DMA_M2M：存储器到存储器模式 ，使用存储器到存储器时用到设定DMA_CCR 的位14 MEN2MEN 即可启动存储器到存储器模式。<h3 id="四、软件流程图"><a href="#四、软件流程图" class="headerlink" title="四、软件流程图"></a>四、软件流程图</h3><img src="https://img-blog.csdnimg.cn/20191009180330852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图1 实验程序流程示意图<h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="硬件设备："><a href="#硬件设备：" class="headerlink" title="硬件设备："></a>硬件设备：</h3>双轮自平衡机器人。如图2所示，平衡车所搭载的电路板主控芯片STM32内部有DMA，另外，电路上已经预留接口并安装了OLED显示屏。<br>ST-Link下载器（包含USB线与下载线）。如图3所示。<h3 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h3>Windows7/8/10，32bit/64bit<br><img src="https://img-blog.csdnimg.cn/20190926220202279.png" alt="在这里插入图片描述"><br>图2 双轮自平衡机器人<br><img src="https://img-blog.csdnimg.cn/20190926220218112.png" alt="在这里插入图片描述"><br>图3 ST-Link下载器与下载线<h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3>Keil 5，串口助手软件<br>实验场地：<br>无<h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="一、-配置工程环境"><a href="#一、-配置工程环境" class="headerlink" title="一、 配置工程环境"></a>一、 配置工程环境</h3>打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLIB文件夹，如图4所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。在本实验中，oled模块的设备函数已经在oled.c的文件中给出。<br><img src="https://img-blog.csdnimg.cn/20190926220240724.png" alt="在这里插入图片描述"><br>图4 工程模板对应的文件夹<br>在HARDWARE文件夹下新建两个文件，分别为dma.c和dma.h。分别存放DMA控制函数与DMA头文件，如图5所示。<br><img src="https://img-blog.csdnimg.cn/20190926220246536.png" alt="在这里插入图片描述"><br>图5 在HARDWARE文件夹下建立dma.c与dma.h文件<h3 id="二、-完成DMA配置，并开启时钟"><a href="#二、-完成DMA配置，并开启时钟" class="headerlink" title="二、 完成DMA配置，并开启时钟"></a>二、 完成DMA配置，并开启时钟</h3>2.1 打开程序中的dma.c文件，首先将dma.h文件包含进来。其次对DMA_Config函数进行编写，对DMA的地址通信模式等进行配置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dma.h"</span>    <span class="comment">//包含头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_Config</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*定义一个GPIO_ InitTypeDef类型的结构体*/</span></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line"><span class="comment">/*定义一个GPIO_ InitTypeDef类型的结构体*/</span></span><br><span class="line">DMA_DeInit(DMA1_Channel1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)使能DMA时钟</span></span><br><span class="line"><span class="comment">/*开启DMA时钟*/</span></span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)初始化DMA通道参数</span></span><br><span class="line">        <span class="comment">/*配置源地址*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&amp;number_origin;  </span><br><span class="line"><span class="comment">/*配置目标地址*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&amp;number_target;</span><br><span class="line"><span class="comment">/*配置DMA的传输方向*/</span></span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line"><span class="comment">/*配置缓冲区大小*/</span></span><br><span class="line">DMA_InitStructure.DMA_BufferSize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*配置在完成单次转移后是否对源地址进行位移*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc= DMA_PeripheralInc_Disable;</span><br><span class="line"><span class="comment">/*配置在完成单次转移后是否对目标地址进行位移*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;</span><br><span class="line"><span class="comment">/*配置DMA每次访问的源地址长度*/</span></span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize =                                                          DMA_PeripheralDataSize_HalfWord;</span><br><span class="line"><span class="comment">/*配置DMA每次访问的目标地址长度*/</span></span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize =                                                                  DMA_MemoryDataSize_HalfWord;</span><br><span class="line"><span class="comment">/*配置DMA的传输模式*/</span></span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line"><span class="comment">/*配置DMA的优先级*/</span></span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_High;</span><br><span class="line"><span class="comment">/*配置DMA是否可以进行内存到内存的转移*/</span></span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line"><span class="comment">/*将以上配置进行部署*/</span></span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)使能DMA通道，启动传输</span></span><br><span class="line"><span class="comment">/*使能DMA传输*/</span></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>2.2 打开dma.h文件，添加DMA_Config 函数声明及外部变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __DMA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">uint16_t</span> number_origin;    <span class="comment">//引用已经定义的外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">uint16_t</span> number_target;    <span class="comment">//引用已经定义的外部变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_Config</span><span class="params">(<span class="keyword">void</span>)</span></span>;        <span class="comment">//声明函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h3 id="三、-编写main-c文件"><a href="#三、-编写main-c文件" class="headerlink" title="三、 编写main.c文件"></a>三、 编写main.c文件</h3><p>将工程编译需要用到的头文件包含进来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span>    <span class="comment">//包含系统寄存器定义声明的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>          <span class="comment">//包含系统文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span>        <span class="comment">//包含延时函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dma.h"</span>          <span class="comment">//包含DMA头文件</span></span></span><br></pre></td></tr></table></figure></p><p>定义待转移的源地址及目标地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> number_origin=<span class="number">123</span>;        <span class="comment">//待转移的源地址</span></span><br><span class="line"><span class="keyword">uint16_t</span> number_target=<span class="number">0</span>;          <span class="comment">//待转移的目标地址</span></span><br></pre></td></tr></table></figure></p><p>预定义oled屏幕显示函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span>;      <span class="comment">//oled屏幕显示函数</span></span><br></pre></td></tr></table></figure></p><p>在主函数中调用延时函数与OLED初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delay_init();     <span class="comment">//调用延时函数</span></span><br><span class="line">OLED_Init();    <span class="comment">//调用OLED初始化函数</span></span><br></pre></td></tr></table></figure></p><p>在主函数中，更新源地址内容并调用显示函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">delay_init();         <span class="comment">//延时函数初始化</span></span><br><span class="line">OLED_Init();        <span class="comment">//OLED屏幕显示初始化</span></span><br><span class="line">DMA_Config();        <span class="comment">//DMA初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;   </span><br><span class="line">    DMA_Cmd(DMA1_Channel1, ENABLE);   <span class="comment">//调用DMA传输 </span></span><br><span class="line">    number_origin++;</span><br><span class="line">    delay_ms(<span class="number">500</span>);</span><br><span class="line">    oled_show();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主函数下面新建oled_show函数，并编写显示函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">50</span>,<span class="string">"DMA_NUM_O"</span>);  <span class="comment">//在指定位置显示文字信息</span></span><br><span class="line">OLED_ShowNumber(<span class="number">85</span>,<span class="number">50</span>,number_origin,<span class="number">3</span>,<span class="number">12</span>); <span class="comment">//在指定位置显示数字信息</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">30</span>,<span class="string">"DMA_NUM_T"</span>);</span><br><span class="line">OLED_ShowNumber(<span class="number">85</span>,<span class="number">30</span>,number_target,<span class="number">3</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">/*=============刷新=======================*/</span></span><br><span class="line">OLED_Refresh_Gram();    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、-编译并下载，观察实验现象"><a href="#四、-编译并下载，观察实验现象" class="headerlink" title="四、 编译并下载，观察实验现象"></a>四、 编译并下载，观察实验现象</h3><p>本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图6所示。<br><img src="https://img-blog.csdnimg.cn/20190926220556129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图6 仿真器与下载线连接图<br>编译程序：点击如图7所示的编译按键。<br><img src="https://img-blog.csdnimg.cn/20190926220607262.png" alt="在这里插入图片描述"><br>图7  Keil编译环境下的编译按键<br>当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图8所示。<br><img src="https://img-blog.csdnimg.cn/20190926220615263.png" alt="在这里插入图片描述"><br>图8 编译通过后Build Output栏提示信息<br>下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如图9所示。<br><img src="https://img-blog.csdnimg.cn/20190926220621468.png" alt="在这里插入图片描述"><br>图9 Keil编译环境下的下载按键<br>观察实验现象，如图12所示。重新上电以后，OLED显示屏上显示的DMA_NUM_O后数字从初始设定的123开始，每隔0.5秒加一。DMA_NUM_T紧跟着DMA_NUM_O变化。<br><img src="https://img-blog.csdnimg.cn/20190926220628938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图10 平衡车上的小灯LED2</p><h2 id="【思考题】"><a href="#【思考题】" class="headerlink" title="【思考题】"></a>【思考题】</h2><h3 id="1、选择题"><a href="#1、选择题" class="headerlink" title="1、选择题"></a>1、选择题</h3><p>题目1：  下面哪条语句是设置串口数据寄存地址？（A）<br>A：DMA_InitStructure.DMA_PeripheralBaseAddr = 0x40004C04;<br>B：DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;<br>C：DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;<br>D：DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</p><p>题目2：  在DMA进行数据转移时，内核可以进行其它操作吗？（A）<br>A：可以<br>B：不可以</p><h3 id="2、简答题"><a href="#2、简答题" class="headerlink" title="2、简答题"></a>2、简答题</h3><p>题目1：DMA的工作意义是什么？<br>在转移数据的过程中会占用 CPU 十分宝贵的资源，所以我们希望 CPU 更多地被用在数据运算或响应中断之中，而数据转移的工作交由其它部件完成。DMA 正为 CPU 分担了数据转移的工作。因为 DMA 的存在， CPU 被解放出来，它可以在 DMA 转移数据的过程中同时进行数据运算，响应中断，大大提高效率。</p><h2 id="附录：DMA-库函数"><a href="#附录：DMA-库函数" class="headerlink" title="附录：DMA 库函数"></a>附录：DMA 库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190926220643942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> dma </tag>
            
            <tag> 存取 </tag>
            
            <tag> 数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式实验 之 SPI通信实验</title>
      <link href="/2019/09/25/tech/c-spi/"/>
      <url>/2019/09/25/tech/c-spi/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>1、通过实验了解SPI的通信模式及配置过程。<br>2、通过使用SPI与蓝牙模块NRF2401进行通信，送内部数据到蓝牙模块并读取从蓝牙主机上发送的控制信息，了解蓝牙模块的配置和通信过程。</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>SPI 协议(Serial Peripheral Interface)，即串行外围设备接口，是一种高速全双工的通信总线，它由摩托罗拉公司提出，当前最新的为 V04.01-2004 版。它被广泛地使用在 ADC、 LCD 等设备与 MCU 间通讯的场合。SPI通讯设备之间常用连接方式如图1所示。<br><img src="https://img-blog.csdnimg.cn/20190925173701597.png" alt="在这里插入图片描述"><br>图1  常见的SPI通讯系统</p><h3 id="一、SPI原理"><a href="#一、SPI原理" class="headerlink" title="一、SPI原理"></a>一、SPI原理</h3><p>SPI 接口一般使用 4 条线： MISO 主设备数据输入，从设备数据输出。 MOSI 主设备数据输出，从设备数据输入SCLK 时钟信号，由主设备产生。CS 从设备片选信号，由主设备控制。根据 SPI 时钟极性(CPOL)和时钟相位(CPHA) 配置的不同，分为四种 SPI 模式。时钟极性是指 SPI 通讯设备处于空闲状态时SCK 信号线的电平信号。时钟相位是指数据的采样的时刻。</p><h3 id="二、SPI特性"><a href="#二、SPI特性" class="headerlink" title="二、SPI特性"></a>二、SPI特性</h3><p>SPI 主要特点有：可以同时发出和接收串行数据；可以当作主机或从机工作； 提供频率可编程时钟；发送结束中断标志；写冲突保护；总线竞争保护等。<br>SPI 模块为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟极性和相位可以进行配置，时钟极性（CPOL）对传输协议没有重大的影响。如果CPOL=0，串行同步时钟的空闲状态为低电平；如果 CPOL=1，串行同步时钟的空闲状态为高电平。时钟相位（CPHA）能够配置用于选择两种不同的传输协议之一进行数据传输。如果CPHA=0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；如果 CPHA=1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。SPI 主模块和与之通信的外设备时钟相位和极性应该一致。</p><h3 id="三、SPI库函数分析"><a href="#三、SPI库函数分析" class="headerlink" title="三、SPI库函数分析"></a>三、SPI库函数分析</h3><p>跟其他外设一样，STM32标准库提供了SPI初始化结构体及初始化函数来配置SPI外设。初始化结构体及函数定义在库文件“stm32f4xx_spi.h”和“stm32f4xx_spi.c”中。<br>SPI初始化结构体为SPI_InitTypeDef，其中包含：<br><img src="https://img-blog.csdnimg.cn/20190925173719263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>表1  SPI_InitTypeDef配置</p><p>配置完这些结构体成员后，我们要调用库函数：<br>SPI_Init(SPI_TypeDef<em> SPIx, SPI_InitTypeDef</em> SPI_InitStruct)<br>把这些参数写入到寄存器中，实现 SPI 的初始化，然后调用库函数：SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState) 来使能 SPI 外设。</p><p>在进行SPI发送数据时我们需要用到库函数：SPI_I2S_GetFlagStatus(SPI_TypeDef<em> SPIx, uint16_t SPI_I2S_FLAG)<br>来判断指定的SPI的标志位，在本实验中，检查指定的SPI标志位设置与否:发送缓存空标志位。<br>SPI_I2S_SendData(SPI_TypeDef</em> SPIx, uint16_t Data)来发送指定的数据。</p><p>在进行SPI接受数据时我们需要用到库函数：<br>SPI_I2S_GetFlagStatus(SPI_TypeDef<em> SPIx, uint16_t SPI_I2S_FLAG)<br>来判断指定的SPI的标志位，在本实验中，检查指定的SPI标志位设置与否:接受缓存非空标志位。<br>SPI_I2S_ReceiveData(SPI_TypeDef</em> SPIx)通过SPIx最近接受的数据。</p><h3 id="四、蓝牙模块NRF2401"><a href="#四、蓝牙模块NRF2401" class="headerlink" title="四、蓝牙模块NRF2401"></a>四、蓝牙模块NRF2401</h3><p>nRF24L01是一款工作在2.4~2.5GHz世界通用ISM频段的单片无线收发器芯片。无线收发器包括：频率发生器、增强型SchockBurst模式控制器、功率放大器、晶体振荡器、调制器、解调器、输出功率、频道选择和协议的设置可以通过SPI接口进行设置。极低的电流消耗：当工作在发射模式下发射功率为-6dBm时电流消耗为9.0mA，接收模式时为12.3mA，掉电模式和待机模式下电流消耗更低。</p><h3 id="五、软件流程图"><a href="#五、软件流程图" class="headerlink" title="五、软件流程图"></a>五、软件流程图</h3><p><img src="https://img-blog.csdnimg.cn/20190925173801706.png" alt="在这里插入图片描述"><br>图2  程序流程图</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Windows7/8/10，32bit/64bit</p><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>小车所搭载的电路板主控芯片留有蓝牙调试端口，可以通过SPI连接蓝牙设备发送数据进行调试。</p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>Keil 5，串口助手软件</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="一、配置工程环境"><a href="#一、配置工程环境" class="headerlink" title="一、配置工程环境"></a>一、配置工程环境</h3><p>1.1 在操作之前需要把关于GPIO,SPI,USART等的库文件添加到工程模板之中。在添加这些库文件之前需要把与stm32f10x_xxx.c 文件对应的一个 stm32f10x_xxx.h 头文也包含进我们的工程中才能够使用这些外设库。如图3所示。<br><img src="https://img-blog.csdnimg.cn/20190925173817113.png" alt="在这里插入图片描述"><br>图3 所需的头文件</p><h3 id="二、开启时钟，完成端口初始化"><a href="#二、开启时钟，完成端口初始化" class="headerlink" title="二、开启时钟，完成端口初始化"></a>二、开启时钟，完成端口初始化</h3><p>2.1 打开程序中的spi.c文件，对SPI1_init函数进行编写和修改。在这个函数中我们调用了库函数 RCC_APB2PeriphClockCmd()初始化SPI1 和 GPIOC 的时钟。<br>2.2 GPIO端口时钟初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*对GPIOC端口进行初始化设置*/</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;   </span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE );  <span class="comment">//初始化时钟</span></span><br></pre></td></tr></table></figure></p><p>2.3 GPIO 端口模式设置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;             <span class="comment">//复用推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;            <span class="comment">//GPIO速率</span></span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);                        <span class="comment">//GPIO初始化</span></span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);</span><br></pre></td></tr></table></figure></p><p>2.4 对SPI进行初始化配置，使用SPI初始化结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; </span><br><span class="line">    <span class="comment">//设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工          </span></span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master;</span><br><span class="line"><span class="comment">//设置SPI工作模式:设置为主SPI</span></span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line"><span class="comment">//设置SPI的数据大小:SPI发送接收8位帧结构</span></span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;</span><br><span class="line"><span class="comment">//选择了串行时钟的稳态:时钟悬空高</span></span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;</span><br><span class="line"><span class="comment">//数据捕获于第二个时钟沿</span></span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;   </span><br><span class="line"><span class="comment">//NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制</span></span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler =                    SPI_BaudRatePrescaler_256  </span><br><span class="line"><span class="comment">//定义波特率预分频的值:波特率预分频值为256</span></span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; </span><br><span class="line">    <span class="comment">//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始     </span></span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//CRC值计算的多项式</span></span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line">   <span class="comment">//根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器，这里我们初始化的是  SPI1</span></span><br></pre></td></tr></table></figure></p><p> 2.5 使能SPI。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPI_Cmd(SPI1, ENABLE);</span><br><span class="line"><span class="comment">//使能SPI外设SPI1</span></span><br><span class="line">    SPI1_ReadWriteByte(<span class="number">0xff</span>);</span><br><span class="line"><span class="comment">//启动传输</span></span><br></pre></td></tr></table></figure></p><p>2.6 设置SPI的传输速率。<br><img src="https://img-blog.csdnimg.cn/2019092517395493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图4  SPI控制寄存器1结构图<br>通过SPI的控制寄存器1设置SPI的传输速率，如图4所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI1_SetSpeed</span><span class="params">(u8 SpeedSet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SPI1-&gt;CR1&amp;=<span class="number">0XFFC7</span>;      <span class="comment">//将第3位，第4位，第5位清零</span></span><br><span class="line">SPI1-&gt;CR1|=SpeedSet;         <span class="comment">//设置SPI1速度  </span></span><br><span class="line">    SPI1-&gt;CR1|=<span class="number">1</span>&lt;&lt;<span class="number">6</span>;        <span class="comment">//SPI设备使能 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.7 编写SPI读写字节函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPIx 读写一个字节</span></span><br><span class="line"><span class="comment">//TxData:要写入的字节</span></span><br><span class="line"><span class="comment">//返回值:读取到的字节</span></span><br><span class="line"><span class="function">u8 <span class="title">SPI1_ReadWriteByte</span><span class="params">(u8 TxData)</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">        u8 retry=<span class="number">0</span>;                 </span><br><span class="line">        <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET) </span><br><span class="line">          <span class="comment">//检查指定的SPI标志位设置与否:发送缓存空标志位</span></span><br><span class="line">         &#123;</span><br><span class="line">              retry++;</span><br><span class="line">              <span class="keyword">if</span>(retry&gt;<span class="number">200</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//超时退出</span></span><br><span class="line">         &#125;  <span class="comment">//判断数据寄存器中是否有数据，若没有，则写入我们的数据</span></span><br><span class="line">          SPI_I2S_SendData(SPI1, TxData);   <span class="comment">//通过外设SPIx发送一个数据</span></span><br><span class="line">          retry=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)== RESET)</span><br><span class="line">          <span class="comment">//检查指定的SPI标志位设置与否:接受缓存非空标志位</span></span><br><span class="line">           &#123;</span><br><span class="line">              retry++;</span><br><span class="line">              <span class="keyword">if</span>(retry&gt;<span class="number">200</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//超时退出</span></span><br><span class="line">    &#125;       <span class="comment">//判断数据寄存器中是否有数据，若有，则将其读取出来   </span></span><br><span class="line"> <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1); <span class="comment">//返回通过SPIx最近接收的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在24L01.c中编辑传输函数。<br>因为24L01程序较为复杂，建议使用参考例程。仅做初始化配置。</p><h3 id="三、编写SPI模块"><a href="#三、编写SPI模块" class="headerlink" title="三、编写SPI模块"></a>三、编写SPI模块</h3><p>3.1 初始化24L01的IO口。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化24L01的IO口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NRF24L01_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|</span><br><span class="line">RCC_APB2Periph_GPIOC, ENABLE );         <span class="comment">//PC5端口设置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_PP ; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOC,GPIO_Pin_5);</span><br><span class="line">        <span class="comment">//PB12端口设置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode =GPIO_Mode_Out_PP ; <span class="comment">//推挽输出</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure); </span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">        <span class="comment">//PC4端口设置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU ;  <span class="comment">//上拉输入</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_SetBits(GPIOC,GPIO_Pin_4);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// NRF24L01_CE和NRF24L01_CSN的定义在24l01.h中</span></span><br><span class="line">    NRF24L01_CE=<span class="number">0</span>;  <span class="comment">//使能24L01</span></span><br><span class="line">        NRF24L01_CSN=<span class="number">1</span>; <span class="comment">//SPI片选取消</span></span><br></pre></td></tr></table></figure></p><p>3.2编写基于SPI的24L01读写函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SPI写寄存器</span></span><br><span class="line"><span class="comment">//reg:指定寄存器地址</span></span><br><span class="line"><span class="comment">//value:写入的值</span></span><br><span class="line"><span class="function">u8 <span class="title">NRF24L01_Write_Reg</span><span class="params">(u8 reg,u8 value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 status;  </span><br><span class="line">     NRF24L01_CSN=<span class="number">0</span>;           <span class="comment">//使能SPI传输</span></span><br><span class="line">        status =SPI1_ReadWriteByte(reg);<span class="comment">//发送寄存器号 </span></span><br><span class="line">        SPI1_ReadWriteByte(value);    <span class="comment">//写入寄存器的值</span></span><br><span class="line">        NRF24L01_CSN=<span class="number">1</span>;           <span class="comment">//禁止SPI传输    </span></span><br><span class="line">        <span class="keyword">return</span>(status);                 <span class="comment">//返回状态值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取SPI寄存器值</span></span><br><span class="line"><span class="comment">//reg:要读的寄存器</span></span><br><span class="line"><span class="function">u8 <span class="title">NRF24L01_Read_Reg</span><span class="params">(u8 reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            u8 reg_val;     </span><br><span class="line">        NRF24L01_CSN = <span class="number">0</span>;             <span class="comment">//使能SPI传输     </span></span><br><span class="line">        SPI1_ReadWriteByte(reg);         <span class="comment">//发送寄存器号</span></span><br><span class="line">        reg_val=SPI1_ReadWriteByte(<span class="number">0XFF</span>);<span class="comment">//读取寄存器内容</span></span><br><span class="line">        NRF24L01_CSN = <span class="number">1</span>;             <span class="comment">//禁止SPI传输         </span></span><br><span class="line">        <span class="keyword">return</span>(reg_val);                  <span class="comment">//返回状态值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、编写main函数和控制模块"><a href="#四、编写main函数和控制模块" class="headerlink" title="四、编写main函数和控制模块"></a>四、编写main函数和控制模块</h3><p>通过蓝牙遥控器控制小车<br>4.1 控制语句编写在程序control.c文件中。因为在24L01和按键程序中已经对输入信号做了处理，因此只需判断蓝牙发送的数据是何种控制命令即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">函数功能：采集遥控器的信号</span></span><br><span class="line"><span class="comment">入口参数：无</span></span><br><span class="line"><span class="comment">返回  值：无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Get_MC6</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(Flag_Left==<span class="number">0</span>&amp;&amp;Flag_Right==<span class="number">0</span>) <span class="comment">//判断左转和右转标志位是否为零</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>((Remoter_Ch1&gt;<span class="number">1650</span>&amp;&amp;Remoter_Ch1&lt;<span class="number">2100</span>)</span><br><span class="line">||(Remoter_Ch1&gt;<span class="number">21650</span>&amp;&amp;Remoter_Ch1&lt;<span class="number">22100</span>))   </span><br><span class="line">Flag_Qian=<span class="number">1</span>,Flag_Hou=<span class="number">0</span>,Flag_sudu=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//判断遥控接收变量Remoter_Ch1</span></span><br><span class="line">                <span class="comment">//////////////前进</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((Remoter_Ch1&lt;<span class="number">1350</span>&amp;&amp;Remoter_Ch1&gt;<span class="number">900</span>)                                         ||(Remoter_Ch1&lt;<span class="number">21350</span>&amp;&amp;Remoter_Ch1&gt;<span class="number">20900</span>))</span><br><span class="line">Flag_Qian=<span class="number">0</span>,Flag_Hou=<span class="number">1</span>,Flag_sudu=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//////////////后退</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((Remoter_Ch1&gt;<span class="number">1350</span>&amp;&amp;Remoter_Ch1&lt;<span class="number">1650</span>)                                       ||(Remoter_Ch1&gt;<span class="number">21350</span>&amp;&amp;Remoter_Ch1&lt;<span class="number">21650</span>))       Flag_Qian=<span class="number">0</span>,Flag_Hou=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//////////////停</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Flag_Qian==<span class="number">0</span>&amp;&amp;Flag_Hou==<span class="number">0</span>)<span class="comment">//判断前进和后退标志位是否为零</span></span><br><span class="line">&#123;           </span><br><span class="line"><span class="keyword">if</span>((Remoter_Ch2&gt;<span class="number">1650</span>&amp;&amp;Remoter_Ch2&lt;<span class="number">2100</span>)</span><br><span class="line">||(Remoter_Ch2&gt;<span class="number">21650</span>&amp;&amp;Remoter_Ch2&lt;<span class="number">22100</span>))</span><br><span class="line">Flag_Left=<span class="number">1</span>,Flag_Right=<span class="number">0</span>,Flag_sudu=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//判断遥控接收变Remoter_Ch2</span></span><br><span class="line">                <span class="comment">//////////////左转</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((Remoter_Ch2&lt;<span class="number">1350</span>&amp;&amp;Remoter_Ch2&gt;<span class="number">900</span>)                                         ||(Remoter_Ch2&lt;<span class="number">21350</span>&amp;&amp;Remoter_Ch2&gt;<span class="number">20900</span>))</span><br><span class="line">Flag_Left=<span class="number">0</span>,Flag_Right=<span class="number">1</span>,Flag_sudu=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//////////////右转</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((Remoter_Ch2&gt;<span class="number">1350</span>&amp;&amp;Remoter_Ch2&lt;<span class="number">1650</span>)                                       ||(Remoter_Ch2&gt;<span class="number">21350</span>&amp;&amp;Remoter_Ch2&lt;<span class="number">21650</span>))</span><br><span class="line">Flag_Left=<span class="number">0</span>,Flag_Right=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//////////////停</span></span><br><span class="line">            &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="五、编译并下载程序到小车。"><a href="#五、编译并下载程序到小车。" class="headerlink" title="五、编译并下载程序到小车。"></a>五、编译并下载程序到小车。</h3><p><img src="https://img-blog.csdnimg.cn/20190925174121277.png" alt="在这里插入图片描述"><br>图5  Keil编译环境下的下载按键</p><h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><p>题目1：下面哪条语句是设置SPI通讯数据的大小（D）<br>A：SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;<br>B：SPI_InitStructure.SPI_BaudRatePrescaler =                                                                         SPI_BaudRatePrescaler_256;<br>C：SPI_InitStructure.SPI_Mode = SPI_Mode_Master;<br>D：SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; </p><p>题目2：在对SPI进行初始化时，涉及到的端口应该设置成哪种模式？（A）<br>A：复用推挽输出<br>B：复用开漏输出</p><h3 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h3><p>题目1：SPI的片选线（CS）设置是必需的吗？</p><p>CS线用于控制片选信号。当一个SPI从设备的CS线识别到了预先规定的片选电平，则表示该设备被选中，接下来的操作对其有效。显然，使用CS线可以完成“一主多从”的SPI网络架设，但是，在“一主一从”的SPI通信时，CS线不是必需的。</p><h2 id="附录：SPI-库函数"><a href="#附录：SPI-库函数" class="headerlink" title="附录：SPI 库函数"></a>附录：SPI 库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190925173325735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> spi </tag>
            
            <tag> 通信 </tag>
            
            <tag> 串行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 中断和串口通信实验</title>
      <link href="/2019/09/24/tech/c-serial/"/>
      <url>/2019/09/24/tech/c-serial/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>掌握USART接口的基本的和主要指标。<br>掌握USART接口的编程原理和使用方法。</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><p>STM32的串口非常强大，它不仅支持最基本的通用串口同步、异步通讯，还具有LIN总线功能(局域互联网)、IRDA 功能(红外通讯)、SmartCard功能。</p><h3 id="一、USART接口简介"><a href="#一、USART接口简介" class="headerlink" title="一、USART接口简介"></a>一、USART接口简介</h3><p>本实验使用的为串口中最基本、最常用的全双工、异步通讯方式，其寄存器说明如表1所示。要配置串口通讯，至少要设置以下几个参数：字长(一次传送的数据长度)、波特率(每秒传输的数据位数)、奇偶校验位、还有停止位。在初始化串口的时候，必然有一个串口初始化结构体，这个结构体的几个成员肯定就是存储这些控制参数的。<br><img src="https://img-blog.csdnimg.cn/20190924232547893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>表1 USART相关寄存器</p><h3 id="二、串口通信分类及原理"><a href="#二、串口通信分类及原理" class="headerlink" title="二、串口通信分类及原理"></a>二、串口通信分类及原理</h3><p>串口通讯分为并行通信和串行通信。并行通信是通过多条数据线来传输数据，所以传输的速度比较快，缺点是不利于长距离传输，串行通信指将数据字节分成位的形式，在一条线上来传输，相比并行通信可以大幅减少成本，但是控制难度较大，串行通信根据传输方向分为单工、半双工和全双工，根据时钟的特性又可以分为同步通信和异步通信。</p><p>一般使用异步通信较多，异步通信的原理是将数据以帧的形式传输，每帧间有固定的传输时间间隔，通信中的波特率、数据位、停止位和奇偶校验的参数设置很关键，必须使两个端口的参数匹配后才可以通信。</p><p>串行通信中的波特率和比特率：波特率指数据信号对载波的调制速率，波特率的单位是波特(baud)，比特率指单位时间内传输的比特数，单位bit/s(bps)，而对于USART来说，波特率和比特率是相等的。总之，波特率越大传输速率越快，通过控制时钟可以改变波特率。</p><p>数据位是传输数据的部分，停止位都在一帧数据的最后一位表示数据帧传输的结束，而奇偶校验位是用来纠错的，用于判读数据传输过程中是否发生了错误。</p><h3 id="三、硬件连接和USART库函数介绍"><a href="#三、硬件连接和USART库函数介绍" class="headerlink" title="三、硬件连接和USART库函数介绍"></a>三、硬件连接和USART库函数介绍</h3><p><img src="https://img-blog.csdnimg.cn/20190924232601975.png" alt="在这里插入图片描述"><br>图1 电路原理图<br>STM32芯片有3个同步异步串口和2个异步串口，本实验中使用异步串口的方式进行通讯，连接方式见图1，芯片上的PC10和PC11引脚分别对应异步串口UART4的发送端TX和接收端RX，小车上的电路板已经将这两个引脚引出。<br><img src="https://img-blog.csdnimg.cn/20190924232610695.png" alt="在这里插入图片描述"><br>表2 STM32F103xx芯片引脚功能定义</p><p>STM32的芯片引脚和串口的对应关系见上表2(芯片手册P34页)，可以看出PC10和PC11引脚的功能分别是异步串口UART4的发送和接收端，为了使用串口通信功能，需要对GPIO和UART4的时钟进行配置。</p><p>与串口模块有关的结构体USART_InitTypeDef定义在stm32f10x_usart.h中，库函数USART_Init定义在stm32f10x_usart.c中。<br>USART_InitTypeDef结构体的配置如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>  USART_BaudRate;                <span class="comment">// 波特率</span></span><br><span class="line"><span class="keyword">uint16_t</span>  USART_WordLength;              <span class="comment">// 字长</span></span><br><span class="line"><span class="keyword">uint16_t</span>  USART_StopBits;                 <span class="comment">// 停止位</span></span><br><span class="line"><span class="keyword">uint16_t</span>  USART_Parity;                   <span class="comment">// 校验位</span></span><br><span class="line"><span class="keyword">uint16_t</span>  USART_Mode;                   <span class="comment">// USART 模式</span></span><br><span class="line"><span class="keyword">uint16_t</span>  USART_HardwareFlowControl;     <span class="comment">// 硬件流控制</span></span><br><span class="line">&#125; USART_InitTypeDef;</span><br><span class="line">``` </span><br><span class="line">库函数USART_Init的作用是初始化串口参数，配置串口的波特率、数据位、停止位和奇偶校验等参数。</span><br><span class="line">### 四、软件流程图</span><br><span class="line"></span><br><span class="line">图<span class="number">2</span> 系统流程图</span><br><span class="line">系统流程图见图<span class="number">2</span>，使用串口模块时同样要先初始化串口所对应的GPIO引脚，这里使用的是异步串口UART4，它所对应的引脚为PC10和PC11，所以先使能引脚的时钟，设置与串口发送端TX对应的PC10为推挽输出，与串口接收端RX对应的PC11引脚设置为浮空输入，然后初始化GPIO，之后再使能串口UART4的时钟，先将其复位，然后设置波特率、停止位、校验位等参数，最关键的是要重定位fputc函数，因为这里要与电脑通信，所以要将该函数的输出重定向到串口上，这样在使用<span class="built_in">printf</span>语句时，输出的结果可以通过串口传到电脑端，然后再开启串口中断。最后开启串口进行通信，这样电脑端就可以显示从单片机发送来的信息。</span><br><span class="line">## 【实验环境】</span><br><span class="line">### 操作系统：</span><br><span class="line">Windows7/<span class="number">8</span>/<span class="number">10</span>，<span class="number">32b</span>it/<span class="number">64b</span>it</span><br><span class="line">### 设备简介：</span><br><span class="line"><span class="number">1</span>、自平衡小车，如下图<span class="number">3</span>所示，小车所搭载的电路板已经将STM32芯片上的PC10和PC11引脚引出，测试串口时将电路板和电脑端的usb转TTL模块的GND端连接，TX和RX相互交叉连接，则串口通讯的物理连接就完成了。 </span><br><span class="line">![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20190924232701863.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190924232707174.png)</span></span><br><span class="line">图<span class="number">3</span> 双轮自平衡车和USB转TTL模块</span><br><span class="line"><span class="number">2</span>、ST-Link下载器(包含USB线与下载线)，如下图<span class="number">4</span>所示。</span><br><span class="line">    ![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20190924232718123.png)</span></span><br><span class="line">图<span class="number">4</span> ST-Link下载器与下载线</span><br><span class="line"><span class="number">3</span>、软件：Keil5、串口调试软件。</span><br><span class="line"></span><br><span class="line">通过串口功能可以实现STM32单片机和电脑端的异步通讯，例如将单片机的信息输出到电脑端，在电脑端显示通讯结果的软件叫串口调试助手，串口调试助手的参数设置如图<span class="number">5</span>所示。</span><br><span class="line">![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20190924232725784.png)</span></span><br><span class="line">图<span class="number">5</span> 串口助手参数配置界面</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、实验场地：无</span><br><span class="line">## 【实验步骤】</span><br><span class="line">### 一、配置工程环境</span><br><span class="line"><span class="number">1.1</span> 打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如下图<span class="number">6</span>所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。</span><br><span class="line">![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20190924232734349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70)</span></span><br><span class="line">图<span class="number">6</span> 工程模板对应的文件夹</span><br><span class="line"><span class="number">1.2</span> 在SYSTEM文件夹下新建两个文件，分别为usart.c和usart.h。分别存放串口USART模块的初始化及配置函数与USART头文件，如图<span class="number">7</span>所示。</span><br><span class="line">![在这里插入图片描述](https:<span class="comment">//img-blog.csdnimg.cn/20190924232740781.png)</span></span><br><span class="line">图<span class="number">7</span> 在SYSTEM文件夹下新建usart.c和usart.h文件</span><br><span class="line">### 二、开启时钟，完成端口初始化</span><br><span class="line"><span class="number">2.1</span> GPIO时钟使能：调用库函数RCC_APB2PeriphClockCmd()初始化UART4和GPIOC的时钟。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*声明一个GPIO初始化结构体*/</span></span><br><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line"><span class="comment">/*使能USART4对应的GPIOA时钟*/</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line"><span class="number">2.2</span>设置GPIO端口模式：这是使用GPIOC的PC10和PC11的默认复用UART4的功能，在使用复用功能的时候，要开启相应的功能时钟UART4。</span><br><span class="line"><span class="comment">/*USART4_TX对应引脚PC10*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"><span class="comment">/*复用推挽输出*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line"><span class="comment">/*初始化PC10引脚*/</span></span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">/*USART4_RX对应引脚PC11*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;</span><br><span class="line"><span class="comment">/*设置浮空输入*/</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;</span><br><span class="line"><span class="comment">/*初始化PC11*/</span></span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></p><p>2.3 UART4外设使能：对UART进行初始化配置。分别配置串口的波特率、传输字长、停止位和校验位等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明一个串口初始化结构体*/</span></span><br><span class="line">USART_InitTypeDef  USART_InitStructure;</span><br><span class="line"><span class="comment">/*声明一个中断初始化结构体*/</span> </span><br><span class="line">NVIC_InitTypeDef  NVIC_InitStructure;</span><br><span class="line"><span class="comment">/*使能USART4的时钟*/</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);</span><br><span class="line"><span class="comment">/*复位串口4 */</span> </span><br><span class="line">USART_DeInit(UART4);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* USART初始化设置，波特率设置为9600*/</span></span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line"><span class="comment">/*字长为8位数据格式*/</span></span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line"><span class="comment">/*一个停止位*/</span></span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line"><span class="comment">/*无奇偶校验位*/</span></span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line"><span class="comment">/*无硬件数据流控制*/</span></span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl=USART_HardwareFlowControl_None;</span><br><span class="line"><span class="comment">/*收发模式*/</span></span><br><span class="line">USART_InitStructure.USART_Mode=USART_Mode_Rx|USART_Mode_Tx;</span><br><span class="line"><span class="comment">/*初始化串口*/</span></span><br><span class="line">USART_Init(UART4, &amp;USART_InitStructure);</span><br><span class="line"><span class="comment">/*开启中断*/</span></span><br><span class="line"><span class="comment">//USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);</span></span><br><span class="line"><span class="comment">/*使能串口*/</span></span><br><span class="line">USART_Cmd(UART4, ENABLE);</span><br></pre></td></tr></table></figure></p><p>2.4中断做初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Usart4 NVIC配置*/</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;</span><br><span class="line"><span class="comment">/*抢占优先级3*/</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/*子优先级3*/</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/*IRQ通道使能*/</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line"><span class="comment">/*根据指定的参数初始化VIC寄存器*/</span> </span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br></pre></td></tr></table></figure></p><p>2.5 输出：根据选择的串口类型重新定义fputc函数，则调用printf函数可以将结果通过串口打印到电脑端的串口助手上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重定义fputc函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE*f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*循环发送, 直到发送完毕*/</span></span><br><span class="line"><span class="keyword">while</span>(USART_GetFlagStatus(UART4, USART_FLAG_TC)!=Bit_SET);</span><br><span class="line">UART4-&gt;DR = (u8)ch;</span><br><span class="line"><span class="comment">/*返回要发送的值*/</span></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、编写main函数实现实验要求"><a href="#三、编写main函数实现实验要求" class="headerlink" title="三、编写main函数实现实验要求"></a>三、编写main函数实现实验要求</h3><p>3.1编写主函数来实现串口通信的功能<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span>      <span class="comment">//包含延时函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"usart.h"</span>     <span class="comment">//包含串口函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>        <span class="comment">//包系统函数的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">/*计数器初始化*/</span></span><br><span class="line">u16 i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*延时函数初始化*/</span></span><br><span class="line">    delay_init(); </span><br><span class="line">    <span class="comment">/*设置NVIC中断分组2:2位抢占优先级，2位响应优先级*/</span></span><br><span class="line">    NVIC_Configuration();</span><br><span class="line">    <span class="comment">/*串口初始化波特率为9600*/</span></span><br><span class="line">    uart_init(<span class="number">9600</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*将嵌入式实验输出到串口中，并在电脑端显示结果*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\r\n 嵌入式实验 \r\n"</span>);</span><br><span class="line"><span class="comment">/*计数器累加*/</span></span><br><span class="line">        i++;</span><br><span class="line"><span class="comment">/*当计数器结果等于20时，改变输出结果*/</span></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*串口输出中断和串口操作实验字符串*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\r\n 中断和串口操作实验 \r\n"</span>);</span><br><span class="line">            <span class="comment">/*计数器清零 */</span></span><br><span class="line">            i = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 延迟10ms*/</span></span><br><span class="line">        delay_ms(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、编译并下载，观察实验现象"><a href="#四、编译并下载，观察实验现象" class="headerlink" title="四、编译并下载，观察实验现象"></a>四、编译并下载，观察实验现象</h3><p>4.1 本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如下图8所示。<br><img src="https://img-blog.csdnimg.cn/20190924232901111.png" alt="在这里插入图片描述"><br>图8 仿真器与下载线连接图<br>4.2 编译程序：点击如图9所示的编译按键。<br><img src="https://img-blog.csdnimg.cn/20190924232907783.png" alt="在这里插入图片描述"><br>图9 Keil5编译环境下的编译按键<br>当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图10所示。<br><img src="https://img-blog.csdnimg.cn/20190924232913597.png" alt="在这里插入图片描述"><br>图10 编译通过后Build Output栏提示信息<br>4.3 下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如下图11所示。<br><img src="https://img-blog.csdnimg.cn/20190924232921386.png" alt="在这里插入图片描述"><br>图11 Keil5编译环境下的下载按键<br>4.4 打开串口调试软件。设置波特率为9600打开串口接受数据，如图12所示<br><img src="https://img-blog.csdnimg.cn/20190924232927646.png" alt="在这里插入图片描述"><br>图12 串口调试助手显示的结果</p><h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><p>题目1：下面哪条语句是设置串口传输字长？ (A)<br>A：USART_InitStructure.USART_WordLength = USART_WordLength_8b;<br>B：USART_InitStructure.USART_BaudRate = 9600;<br>C：USART_InitStructure.USART_Mode=USART_Mode_Rx| USART_Mode_Tx;<br>D：USART_InitStructure.USART_StopBits = USART_StopBits_1;</p><p>题目2：在串口配置时将波特率设置为9600，那么在串口助手中应该将波特率设置为多少？(A)<br>A：9600<br>B：115200</p><h3 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h3><p>题目1：在选定串口引脚后，应该如何对引脚进行功能配置选择？</p><p>在UART4串口选择管脚后，Tx为发送端，输出引脚，而且现在GPIO是使用复用功能，所以要把它配置为复用推挽输出(GPIO_Mode_AF_PP)，而Rx引脚为接收端，输入引脚，所以配置为浮空输入模式GPIO_Mode_IN_FLOATING。</p><h2 id="附录：USART相关库函数"><a href="#附录：USART相关库函数" class="headerlink" title="附录：USART相关库函数"></a>附录：USART相关库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190924232951177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 中断 </tag>
            
            <tag> 串口 </tag>
            
            <tag> serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 GPIO的配置与FLASH编程</title>
      <link href="/2019/09/23/tech/c-gpio-flash/"/>
      <url>/2019/09/23/tech/c-gpio-flash/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>1、通过练习初步掌握STM32基本IO口的使用，迈向STM32的第一步。<br>2、通过对GPIO端口配置和对FLASH的读写编程，设计程序按要求点亮小灯，初步了解和熟悉GPIO端口的配置方法以及FLASH的写入和读取。</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><h3 id="一、GPIO简介"><a href="#一、GPIO简介" class="headerlink" title="一、GPIO简介"></a>一、GPIO简介</h3><p>STM32的IO口可以由软件通过编程配置成8种模式：输入浮空、输入上拉、输入下拉、模拟输入、开漏输出、推挽输出、推挽式复用功能和开漏复用功能。每个IO口可以自由编程，单IO口寄存器必须要按32位字被访问。STM32的每个IO端口都有7个寄存器来控制，如表1所示。<br><img src="https://img-blog.csdnimg.cn/20190923212600113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>表1  GPIO相关寄存器</p><p>在STM32芯片上，I/O引脚可以被软件编程设置成各种不同的功能，如输入或输出，所以被称为GPIO(General-purposeI/O)。而GPIO引脚又被分为GPIOA、GPIOB……GPIOG不同的组，每组端口分为0~15，共16个不同的引脚，对于不同型号的芯片，端口的组和引脚的数量不同，具体请参考相应芯片型号datasheet。</p><h3 id="二、STM32时钟系统"><a href="#二、STM32时钟系统" class="headerlink" title="二、STM32时钟系统"></a>二、STM32时钟系统</h3><p>从时钟频率来说，分为高速时钟和低速时钟，高速时钟是提供给芯片主体的主时钟，而低速时钟只是提供给芯片中的RTC（实时时钟）及独立看门狗使用。</p><p>从芯片角度来说，时钟源分为内部时钟与外部时钟源，内部时钟是在芯片内部RC振荡器产生的，起振较快，所以时钟在芯片刚上电的时候，默认使用内部高速时钟。而外部时钟信号是由外部的晶振输入的，在精度和稳定性上都有很大优势，所以上电之后我们再通过软件配置，转而采用外部时钟信号。</p><p>我们实验中调用了RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)，其中RCC_APB2Periph用于指示要配置的时钟，在应用时可以使用“|”或操作同时配置几个外设的时钟；NewState用于设置状态，可输入“Disable”关闭或者“Enable”使能时钟。</p><h3 id="三、STM32的内部FLASH读写"><a href="#三、STM32的内部FLASH读写" class="headerlink" title="三、STM32的内部FLASH读写"></a>三、STM32的内部FLASH读写</h3><p>在STM32芯片内部有一个FLASH存储器，它主要用于存储代码，我们在电脑上编写好程序后，使用下载器把编译后的代码文件烧录到该内部FLASH中，由于FLASH存储器的内容在掉电后不会丢失，芯片重新上电复位后，内核可从内部FLASH中加载代码并运行。</p><p>我们实验中实现对FLASH的读写是通过调用库函数：<br>STMFLASH_Write(u32 WriteAddr,u16 <em>pBuffer,u16 NumToWrite)<br>STMFLASH_Read(u32 ReadAddr,u16 </em>pBuffer,u16 NumToRead)<br>其中WriteAddr为起始地址（此地址必须为2的倍数），pBuffer为数据指针，NumToWrite和NumToRead为半字数（就是要写入或读取16位数据的个数）。 </p><h3 id="四、硬件连接和GPIO相关库函数介绍"><a href="#四、硬件连接和GPIO相关库函数介绍" class="headerlink" title="四、硬件连接和GPIO相关库函数介绍"></a>四、硬件连接和GPIO相关库函数介绍</h3><p>控制LED灯，通过控制I/O引脚电平的高低来实现。通过图1，LED的硬件连接图可知当I/O引脚为高电平时，LED点亮，为低电平是，LED熄灭。</p><p><img src="https://img-blog.csdnimg.cn/20190923212634703.png" alt="在这里插入图片描述"><br>图1  LED硬件连接示意图</p><p>对应GPIO_InitTypeDef类型的结构体配置说明如下，其中GPIO 输入/输出模式配置如表2所示，GPIO的输出速率配置如表示所示。<br>typedef struct<br>{<br>u16 GPIO_Pin;                    //指定将要配置的GPIO引脚序号<br>GPIOSpeed_TypeDef  GPIO_Speed;  //指定GPIO引脚可以输出的最高频率<br>GPIOMode_TypeDef  GPIO_Mode;  //指定GPIO引脚配置的工作状态<br>}GPIO_InitTypeDef;<br><img src="https://img-blog.csdnimg.cn/20190923212648753.png" alt="在这里插入图片描述"><br>表2  GPIO 输入/输出模式配置<br><img src="https://img-blog.csdnimg.cn/20190923212655603.png" alt="在这里插入图片描述"><br>表3  GPIO 输出速率配置</p><p>对结构体中的各个成员进行赋值，然后把这个变量作为“GPIO初始化函数”GPIO_Init的输入参数，该函数能根据这个变量值中的内容去配置寄存器，从而实现GPIO的初始化。对初始化结构体赋值后，把它输入到GPIO初始化函数GPIO_Init，由它来实现寄存器配置，完成GPIO引脚初始化。<br>库函数GPIO_Init根据GPIO_InitStruct中指定的参数初始化外设GPIOx寄存器，调用形式为：<br>GPIO_Init(GPIO_TypeDef<em> GPIOx,GPIO_InitTypeDef</em> GPIO_InitStruct)<br>其中GPIOx为GPIO_TypeDef类型的指针，指向GPIO端口的地址；GPIO_InitStruct为GPIO_TypeDef结构体指针，指向初始化变量。<br>我们实验中选择的GPIOC的1~3引脚连接到电路上的3个LED小灯。控制引脚的电平变化时，直接使用GPIO_SetBits、GPIO_ResetBits函数控制引脚的输出，就可以控制小灯的亮灭。<br>库函数GPIO_SetBits/GPIO_RessetBits的主要功能为置/复位指定的数据端口位，其调用形式为：<br>GPIO_SetBits(GPIO_TypeDef<em> GPIOx,uint16_t GPIO_Pin)<br>GPIO_ResetBits(GPIO_TypeDef</em> GPIOx,uint16_t GPIO_Pin)<br>其中GPIOx为GPIO_TypeDef类型的指针，指向GPIO端口的地址；GPIO_Pin为指定要写入的端口位，可输入宏GPIO_Pin_0-15，表示GPIOx端口的0-15号引脚。其他库函数说明见附录说明。</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Windows7/8/10，32bit/64bit</p><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>双轮自平衡机器人。小车所搭载的电路板已经将STM32芯片上的PC1、PC2、PC3管脚引出，连接到电路上的3个LED灯上。<br>ST-Link下载器（包括USB线与下载线）。如图1.2所示。<br><img src="https://img-blog.csdnimg.cn/20190923212716159.png" alt="在这里插入图片描述"><br>图1.2  ST-Link下载器与下载线</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Keil 5<br>实验场地：<br>无</p><h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><h3 id="1-配置工程环境"><a href="#1-配置工程环境" class="headerlink" title="1 配置工程环境"></a>1 配置工程环境</h3><p>1.1  打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如图3所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。<br><img src="https://img-blog.csdnimg.cn/20190923212726393.png" alt="在这里插入图片描述"><br>图3 工程模板对应的文件夹<br>1.2  在SYSTEM文件夹下新建两个文件，分别为led.c和led.h。分别存放LED控制函数与LED头文件，如图4所示。以及在HARDWARE文件夹下添加FLASH相关的stmflash.c和stmflash.h文件，如图5所示。<br><img src="https://img-blog.csdnimg.cn/20190923212733558.png" alt="在这里插入图片描述"><br>图4 在SYSTEM文件夹下建立led.c与led.h文件<br><img src="https://img-blog.csdnimg.cn/20190923212741529.png" alt="在这里插入图片描述"><br>图1.5 在HARDWARE文件夹下添加stmflash.c和stmflash.h文件</p><h3 id="2-开启时钟，完成端口初始化"><a href="#2-开启时钟，完成端口初始化" class="headerlink" title="2 开启时钟，完成端口初始化"></a>2 开启时钟，完成端口初始化</h3><p>2.1  打开程序中的led.c文件，首先将led.h文件包含进来。对LED_Init函数进行编写和修改。选择要控制的GPIO引脚并设置引脚模式和速率。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span><span class="comment">//包含头文件</span></span></span><br><span class="line"><span class="comment">/*初始化PC1、PC2、PC3为输出口。并使能时钟*/</span>        </span><br><span class="line"><span class="comment">/*对LED的IO口进行初始化*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个GPIO_InitTypeDef类型的结构体*/</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    <span class="comment">/*开启GPIOC的外设时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); </span><br><span class="line">    <span class="comment">/*选择要控制的GPIOC引脚*/</span>                                              </span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3; </span><br><span class="line">    <span class="comment">/*设置引脚模式为通用推挽输出*/</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   </span><br><span class="line">    <span class="comment">/*设置引脚速率为50MHz */</span>   </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; </span><br><span class="line">    <span class="comment">/*调用库函数，初始化GPIOC*/</span></span><br><span class="line">    GPIO_Init(GPIOC,&amp;GPIO_InitStructure);         </span><br><span class="line">    <span class="comment">/*关闭所有led灯  */</span></span><br><span class="line">    GPIO_ResetBits(GPIOC,GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3 );    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.2  打开led.h文件，添加LED_Init函数声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LED_H  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">//初始化                     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>2.3  打开stmflash.c文件，查看在编写程序时需调用的STMFLASH_Write，STMFLASH_Read函数的变量类型和用法。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//WriteAddr:起始地址(此地址必须为2的倍数)，pBuffer:数据指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NumToWrite:半字(16位)数(就是要写入的16位数据的个数.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Read</span><span class="params">(u32 ReadAddr,u16 *pBuffer,u16 NumToRead)</span></span></span><br></pre></td></tr></table></figure></p><p>编写main函数实现实验要求<br>函数流程图如图6所示，首先对定义函数所使用的的变量，并对各模块进行初始，循环写入和读取FLASH，并根据数据对LED小灯的闪烁次数进行控制。<br><img src="https://img-blog.csdnimg.cn/20190923212755251.png" alt="在这里插入图片描述"><br>图6 程序流程图</p><h3 id="3-编写程序"><a href="#3-编写程序" class="headerlink" title="3 编写程序"></a>3 编写程序</h3><p>3.1 将工程编译需要用到的头文件包含进来<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"delay.h"</span>     <span class="comment">//包含延时函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stmflash.h"</span>  <span class="comment">//包含FLASH头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span>      <span class="comment">//包含LED头文件</span></span></span><br></pre></td></tr></table></figure></p><p>3.2 编写要写入FLASH中的字符串数组<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASH_SAVE_ADDR  0X08070000  <span class="comment">//设置FLASH保存地址（必须为偶数）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ON   0   <span class="comment">//定义全局变量ON=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFF  1   <span class="comment">//定义全局变量OFF=1</span></span></span><br></pre></td></tr></table></figure></p><p>3.3 在主函数中调用延时函数与LED初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delay_init();            <span class="comment">//延时函数初始化    </span></span><br><span class="line">LED_Init();           <span class="comment">//调用LED初始化函数</span></span><br></pre></td></tr></table></figure></p><p>3.4 将已编辑好的初始化函数写入main函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">u16 j=<span class="number">0</span>;</span><br><span class="line">u16 datatemp; </span><br><span class="line">u16 ledtime=<span class="number">5</span>;</span><br><span class="line">delay_init();            <span class="comment">//延时函数初始化    </span></span><br><span class="line">LED_Init();  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.5 因为要实现在FLASH中写入一个数字，再将这个数字读出作为小灯的闪烁次数，因此接下来需要编写一个循环来实现小灯的闪烁，这里我们使用while语句来进行循环。</p><p>3.6 在while(1)中编写实现读写FLASH的程序。首先调用STMFLASH_Write函数，写入FLASH存储起始地址、数据指针地址和写入数据的个数。之后调用STMFLASH_Read读取存储的数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STMFLASH_Write(FLASH_SAVE_ADDR,&amp;ledtime,<span class="number">1</span>); </span><br><span class="line">STMFLASH_Read(FLASH_SAVE_ADDR,&amp;datatemp,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>3.7  在while(1)中编写小灯闪烁程序。定义变量j，当j小于FLASH中写入的数字时，满足if语句的判断条件，将GPIO_Pin_2管脚位置低，小灯点亮，变量j加1，延时100ms后关闭，再重新if判断，直到完成小灯的j次闪烁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&lt;datatemp)</span><br><span class="line">&#123;           </span><br><span class="line">    GPIO_ResetBits(GPIOC,GPIO_Pin_2);</span><br><span class="line">    delay_ms(<span class="number">100</span>);</span><br><span class="line">   GPIO_SetBits(GPIOC,GPIO_Pin_2);  </span><br><span class="line">delay_ms(<span class="number">100</span>);  </span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-编译并下载，观察实验现象"><a href="#4-编译并下载，观察实验现象" class="headerlink" title="4 编译并下载，观察实验现象"></a>4 编译并下载，观察实验现象</h3><p>4.1本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图7所示。<br><img src="https://img-blog.csdnimg.cn/20190923212831390.png" alt="在这里插入图片描述"><br>图7 仿真器与下载线连接图</p><p>4.2编译程序，当编译完成后，如果没有问题，Build Output栏会出现无错误，无警号的提示，如图8所示。<br><img src="https://img-blog.csdnimg.cn/20190923212840883.png" alt="在这里插入图片描述"><br>图8 编译通过后Build Output栏提示信息</p><p>4.3下载程序到小车，并观察小灯闪烁。如图9所示。<br><img src="https://img-blog.csdnimg.cn/20190923212851440.png" alt="在这里插入图片描述"><br>图9  Keil编译环境下的下载按键</p><h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><p>题目1：下面哪条语句是设置引脚输出模式（D）<br>A：GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;<br>B：GPIO_Init(GPIOC, &amp;GPIO_InitStructure);<br>C：GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>D：GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</p><p>题目2：GPIO所用的时钟PCLK2的默认值是多少？（A）<br>A：72MHz<br>B：36MHz</p><h3 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h3><p>题目1：GPIO分别有哪些工作模式？简单介绍各个模式的工作场合。</p><p>GPIO引脚配置为上拉输入模式，在默认状态下(GPIO引脚无输入)，读取得的GPIO引脚数据为1，高电平。而下拉模式则相反，在默认状态下其引脚数据为0，低电平。浮空输入模式一般用于标准的通讯协议如I2C、USART的接收端。模拟输入模式可以用于ADC模块。</p><p>普通推挽输出模式一般应用在输出电平为0和3.3伏的场合。而普通开漏输出一般应用在电平不匹配的场合。对于相应的复用模式，则是根据GPIO的复用功能来选择的，如GPIO的引脚用作串口的输出，则使用复用推挽输出模式。如果用在IC、SMBUS这些需要线与功能的复用场合，就使用复用开漏模式。</p><h2 id="附录：GPIO相关库函数"><a href="#附录：GPIO相关库函数" class="headerlink" title="附录：GPIO相关库函数"></a>附录：GPIO相关库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190923212902692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> GPIO </tag>
            
            <tag> FLASH </tag>
            
            <tag> 引脚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 定时器实验</title>
      <link href="/2019/09/19/tech/c-timer/"/>
      <url>/2019/09/19/tech/c-timer/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>1、通过子函数实现任务注册与调用，体会指针函数和结构体的实用性。<br>2、通过对Systick、TIM2、TIM3、TIM4定时器的配置，进入定时器中断执行任务。</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><h3 id="一、STM32的内部Sys-Tick滴答定时器"><a href="#一、STM32的内部Sys-Tick滴答定时器" class="headerlink" title="一、STM32的内部Sys Tick滴答定时器"></a>一、STM32的内部Sys Tick滴答定时器</h3><p>在STM32芯片内部有一个简单的定时器——Sys tick timer。该定时器的时钟源可以是内部时钟，或外部时钟。所以在STM32中Sys Tick以HCLK（APB时钟）或HCLK/8作为运行时钟。</p><p>Sys Tick是一个24位的定时器，即一次最多可以计数2^24个时钟脉冲，这个脉冲计数值被保存到当前计数值寄存器SysTick-&gt;VAL中,只能向下计数，每接受到一个时钟脉冲<br>Sys Tick-&gt;VAL的值就向下减1,直至到0，当SysTick-&gt;VAL的值被减至到0时，由硬件自动把重载寄存器Sys Tick-&gt;LOAD中保存的数据加载到SysTick-&gt;VAL中，从新向下计数；当Sys Tick-&gt;VAL的值被减至到0时，触发异常，就可以在中断服务函数中处理定时事件。</p><p>当然，要使用Sys Tick进行以上工作必须对SysTick进行配置，它的控制配置很简单，只有三个控制位和1个标志位，都位于寄存器SysTick-&gt;CTRL寄存器中<br><img src="https://img-blog.csdnimg.cn/20190919193939387.png" alt="在这里插入图片描述"></p><ol><li>Bit0:ENABLE<br>为Sys Tick timer 的使能位，此位为1的时候使能Sys Tick timer ，此位为0的时候关闭Sys Tick timer.</li><li>Bit1:TICKINT<br>为异常触发使能位，此位为1的时候并且Sys Tick-&gt;VAL计数至0时会触发Sys Tick异常，此位为0的时候不触发异常。</li><li>Bit2:CLKSOURCE<br>为Sys Tick的时钟选择位，此位为1的时候Sys Tick的时候为AHB 时钟，此位为0的时候Sys Tick时钟为AHB/8（AHB的八分频）</li><li>Bit16:COUNTFLAG<br>为计数为0标志位，若Sys Tick-&gt;VAL计数至0，此标志位会被置1.<br>定时时间计算公式：T=ticks*(1/f)，T为要定时的总时间。</li></ol><p>Ticks是存放到到重载SysTick-&gt;LOAD寄存器中，Sys Tick timer 定时器启动每次计数到Tick个脉冲产生异常触发（中断）。1/f即为Sys Tick timer 使用的时钟源，f为该时钟源的时钟频率，当时钟源确定后为常数</p><p>SysTick-&gt;CTRL &amp;= ~(1 &lt;&lt; 2); </p><p>使Sys tick CTRL寄存器 Bit2 位置0 ，其他位保持不变，Bit2位为0 ，Sys Tick时钟为AHB/8（AHB的八分频）</p><p>f = AHB/8=72MHz/8 =9MHz </p><p>1/f= 1/9000000 一个时钟周期为1/f s，所以我们得到一个时钟周期为1/9us</p><h3 id="二、STM32-通用定时器简介"><a href="#二、STM32-通用定时器简介" class="headerlink" title="二、STM32 通用定时器简介"></a>二、STM32 通用定时器简介</h3><p>STM32F1 的通用定时器是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）构成。 STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和 PWM)等。 使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。 STM32 的每个通用定时器都是完全独立的，没有互相共享的任何资源。</p><p>STM3F1 的通用 TIMx (TIM2、 TIM3、 TIM4 和 TIM5)定时器功能包括：</p><ol><li>16 位向上、向下、向上/向下自动装载计数器（TIMx_CNT）。</li><li>16 位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数为 1～<br>65535 之间的任意数值。</li><li>4 个独立通道（TIMx_CH1~4），这些通道可以用来作为：<br>A．输入捕获<br>B．输出比较<br>C． PWM 生成(边缘或中间对齐模式)<br>D．单脉冲模式输出</li><li>可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1 个定时器控制另外<br>一个定时器）的同步电路。</li><li>如下事件发生时产生中断/DMA：<br>A．更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)<br>B．触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)<br>C．输入捕获<br>D．输出比较<br>E．支持针对定位的增量(正交)编码器和霍尔传感器电路<br>F．触发输入作为外部时钟或者按周期的电流管理<br>由于 STM32 通用定时器比较复杂，这里我们不再多介绍，请大家直接参考《STM32 参考<br>手册》第 253 页，通用定时器一章。 为了深入了解 STM32 的通用寄存器， 下面我们先介绍一<br>下与我们这章的实验密切相关的几个通用定时器的寄存器。<br>首先是控制寄存器 1（TIMx_CR1），该寄存器的各位描述如图 13.1.1 所示：</li></ol><p><img src="https://img-blog.csdnimg.cn/20190919194247605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>结构体介绍<br>结构体TIM_OCInitTypeDef，包含了TIMx时间基数单位的配置信息<br><img src="https://img-blog.csdnimg.cn/20190919194306729.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091919431634.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194328223.png" alt="在这里插入图片描述"><br><strong>TIM_Pulse</strong><br>TIM_Pulse 设置了待装入捕获比较寄存器的脉冲值。它的取值必须在 0x0000 和 0xFFFF 之间。<br><img src="https://img-blog.csdnimg.cn/20190919194340371.png" alt="在这里插入图片描述"><br>结构体NVIC_InitTypeDef<br> <img src="https://img-blog.csdnimg.cn/20190919194407277.png" alt="在这里插入图片描述"><br>因版本原因可能在最新的库中通道名还减去尾部的Channel，写代码才能通过，本实验要去除尾部Channel<br><img src="https://img-blog.csdnimg.cn/2019091919442239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NVIC_IRQChannelPreemptionPriority<br>该参数设置了成员 NVIC_IRQChannel 中的先占优先级。<br>NVIC_IRQChannelSubPriority<br>该参数设置了成员 NVIC_IRQChannel 中的从优先级。<br> <img src="https://img-blog.csdnimg.cn/20190919194438417.png" alt="在这里插入图片描述"><br>NVIC_IRQChannelCmd<br>该参数指定了在成员 NVIC_IRQChannel 中定义的 IRQ 通道被使能还是失能。这个参数取值为 ENABLE 或者 DISABLE。</p><p>结构体TIM_TimeBaseInitTypeDef<br><img src="https://img-blog.csdnimg.cn/20190919194509332.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194519698.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091919452550.png" alt="在这里插入图片描述"><br>RCC_ClocksTypeDef结构体<br><img src="https://img-blog.csdnimg.cn/20190919194535766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>程序中使用到的函数<br>函数NVIC_PriorityGroupConfig 选择优先分组<br><img src="https://img-blog.csdnimg.cn/20190919194617533.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194628556.png" alt="在这里插入图片描述"><br>函数NVIC_Init 初始化中断优先级配置参数<br><img src="https://img-blog.csdnimg.cn/20190919194647627.png" alt="在这里插入图片描述"><br>函数RCC_GetClocksFreq 获取系统时钟频率<br><img src="https://img-blog.csdnimg.cn/20190919194654361.png" alt="在这里插入图片描述"><br>函数TIM_TimeBaseInit<br><img src="https://img-blog.csdnimg.cn/20190919194718951.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194725621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194731746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194740461.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019091919475098.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194800150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/201909191948193.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194827811.png" alt="在这里插入图片描述"></p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><p>开发环境：Windows7/8/10，32bit/64bit<br>开发软件：Keil<br>开发硬件：双轮自平衡车、ST-link</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="一、定义参数变量，声明函数"><a href="#一、定义参数变量，声明函数" class="headerlink" title="一、定义参数变量，声明函数"></a>一、定义参数变量，声明函数</h3><p><img src="https://img-blog.csdnimg.cn/20190919194852431.png" alt="在这里插入图片描述"></p><h3 id="二、定时器TIM2、TIM3、TIM4、配置"><a href="#二、定时器TIM2、TIM3、TIM4、配置" class="headerlink" title="二、定时器TIM2、TIM3、TIM4、配置"></a>二、定时器TIM2、TIM3、TIM4、配置</h3><p>定义结构体变量，判断定时器是否是TIM2、TIM3、TIM4不是直接返回，是否是首次初始化，<br>结构体参数配置</p><p><img src="https://img-blog.csdnimg.cn/20190919194900537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194909729.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194917947.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190919194926622.png" alt="在这里插入图片描述"></p><h3 id="三、任务函数注册、任务信息返回"><a href="#三、任务函数注册、任务信息返回" class="headerlink" title="三、任务函数注册、任务信息返回"></a>三、任务函数注册、任务信息返回</h3><p><img src="https://img-blog.csdnimg.cn/20190919194938221.png" alt="在这里插入图片描述"></p><h3 id="四、中断函数调用任务"><a href="#四、中断函数调用任务" class="headerlink" title="四、中断函数调用任务"></a>四、中断函数调用任务</h3><p><img src="https://img-blog.csdnimg.cn/20190919194946752.png" alt="在这里插入图片描述"></p><h3 id="五、打开main-c"><a href="#五、打开main-c" class="headerlink" title="五、打开main.c"></a>五、打开main.c</h3><p><img src="https://img-blog.csdnimg.cn/20190919195009706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="六、任务函数"><a href="#六、任务函数" class="headerlink" title="六、任务函数"></a>六、任务函数</h3><p><img src="https://img-blog.csdnimg.cn/20190919195017211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="【实验思考】"><a href="#【实验思考】" class="headerlink" title="【实验思考】"></a>【实验思考】</h2><h3 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h3><p>题目1 下面那个表示TIM2通道1预装值失能（B）<br>A:TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Disable);<br>B: TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Disable);<br>C: TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Disable);<br>D: TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Disable);   </p><p>题目2 定时器有几种计数模式（A）<br>A: 3    B:4    C: 5     D:6</p><h3 id="二、简答题"><a href="#二、简答题" class="headerlink" title="二、简答题"></a>二、简答题</h3><p>题目1 定义定时器的结构体有哪些成员？成员表示的功能？</p><p>答：TIM_TimeBaseInitTypeDef 中包含5个成员变量：<br>TIM_Period ：该参数是用来设置自动重装寄存器的值，它的取值范围必须在0x0000和0xFFFF之间。<br>TIM_Prescaler ：该参数是用来设置PSC预分频器的分频系数，它的取值范围必须在0x0000和0xFFFF之间。<br>TIM_ClockDivision　：该参数是用来设置时钟分割<br>TIM_CounterMode　：该参数是用来设置计数模式的。<br>TIM_RepetitionCounter　：该参数使用设置重载几次数据后定时器才进入中断。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 定时器 </tag>
            
            <tag> timer </tag>
            
            <tag> systick </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 陀螺仪传感器实验</title>
      <link href="/2019/09/18/tech/c-gyro/"/>
      <url>/2019/09/18/tech/c-gyro/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>熟悉陀螺仪工作原理，了解不同种类陀螺仪之间的差异；<br>熟悉MPU6050的输出形式，熟悉MPU6050的通信方法；<br>掌握STM32F10xx系列微控制器上陀螺仪的接口配置与数据采集过程；</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><h3 id="一、陀螺仪简介"><a href="#一、陀螺仪简介" class="headerlink" title="一、陀螺仪简介"></a>一、陀螺仪简介</h3><p>陀螺仪（gyroscope）是角运动检测装置，传统陀螺仪是通过检测高速回转体的动量矩敏感壳体相对惯性空间绕正交于自转轴的一个或两个轴的角运动的装置。通俗的来讲，一个旋转物体的旋转轴所指的方向在不受外力影响时，是不会改变的。人们根据这个道理，用它来保持方向。然后用多种方法读取轴所指示的方向，并自动将数据信号传给控制系统。利用其他原理制成的角运动检测装置起同样功能的也称陀螺仪。</p><p>传统陀螺仪为机械式陀螺仪，然而机械式陀螺仪制造工艺要求高，而且精度低，体积大。于是，人们开始寻找更好的办法，利用物理学上的进步，发展出激光陀螺仪，光纤陀螺仪，以及微机电陀螺仪（MEMS）。这些东西虽然还叫陀螺仪，但是它们的原理和传统的机械陀螺仪已经完全是两码事了。目前，传统上的机械陀螺仪正在被淘汰，有高精度需求的地方用的是激光陀螺仪，而普及方面则是微机电陀螺仪。</p><h3 id="二、MPU6050简介"><a href="#二、MPU6050简介" class="headerlink" title="二、MPU6050简介"></a>二、MPU6050简介</h3><p>本实验采用的是MPU6050运动传感器，它是一款整合性6轴运动传感器，集成了3轴MEMS陀螺仪，3轴MEMS加速度计，以及一个可拓展的数字运动处理器DMP（Digital Motion Processor）。MPU6050传输可透过最高至400kHz的IIC通信，也可以通过其I2C接口连接其他非惯性的数字传感器。IIC通信协议要求每一个挂载在总线上的设备都要有一个独有的7位设备地址，用以区分信号传递的对象。MPU6050的设备地址前六位在出场时已经由厂商决定为（110100B），而MPU6050提供一个AD0引脚用以确定第7位电平，若AD0接地，则其设备地址为0x68H（1101000B），再加上第8位读写方向位，构成了IIC传输的器件地址0xD0(11010000B)。</p><p>硬件连接图和库函数介绍<br><img src="https://img-blog.csdnimg.cn/20190918194117190.png" alt="在这里插入图片描述"><br>图1.1 硬件连接示意图<br>在本实验中所使用的库函数包括IICwriteBits函数，该函数的参数含义如下：</p><ol><li>dev，设备地址，这里为MPU6050设备地址（在mpu6050.h中给出宏定义）；</li><li>reg，目标寄存器地址，这里指PWR电池管理寄存器地址0x6B；</li><li>bitStart，寄存器上功能标志位起始地址，由于配置时钟源的标志位为寄存器上的[2:0]位，因此这里的值为2；</li><li>length，功能标志位长度，由于配置时钟源的标志位为寄存器上的[2:0]位，长度为3，因此这里的值为3；</li><li>data，将要在寄存器标志位储存的值，这里由函数入口的时钟源参数给出。</li></ol><p>I2C_ReadOneByte函数，该函数的参数含义如下：</p><ol><li>I2C_Addr ，目标设备地址，这里为MPU6050设备地址（在mpu6050.h中给出宏定义）；</li><li>addr，寄存器地址<br>四、软件流程图<br> 由于MPU6050通过IIC通信，因此可以通过IIC访问各个数据寄存器对应的地址，就能得到相应的陀螺仪加速度计信息。各个功能寄存器的寄存器地址已经在mpu6050.h中给出，程序中已经预给出的库函数还有：oled.c显示屏库函数、delay.c延时库函数、IOI2C模拟IIC库函数等，程序流程的简要说明图如图1.2所示：</li></ol><p>图1.2 程序流程示意图</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="硬件设备："><a href="#硬件设备：" class="headerlink" title="硬件设备："></a>硬件设备：</h3><p>双轮自平衡机器人。如图1.3所示，在平衡车上电路板上已经集成了MPU6050模块。<br>ST-Link下载器（包含USB线与下载线）。如图1.4所示。<br>操作系统：<br>Windows7/8/10，32bit/64bit</p><p><img src="https://img-blog.csdnimg.cn/20190918194208888.png" alt="在这里插入图片描述"><br>图1.3 双轮自平衡机器人<br><img src="https://img-blog.csdnimg.cn/20190918194223959.png" alt="在这里插入图片描述"><br>图1.4  ST-Link下载器与下载线</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Keil 5</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="第一步-配置工程环境"><a href="#第一步-配置工程环境" class="headerlink" title="第一步 配置工程环境"></a>第一步 配置工程环境</h3><p>打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如图1.5所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。<br><img src="https://img-blog.csdnimg.cn/20190918194232285.png" alt="在这里插入图片描述"><br>图1.5 工程模板对应的文件夹<br>在HARDWARE文件夹下新建一个文件，命名为mpu6050.c，并加载已经编写好的在工程目录下HARDWARE文件夹里的MPU6050文件夹内的MPU6050.h文件，该文件存放MPU6050寄存器地址已经相应数据位的宏定义。mpu6050.c则存放MPU6050的配置文件，如图1.6所示。<br>         <img src="https://img-blog.csdnimg.cn/20190918194240541.png" alt="在这里插入图片描述"><br>图1.6 在HARDWARE文件夹下建立mpu6050.c与mpu6050.h文件</p><h3 id="第二步-陀螺仪寄存器读取函数和初始化函数"><a href="#第二步-陀螺仪寄存器读取函数和初始化函数" class="headerlink" title="第二步 陀螺仪寄存器读取函数和初始化函数"></a>第二步 陀螺仪寄存器读取函数和初始化函数</h3><p>打开程序中的mpu6050.c文件，首先将mpu6050.h和IOI2C.h文件包含进来。其次编写MPU6050的时钟源配置函数MPU6050_setClockSource。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MPU6050.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IOI2C.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050的时钟源</span></span><br><span class="line"><span class="comment">入口参数：时钟源参数</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setClockSource</span><span class="params">(<span class="keyword">uint8_t</span> source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBits(devAddr, MPU6050_RA_PWR_MGMT_1,    MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同理，编写陀螺仪加速度计量程设置函数、睡眠唤醒函数、主从机设置函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050的陀螺仪最大量程</span></span><br><span class="line"><span class="comment">入口参数：陀螺仪最大量程参数</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setFullScaleGyroRange</span><span class="params">(<span class="keyword">uint8_t</span> range)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBits(devAddr, MPU6050_RA_GYRO_CONFIG,   MPU6050_GCONFIG_FS_SEL_BIT,MPU6050_GCONFIG_FS_SEL_LENGTH, range);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050的加速度计最大量程</span></span><br><span class="line"><span class="comment">入口参数：加速度计最大量程参数</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setFullScaleAccelRange</span><span class="params">(<span class="keyword">uint8_t</span> range)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBits(devAddr, MPU6050_RA_ACCEL_CONFIG,  MPU6050_ACONFIG_AFS_SEL_BIT,MPU6050_ACONFIG_AFS_SEL_LENGTH, range);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050是否进入睡眠模式</span></span><br><span class="line"><span class="comment">入口参数：0否 1是</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setSleepEnabled</span><span class="params">(<span class="keyword">uint8_t</span> enabled)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBit(devAddr, MPU6050_RA_PWR_MGMT_1,                                         MPU6050_PWR1_SLEEP_BIT, enabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050是否为主机模式</span></span><br><span class="line"><span class="comment">入口参数：0否 1是</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setI2CMasterModeEnabled</span><span class="params">(<span class="keyword">uint8_t</span> enabled)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBit(devAddr, MPU6050_RA_USER_CTRL,                                  MPU6050_USERCTRL_I2C_MST_EN_BIT, enabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：设置MPU6050是否允许IIC通信</span></span><br><span class="line"><span class="comment">入口参数：0否 1是</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_setI2CBypassEnabled</span><span class="params">(<span class="keyword">uint8_t</span> enabled)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IICwriteBit(devAddr, MPU6050_RA_INT_PIN_CFG,                                        MPU6050_INTCFG_I2C_BYPASS_EN_BIT, enabled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写MPU6050初始化函数，在初始化函数中调用以上定义的函数完成初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">函数功能：初始化MPU6050以进入可用状态</span></span><br><span class="line"><span class="comment">入口参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MPU6050_initialize</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置时钟</span></span><br><span class="line">    MPU6050_setClockSource(MPU6050_CLOCK_PLL_YGYRO);</span><br><span class="line">    <span class="comment">//陀螺仪最大量程+-1000度每秒</span></span><br><span class="line">    MPU6050_setFullScaleGyroRange(MPU6050_GYRO_FS_2000);</span><br><span class="line">    <span class="comment">//加速度计最大量程+-2G</span></span><br><span class="line">    MPU6050_setFullScaleAccelRange(MPU6050_ACCEL_FS_2); </span><br><span class="line">    <span class="comment">//进入工作状态</span></span><br><span class="line">    MPU6050_setSleepEnabled(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//不让MPU6050控制AUX IIC</span></span><br><span class="line">    MPU6050_setI2CMasterModeEnabled(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//主控制器的IIC与MPU6050的AUX IIC 直通</span></span><br><span class="line">    MPU6050_setI2CBypassEnabled(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打开encoder.h，设置MPU6050设备地址宏定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MPU6050_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MPU6050_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devAddr  0xD0</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></p><h3 id="第三步-编写main-c文件"><a href="#第三步-编写main-c文件" class="headerlink" title="第三步 编写main.c文件"></a>第三步 编写main.c文件</h3><p>将工程编译需要用到的头文件包含进来，并预定义显示函数和全局变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpu6050.h"</span>        <span class="comment">//包含mpu6050函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>          <span class="comment">//包含系统头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span>    <span class="comment">//包含系统寄存器定义声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> Gyro_X,Gyro_Z;  <span class="comment">// X、Z轴的陀螺仪变量</span></span><br></pre></td></tr></table></figure></p><p>在主函数中调用延时函数、显示函数、IIC函数和MPU6050的初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">delay_init();       <span class="comment">//延时函数初始化</span></span><br><span class="line">delay_ms(<span class="number">500</span>);</span><br><span class="line">    OLED_Init();     <span class="comment">//OLED初始化</span></span><br><span class="line">        IIC_Init ();            <span class="comment">//IIC初始化</span></span><br><span class="line">    MPU6050_initialize ();            <span class="comment">//MPU6050初始化</span></span><br><span class="line"><span class="comment">//在主循环中调用超声波读取函数和显示函数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">Gyro_X=(I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_XOUT_H)&lt;&lt;<span class="number">8</span>)+I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_XOUT_L);   <span class="comment">//读取X轴陀螺仪数据</span></span><br><span class="line">Gyro_Z=(I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_ZOUT_H)&lt;&lt;<span class="number">8</span>)+I2C_ReadOneByte(devAddr,MPU6050_RA_GYRO_ZOUT_L);   <span class="comment">//读取Z轴陀螺仪数据</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(Gyro_X&gt;<span class="number">32768</span>)  Gyro_X-=<span class="number">65536</span>;      <span class="comment">//数据类型转换</span></span><br><span class="line">        <span class="keyword">if</span>(Gyro_Z&gt;<span class="number">32768</span>)  Gyro_Z-=<span class="number">65536</span>;       <span class="comment">//数据类型转换</span></span><br><span class="line">        oled_show();          <span class="comment">//显示屏打开</span></span><br><span class="line">        delay_ms(<span class="number">50</span>); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>编写OLED显示函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//显示右侧编码器返回值</span></span><br><span class="line">    OLED_ShowString(<span class="number">0</span>,<span class="number">10</span>,<span class="string">" Gyro_X "</span>);</span><br><span class="line">    <span class="keyword">if</span>(Gyro_X &gt;=<span class="number">0</span>)OLED_ShowString(<span class="number">20</span>,<span class="number">20</span>,<span class="string">" "</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">20</span>, Gyro_X,<span class="number">4</span>,<span class="number">12</span>);    </span><br><span class="line">    <span class="keyword">else</span> OLED_ShowString(<span class="number">20</span>,<span class="number">20</span>,<span class="string">"-"</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">20</span>,<span class="number">4</span>- Gyro_X,<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//显示左侧编码器返回值</span></span><br><span class="line">    OLED_ShowString(<span class="number">0</span>,<span class="number">40</span>,<span class="string">" Gyro_Z "</span>);</span><br><span class="line">    <span class="keyword">if</span>(Gyro_Z &gt;=<span class="number">0</span>)OLED_ShowString(<span class="number">10</span>,<span class="number">50</span>,<span class="string">" "</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">50</span>, Gyro_Z,<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">else</span> OLED_ShowString(<span class="number">10</span>,<span class="number">50</span>,<span class="string">"-"</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">50</span>,- Gyro_Z,<span class="number">4</span>,<span class="number">12</span>); </span><br><span class="line">    <span class="comment">//=============刷新======================//</span></span><br><span class="line">    OLED_Refresh_Gram();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四步-编译并下载，观察实验现象"><a href="#第四步-编译并下载，观察实验现象" class="headerlink" title="第四步 编译并下载，观察实验现象"></a>第四步 编译并下载，观察实验现象</h3><p>本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图1.7所示。<br><img src="https://img-blog.csdnimg.cn/20190918194558889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图1.7 仿真器与下载线连接图<br>编译程序：点击如图1.8所示的编译按键。<br><img src="https://img-blog.csdnimg.cn/20190918194628897.png" alt="在这里插入图片描述"><br>图1.8Keil编译环境下的编译按键<br>当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图1.9所示。<br><img src="https://img-blog.csdnimg.cn/20190918194638727.png" alt="在这里插入图片描述"><br>图1.9 编译通过后Build Output栏提示信息<br>下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如图1.10所示。<br><img src="https://img-blog.csdnimg.cn/20190918194644784.png" alt="在这里插入图片描述"><br>图1.10 Keil编译环境下的下载按键<br>观察实验现象，OLED显示屏上显示出当前陀螺仪的读数，用手轻轻晃动车身，观察数值的变化。<br><img src="https://img-blog.csdnimg.cn/20190918194653977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图1.11 平衡车上的陀螺仪测量数据</p><h2 id="【思考题】"><a href="#【思考题】" class="headerlink" title="【思考题】"></a>【思考题】</h2><h3 id="1、选择题"><a href="#1、选择题" class="headerlink" title="1、选择题"></a>1、选择题</h3><p>题目1：若AD0引脚接高电平，MPU6050的7位设备地址是（B）<br>A：0x68<br>B：0x69<br>C：0xD0<br>D：0xD1<br>题目2：同一条IIC总线上最多挂在几个MPU6050设备（B）<br>A：1<br>B：2<br>C：127<br>D：128</p><h3 id="2、简答题"><a href="#2、简答题" class="headerlink" title="2、简答题"></a>2、简答题</h3><p>题目1：简要阐述机械陀螺仪的工作原理。</p><p>一个旋转物体的旋转轴所指的方向在不受外力影响时，是不会改变的。人们根据这个道理，用它来保持方向，制造出来的东西就叫做陀螺仪。陀螺仪在工作时要给它一个力，使它快速旋转起来，一般能达到每分钟几十万转，可以工作很长时间。然后用多种方法读取轴所指示的方向，并自动将数据信号传给控制系统。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 传感器 </tag>
            
            <tag> 陀螺仪 </tag>
            
            <tag> 6轴陀螺仪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 超声波传感器实验</title>
      <link href="/2019/09/17/tech/c-ultra/"/>
      <url>/2019/09/17/tech/c-ultra/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><p>1、熟悉超声波传感器的工作原理；<br>2、了解HC-SR04超声波传感器的测量范围、测量精度等特性；<br>3、掌握STM32F10xx系列微控制器上超声波传感器的接口配置与数据采集过程。</p><h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2><h3 id="一、HC-SR04超声波传感器简介"><a href="#一、HC-SR04超声波传感器简介" class="headerlink" title="一、HC-SR04超声波传感器简介"></a>一、HC-SR04超声波传感器简介</h3><p>超声波传感器是利用检测采集超声波的形式来获得环境信息的传感器。通常用于测距、定位等具体应用场景。超声波是一种弹性介质中的机械波，通常其振动频率为几十KHz到几十MHz（人体能听到的声音频率在20Hz到20KHz）。相比与人耳能听到的声波，超声波具有频率高、波长小、绕射现象小等特点，其传播的方向性强，因此可以用来检测一个固定方向上的距离信息。</p><p>本实验采用HC-SR04超声波测距模块，该模块在空气中的测量范围为20mm到4000mm，其测量精度达到3mm。HC-SR04超声波测距模块的硬件实物图如图1.1所示，该模块主要包涵超声波发射器、超声波接收器和外围控制电路。在电路板上一共引出4根引脚，对映于图1.1模块摆设的方向，其接口从左到右分别为VCC（+5V）、Trig（触发信号输入）、Echo（回响信号输出）、GND。</p><h3 id="二、工作原理"><a href="#二、工作原理" class="headerlink" title="二、工作原理"></a>二、工作原理</h3><p>在外部电路正常供电的情况下，外部采集电路通过给该模块的Trig引脚上输入一个长为10us至20us的高电平信号，以开启一次采集。在模块接收到方波的输入后，超声波发射器会向正前方自动发射8个40KHz的声波信号，于此同时，回响信号的输出端会从低电平跳转为高电平。发射出去的超声波经过前方障碍物的反射，产生相同频率的反射回波，超声波接收器接受到反射回波后，回响信号输出端会从高电平跳转为低电平。对于外部采集电路，需要利用定时器采集回响信号为高电平的总时长T秒，然后根据声音在空气中的传播速度344米/秒计算出模块到障碍物之间的距离D=T*344/2米。</p><p>STM32芯片中集成了强大的定时器模块，其工作状态主要有以下几种模式：输入捕获模式、PWM输入模式、强制输出模式、输出比较模式、PWM模式、单脉冲模式等。在本实验中需要用到的是定时器模块的输入捕获模式。当定时器工作在输入捕获模式下时，当芯片检测到ICx信号引脚上相应的跳变沿后，定时器会将当前的数值锁存在TIMx_CCRx（捕获/比较寄存器）中，同时，在TIMx_SR寄存器中相应的CCxIF标志位被置‘1’，若预先配置使能了中断操作，则同时会响应中断函数。<br><img src="https://img-blog.csdnimg.cn/20190917192401249.png" alt="在这里插入图片描述"><br>图1 HC-SR04超声波测距模块示意图</p><h3 id="三、硬件连接和相关库函数介绍"><a href="#三、硬件连接和相关库函数介绍" class="headerlink" title="三、硬件连接和相关库函数介绍"></a>三、硬件连接和相关库函数介绍</h3><p><img src="https://img-blog.csdnimg.cn/20190917192412671.png" alt="在这里插入图片描述"><br>图2 硬件连接示意图<br>TIM_TimeBaseInitTypeDef结构体参数的配置如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">             <span class="keyword">uint16_t</span> TIM_Prescaler; <span class="comment">// 预分频器</span></span><br><span class="line">             <span class="keyword">uint16_t</span> TIM_CounterMode; <span class="comment">// 计数模式</span></span><br><span class="line">             <span class="keyword">uint32_t</span> TIM_Period; <span class="comment">// 定时器周期</span></span><br><span class="line">             <span class="keyword">uint16_t</span> TIM_ClockDivision; <span class="comment">// 时钟分频</span></span><br><span class="line">             <span class="keyword">uint8_t</span> TIM_RepetitionCounter; <span class="comment">// 重复计算器</span></span><br><span class="line">&#125; TIM_TimeBaseInitTypeDef;</span><br></pre></td></tr></table></figure></p><p>(1) TIM_Prescaler：定时器预分频器设置，时钟源经该预分频器才是定时器时钟，它设定TIMx_PSC 寄存器的值。可设置范围为 0 至 65535，实现 1 至 65536 分频。<br>(2) TIM_CounterMode：定时器计数方式，可是在为向上计数、向下计数以及三种中心对齐模式。基本定时器只能是向上计数，即 TIMx_CNT 只能从 0 开始递增，并且无需初始化。<br>(3) TIM_Period：定时器周期，实际就是设定自动重载寄存器的值，在事件生成时更新到影子寄存器。可设置范围为 0 至 65535。<br>(4) TIM_ClockDivision：时钟分频，设置定时器时钟 CK_INT 频率与数字滤波器采样时钟频率分频比，基本定时器没有此功能，不用设置。<br>(5) TIM_RepetitionCounter：重复计数器，属于高级控制寄存器专用寄存器位，利用它可以非常容易控制输出 PWM 的个数。这里不用设置。</p><h3 id="四、软件流程图"><a href="#四、软件流程图" class="headerlink" title="四、软件流程图"></a>四、软件流程图</h3><p>本实验中使用到的库文件有：oled.c显示屏库函数、sys.c系统库函数、delay.c延时库函数。实验的流程示意图如图3所示：</p><p>图3 程序流程示意图</p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>双轮自平衡机器人。如图4所示，在平衡车背面中间安装了HC-SR04超声波测距模块。<br>ST-Link下载器（包含USB线与下载线）。如图5所示。<br>操作系统：<br>Windows7/8/10，32bit/64bit</p><p><img src="https://img-blog.csdnimg.cn/20190910114001530.png" alt="在这里插入图片描述"><br>图4 双轮自平衡机器人<br>   <img src="https://img-blog.csdnimg.cn/20190910114009746.png" alt="在这里插入图片描述"><br>图5 ST-Link下载器与下载线</p><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><p>Keil 5</p><h3 id="实验场地"><a href="#实验场地" class="headerlink" title="实验场地"></a>实验场地</h3><p>为了直观感受测距效果，试验场地最好设有平整无遮挡墙面。</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h3 id="第一步-配置工程环境"><a href="#第一步-配置工程环境" class="headerlink" title="第一步 配置工程环境"></a>第一步 配置工程环境</h3><p>打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如图6所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。<br><img src="https://img-blog.csdnimg.cn/2019091719272359.png" alt="在这里插入图片描述"><br>图6 工程模板对应的文件夹<br>在HARDWARE文件夹下新建两个文件，分别为timer.c和timer.h。分别存放定时器行数的函数文件和头文件，如图7所示。<br>         <img src="https://img-blog.csdnimg.cn/20190917192735737.png" alt="在这里插入图片描述"><br>图7 在HARDWARE文件夹下建立tiner.c与timer.h文件</p><h3 id="第二步-编写定时器函数，完成定时器的配置和启用"><a href="#第二步-编写定时器函数，完成定时器的配置和启用" class="headerlink" title="第二步 编写定时器函数，完成定时器的配置和启用"></a>第二步 编写定时器函数，完成定时器的配置和启用</h3><p>打开程序中的timer.c文件，首先将timer.h文件包含进来。其次对TIM3_Cap_Init 函数进行编写，选择要使用的时钟，输入捕获的引脚及其参数，并初始化定时器中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：定时器3通道3输入捕获初始化</span></span><br><span class="line"><span class="comment">入口参数：arr::自动重载值  psc:时钟预分频数</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line">TIM_ICInitTypeDef  TIM3_ICInitStructure;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_Cap_Init</span><span class="params">(u16 arr,u16 psc)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">//初始化结构体</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"><span class="comment">//(1) TIM时钟使能， GPIO 时钟使能</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);    <span class="comment">//使能TIM3时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC, ENABLE);    <span class="comment">//使能GPIO 时钟</span></span><br><span class="line"><span class="comment">//(2) GPIO 端口模式设置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0; <span class="comment">//PBO输入</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;   </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_1;     </span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    </span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;    </span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">    <span class="comment">//(3)初始化定时器3(TIM3)</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = arr;    <span class="comment">//设定计数器自动重载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc;    <span class="comment">//预分频器</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; <span class="comment">//设置时钟分割：TDTS = Tck_tim</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">//TIM向上计数模式</span></span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); <span class="comment">//根据TimeBaseStructure中指定的参数初始化TIMx的时间基数单位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)初始化TIM3输入捕获参数</span></span><br><span class="line">TIM3_ICInitStructure.TIM_Channel = TIM_Channel_3; <span class="comment">//CC1S=03选择输入端</span></span><br><span class="line">TIM3_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising; <span class="comment">//上升沿捕获</span></span><br><span class="line">TIM3_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">TIM3_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; <span class="comment">//配置不分频</span></span><br><span class="line">TIM3_ICInitStructure.TIM_ICFilter = <span class="number">0x00</span>;  <span class="comment">//配置输入滤波器，不滤波</span></span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM3_ICInitStructure);</span><br><span class="line"><span class="comment">//(5)中断分组初始化</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  <span class="comment">//TIM3中断    </span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;   <span class="comment">//先占优先级，2级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;  <span class="comment">//从优先级，0级</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; <span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);  <span class="comment">//初始化NVIC寄存器</span></span><br><span class="line"><span class="comment">//(6) 使能捕获和更新中断</span></span><br><span class="line">TIM_ITConfig(TIM3,TIM_IT_Update|TIM_IT_CC3,ENABLE);  <span class="comment">//允许更新中断，允许CC3IE捕获中断</span></span><br><span class="line"><span class="comment">//(7) 使能定时器</span></span><br><span class="line">TIM_Cmd(TIM3, ENABLE);   <span class="comment">//使能定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编写超声波中断脉宽读取中断函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u16 tsr;</span><br><span class="line">tsr=TIM3-&gt;SR;</span><br><span class="line"><span class="keyword">if</span>((TIM3CH3_CAPTURE_STA&amp;<span class="number">0X80</span>)==<span class="number">0</span>)  <span class="comment">//还未成功捕获</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tsr&amp;<span class="number">0X01</span>)  <span class="comment">//溢出</span></span><br><span class="line">    &#123;       </span><br><span class="line">        <span class="keyword">if</span>(TIM3CH3_CAPTURE_STA&amp;<span class="number">0X40</span>)  <span class="comment">//已经捕获到高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((TIM3CH3_CAPTURE_STA&amp;<span class="number">0X3F</span>)==<span class="number">0X3F</span>) <span class="comment">//高电平过长</span></span><br><span class="line">            &#123;</span><br><span class="line">                TIM3CH3_CAPTURE_STA|=<span class="number">0X80</span>; <span class="comment">//标记成功捕获一次</span></span><br><span class="line">                TIM3CH3_CAPTURE_VAL=<span class="number">0XFFFF</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">TIM3CH3_CAPTURE_STA++;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(tsr&amp;<span class="number">0x08</span>)  <span class="comment">//发生捕获事件</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span>(TIM3CH3_CAPTURE_STA&amp;<span class="number">0X40</span>)      <span class="comment">//捕获到一个下降沿    </span></span><br><span class="line">&#123;               </span><br><span class="line">TIM3CH3_CAPTURE_STA|=<span class="number">0X80</span>; <span class="comment">//标记成功捕获一次高电平脉宽</span></span><br><span class="line">TIM3CH3_CAPTURE_VAL=TIM3-&gt;CCR3; <span class="comment">//获取当前的捕获值</span></span><br><span class="line">TIM3-&gt;CCER&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);  <span class="comment">//CC1P=0 设置为上升沿捕获</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>       <span class="comment">//第一次捕获到上升沿</span></span><br><span class="line">&#123;</span><br><span class="line">TIM3CH3_CAPTURE_STA=<span class="number">0</span>;  <span class="comment">//清空</span></span><br><span class="line">TIM3CH3_CAPTURE_VAL=<span class="number">0</span>;</span><br><span class="line">TIM3CH3_CAPTURE_STA|=<span class="number">0X40</span>;  <span class="comment">//标记捕获到了上升沿 </span></span><br><span class="line">TIM3-&gt;CNT=<span class="number">0</span>;         <span class="comment">//计数器清空</span></span><br><span class="line">TIM3-&gt;CCER|=<span class="number">1</span>&lt;&lt;<span class="number">9</span>;     <span class="comment">//CC1P=1 设置为下降沿捕获</span></span><br><span class="line">&#125;           </span><br><span class="line">&#125;                                              </span><br><span class="line">&#125;</span><br><span class="line">TIM3-&gt;SR=<span class="number">0</span>;  <span class="comment">//清除中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(5)编写超声波接受回波函数，计算距离<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">函数功能：超声波接收回波函数</span></span><br><span class="line"><span class="comment">入口参数： 无</span></span><br><span class="line"><span class="comment">返回值： 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="comment">// TIM3CH3_CAPTURE_STA与TIM3CH3_CAPTURE_VAL; 为定时器库里预定义变量，分别指代TIM3通道3的捕获状态寄存器和计时器捕获时间寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_Distane</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    PBout(<span class="number">1</span>)=<span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">15</span>);  </span><br><span class="line">    PBout(<span class="number">1</span>)=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(TIM3CH3_CAPTURE_STA&amp;<span class="number">0X80</span>)  <span class="comment">//成功捕获到一次高电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        Distance=TIM3CH3_CAPTURE_STA&amp;<span class="number">0X3F</span>;</span><br><span class="line">        Distance*=<span class="number">65536</span>;                  <span class="comment">//溢出时间总和</span></span><br><span class="line">        Distance+=TIM3CH3_CAPTURE_VAL;    <span class="comment">//得到总的高电平时间</span></span><br><span class="line">        Distance=Distance*<span class="number">170</span>/<span class="number">1000</span>;</span><br><span class="line">        TIM3CH3_CAPTURE_STA=<span class="number">0</span>;    <span class="comment">//开启下一次捕获</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(6)打开timer.h，编写函数声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys.h&gt;     </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_Cap_Init</span><span class="params">(u16 arr,u16 psc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_Distane</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h3 id="第三步-编写main-c文件"><a href="#第三步-编写main-c文件" class="headerlink" title="第三步 编写main.c文件"></a>第三步 编写main.c文件</h3><p>(7)将工程编译需要用到的头文件包含进来，并预定义显示函数和全局变量。</p><p>#include “timer.h”        //包含定时器函数头文件</p><p>#include “sys.h”          //包含系统头文件</p><p>#include “stm32f10x.h”    //包含系统寄存器定义声明的头文件<br>void oled_show(void);<br>u32 Distance;         //超声波测距变量<br>(8)在主函数中调用延时函数、显示函数和定时器函数的初始化函数。<br>int main(void)<br>{<br>delay_init();       //延时函数初始化<br>OLED_Init();     //OLED初始化<br>TIM3_Cap_Init(0XFFFF,72-1);     //超声波初始化<br>(9)定义主循环，在主循环中调用超声波读取函数和显示函数<br>    while(1)<br>    {<br>        Read_Distane();<br>        oled_show();<br>        delay_ms(500);<br>        }<br>(10)编写OLED显示函数<br>void oled_show(void)<br>{<br>    OLED_ShowString(00,20,”Distance”);<br>    OLED_ShowNumber(95,20,Distance,4,12);<br>    //=============刷新======================//<br>    OLED_Refresh_Gram();<br>}</p><h3 id="第四步-编译并下载，观察实验现象"><a href="#第四步-编译并下载，观察实验现象" class="headerlink" title="第四步 编译并下载，观察实验现象"></a>第四步 编译并下载，观察实验现象</h3><p>(11)本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图8所示。<br><img src="https://img-blog.csdnimg.cn/201909171927552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图8仿真器与下载线连接图<br>(12)编译程序：点击如图9所示的编译按键。<br><img src="https://img-blog.csdnimg.cn/20190917192805248.png" alt="在这里插入图片描述"><br>图1.9 Keil编译环境下的编译按键<br>当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图10所示。<br><img src="https://img-blog.csdnimg.cn/20190917192814132.png" alt="在这里插入图片描述"><br>图10 编译通过后Build Output栏提示信息<br>(13)下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如图11所示。<br><img src="https://img-blog.csdnimg.cn/20190917192824253.png" alt="在这里插入图片描述"><br>图11 Keil编译环境下的下载按键<br>(14)观察实验现象，OLED显示屏上显示出当前超声波传感器测量的距离信息，改变超声波传感器与墙面的距离，观察数值的变化。<br><img src="https://img-blog.csdnimg.cn/20190917192831581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图12 平衡车上的超声波传感器测量数据</p><h2 id="【思考题】"><a href="#【思考题】" class="headerlink" title="【思考题】"></a>【思考题】</h2><h3 id="1、选择题"><a href="#1、选择题" class="headerlink" title="1、选择题"></a>1、选择题</h3><p>题目1：HC-SR04超声波传感器模块返回的数据类型是（D）<br>A：距离数值的数字信号<br>B：距离数值的模拟信号<br>C：发送接收时刻的脉冲信号<br>D：发送接收时刻的跳变沿信号</p><p>题目2：超声波传感器不能运用在以下哪种环境（C）<br>A：空气中<br>B：水中<br>C：真空中<br>D：固体中</p><h3 id="2、简答题"><a href="#2、简答题" class="headerlink" title="2、简答题"></a>2、简答题</h3><p>题目1：STM32通用定时器分别有哪些工作模式？简单介绍输入输出模式的。</p><p>STM32通用定时器的工作模式有计数器模式、输入捕获模式、PWM输入模式、强制输出模式、PWM模式、单脉冲模式、编码器接口模式。</p><p>在输入捕获模式下，当检测到ICx信号上相应的边沿后，计数器的当前值被锁存到捕获/比较寄存器(TIMx_CCRx)中。当捕获事件发生时，相应的CCxIF标志(TIMx_SR寄存器)被置’1’，如果使能了中断或者DMA操作，则将产生中断或者DMA操作。如果捕获事件发生时CCxIF标志已经为高，那么重复捕获标志CCxOF(TIMx_SR寄存器)被置’1’。</p><h2 id="附录：TIM库函数"><a href="#附录：TIM库函数" class="headerlink" title="附录：TIM库函数"></a>附录：TIM库函数</h2><p><img src="https://img-blog.csdnimg.cn/20190924233423899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 传感器 </tag>
            
            <tag> 超声波 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式课程 之 霍尔传感器（编码器）实验</title>
      <link href="/2019/09/10/tech/c-hall/"/>
      <url>/2019/09/10/tech/c-hall/</url>
      
        <content type="html"><![CDATA[<h2 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h2><ol><li>熟悉编码器的种类及其工作原理；</li><li>熟悉编码器的输出形式，熟悉单片机如何通过编码器的输出得到电机的旋转方向和速率；</li><li>掌握STM32F10xx系列微控制器上编码器的接口配置与数据采集过程；<h2 id="【实验原理】"><a href="#【实验原理】" class="headerlink" title="【实验原理】"></a>【实验原理】</h2>编码器（encoder）是指将某一形式的信号或数据（通常特指电机转速）通过采集、编制，转换为可以用于传输、储存的信号形式的设备。编码器按采集方式可以分为接触式编码器和非接触式编码器两种；按工作原理可以分为：光电式、磁电式和触点电刷式编码器。光电式编码器通过采集光通过码盘刻孔产生的脉冲信号的频率进行转换，磁电式编码器通过霍尔元件感应电机转动时产生的磁场变化进行转换，触点电刷式编码器直接采集触点在码盘上的位置进行转换；还可以根据其计数模式分为增量式和绝对式编码器。增量式编码器记录通过采集位移信息产生的脉冲信号，近似于“速率”的概念，绝对式编码器记录位置信息，与过程无关，近似于“路程”的概念。</li></ol><p>本实验采用的编码器为增量式编码器，增量式编码器通常有两个输出信号，分别为A相和B相（也有的编码器有A、B、Z三相输出，有编码器只有A相输出）。每一个信号都是由方波构成的脉冲序列，A相和B相之间的相位差为90度。单片机在接收到AB相输入后，可以根据收到相位的先后顺序确定电机的转向，根据脉冲序列的频率确定电机的转速，这种解码方式称为正交解码。值得注意的是，脉冲频率与电机转速成正比关系，而其具体比例系数会和码盘孔数、减速箱齿数等有关，而转速与行驶速率也存在一个比例系数，因此通常在使用中，会根据实地测试结果直接确定一个脉冲频率与行驶速率之间的经验系数。</p><p>STM32芯片中集成了强大的定时器模块，其工作状态主要有以下几种模式：输入捕获模式、PWM输入模式、强制输出模式、输出比较模式、PWM模式、单脉冲模式、编码器接口模式、调试模式等。在本实验中需要用到的是定时器模块的编码器接口模式。当定时器工作在编码器模式下时，定时器会采集两个指定的引脚输入信号，然后通过检测输入信号的跳变沿，确定输入脉冲的频率及其相位差，从而计算出电机旋转的方向以及速率。编码器接口模式基本上相当于使用了一个带有方向选择的外部时钟。这意味着计数器只在0到TIMx_ARR寄存器的自动装载值之间连续计数(根据方向，或是0到ARR计数，或是ARR到0计数)。所以在开始计数之前必须配置TIMx_ARR。</p><p> <img src="https://img-blog.csdnimg.cn/20190910113846569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 图1 编码器模式下的计数器操作示意图</p><p>值得注意的是，仅仅完成跳变沿检测的功能，普通IO口就能办到。而定时器模块的编码器接口模式相比于普通IO口的优势在于可以抵抗一定的噪音，如图1所示，在输入信号有毛刺的情况下，计数器依然能够正常的工作，普通IO口想要办到类似的功能则需要人为添加一系列代码。<br>程序流程的简要说明图如图2所示：</p><p> <img src="https://img-blog.csdnimg.cn/20190910113938428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图2 程序流程示意图 </p><h2 id="【实验环境】"><a href="#【实验环境】" class="headerlink" title="【实验环境】"></a>【实验环境】</h2><h3 id="硬件设备："><a href="#硬件设备：" class="headerlink" title="硬件设备："></a>硬件设备：</h3><p>1、双轮自平衡机器人。如图3所示，在平衡车背面中间安装了HC-SR04超声波测距模块。<br>2、ST-Link下载器（包含USB线与下载线）。如图4所示。<br>操作系统：<br>Windows7/8/10，32bit/64bit</p><p> <img src="https://img-blog.csdnimg.cn/20190910114001530.png" alt="在这里插入图片描述"><br>图3 双轮自平衡机器人<br>  <img src="https://img-blog.csdnimg.cn/20190910114009746.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190910114023910.png" alt="在这里插入图片描述"><br>图4 ST-Link下载器与下载线</p><h3 id="软件环境："><a href="#软件环境：" class="headerlink" title="软件环境："></a>软件环境：</h3><p>Keil 5</p><h2 id="【实验步骤】"><a href="#【实验步骤】" class="headerlink" title="【实验步骤】"></a>【实验步骤】</h2><h4 id="第一步-配置工程环境"><a href="#第一步-配置工程环境" class="headerlink" title="第一步 配置工程环境"></a>第一步 配置工程环境</h4><p>（1）打开已经建立好的工程模板，在新建立的工程模板中已经添加五个文件夹，分别命名为USER、HARDWARE、SYSTEM、CORE、FWLib文件夹，如图5所示。其中USER文件夹存放的是主函数，HARDWARE文件夹存放的是本实验对应的硬件设备函数，SYSTEM存放的是本课程所有实验通用的函数，CORE文件夹存放的是启动文件，FWLib文件夹存放的是底层驱动函数。<br> <img src="https://img-blog.csdnimg.cn/20190910114120359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图5工程模板对应的文件夹</p><p>（2）在HARDWARE文件夹下新建两个文件，分别为encoder.c和encoder.h。分别存放编码器的函数文件和头文件，如图6所示。<br> <img src="https://img-blog.csdnimg.cn/20190910114140612.png" alt="在这里插入图片描述"><br>图6 在HARDWARE文件夹下建立encoder.c与encoder.h文件</p><h4 id="第二步-编写定时器函数，完成定时器的配置和启用"><a href="#第二步-编写定时器函数，完成定时器的配置和启用" class="headerlink" title="第二步 编写定时器函数，完成定时器的配置和启用"></a>第二步 编写定时器函数，完成定时器的配置和启用</h4><p>（3）打开程序中的encoder.c文件，首先将encoder.h文件包含进来。其次对Encoder_Init_TIM2 函数进行编写，TIM2采集的是左侧的码盘返回值，选择要使用的时钟，配置引脚，启用编码器模式并配置参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"encoder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x_gpio.h"</span></span></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：把TIM2初始化为编码器接口模式</span></span><br><span class="line"><span class="comment">入口参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init_TIM2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  </span><br><span class="line">    TIM_ICInitTypeDef TIM_ICInitStructure;  </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"><span class="comment">//使能定时器4的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line"><span class="comment">//使能PA端口时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1;    <span class="comment">//端口配置</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//浮空输入</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);      <span class="comment">//初始化GPIOA</span></span><br><span class="line">    TIM_TimeBaseStructInit(&amp;TIM_TimeBaseStructure);</span><br><span class="line">    TIM_TimeBaseStructure.TIM_Prescaler = <span class="number">0x0</span>; <span class="comment">//预分频器</span></span><br><span class="line"><span class="comment">//设定计数器自动重载值</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_Period = ENCODER_TIM_PERIOD; </span><br><span class="line"><span class="comment">//选择时钟分频：不分频</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"><span class="comment">//TIM向上计数</span></span><br><span class="line">    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseStructure);</span><br><span class="line">TIM_EncoderInterfaceConfig(TIM2, TIM_EncoderMode_TI12,                  TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<span class="comment">//使用编码器模式</span></span><br><span class="line">    TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">    TIM_ICInitStructure.TIM_ICFilter = <span class="number">10</span>;</span><br><span class="line">    TIM_ICInit(TIM2, &amp;TIM_ICInitStructure);</span><br><span class="line">    TIM_ClearFlag(TIM2, TIM_FLAG_Update);<span class="comment">//清除TIM的更新标志位</span></span><br><span class="line">    TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class="line">    <span class="comment">//Reset counter</span></span><br><span class="line">    TIM_SetCounter(TIM2,<span class="number">0</span>);</span><br><span class="line">    TIM_Cmd(TIM2, ENABLE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) （4）同理，编写Encoder_Init_TIM4函数，TIM4定时器采集的是右侧的编码器返回值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：把TIM4初始化为编码器接口模式</span></span><br><span class="line"><span class="comment">入口参数：无</span></span><br><span class="line"><span class="comment">返回值：无</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init_TIM4</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  </span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;  </span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"><span class="comment">//使能定时器4的时钟</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);</span><br><span class="line"><span class="comment">//使能PB端口时钟</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;    <span class="comment">//端口配置</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; <span class="comment">//浮空输入</span></span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);      <span class="comment">//初始化GPIOA</span></span><br><span class="line">TIM_TimeBaseStructInit(&amp;TIM_TimeBaseStructure);</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler = <span class="number">0x0</span>; <span class="comment">//预分频器</span></span><br><span class="line"><span class="comment">//设定计数器自动重载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = ENCODER_TIM_PERIOD; </span><br><span class="line"><span class="comment">//选择时钟分频：不分频</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line"><span class="comment">//TIM向上计数</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; </span><br><span class="line">TIM_TimeBaseInit(TIM4, &amp;TIM_TimeBaseStructure);</span><br><span class="line">TIM_EncoderInterfaceConfig(TIM4, TIM_EncoderMode_TI12,</span><br><span class="line">TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<span class="comment">//使用编码器模式</span></span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">10</span>;</span><br><span class="line">TIM_ICInit(TIM4, &amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ClearFlag(TIM4, TIM_FLAG_Update);<span class="comment">//清除TIM的更新标志位</span></span><br><span class="line">TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);</span><br><span class="line">TIM_SetCounter(TIM4,<span class="number">0</span>);<span class="comment">//Reset counter</span></span><br><span class="line">TIM_Cmd(TIM4, ENABLE); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（5）编写编码器计数器读取函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************</span></span><br><span class="line"><span class="comment">函数功能：单位时间读取编码器计数</span></span><br><span class="line"><span class="comment">入口参数：定时器</span></span><br><span class="line"><span class="comment">返回值：速度值</span></span><br><span class="line"><span class="comment">*****************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read_Encoder</span><span class="params">(u8 TIMX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Encoder_TIM;    </span><br><span class="line">    <span class="keyword">switch</span>(TIMX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:  Encoder_TIM= (<span class="keyword">short</span>)TIM2 -&gt; CNT;  TIM2 -&gt; CNT=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:  Encoder_TIM= (<span class="keyword">short</span>)TIM4 -&gt; CNT;  TIM4 -&gt; CNT=<span class="number">0</span>;<span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>:  Encoder_TIM=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Encoder_TIM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2) 打开encoder.h，编写函数声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ENCODER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ENCODER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENCODER_TIM_PERIOD (u16)(65535)   <span class="comment">//不可大于65535 因为F103的定时器是16位的</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init_TIM2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoder_Init_TIM4</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Read_Encoder</span><span class="params">(u8 TIMX)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h4 id="第三步-编写main-c文件"><a href="#第三步-编写main-c文件" class="headerlink" title="第三步 编写main.c文件"></a>第三步 编写main.c文件</h4><p>(3) （6）将工程编译需要用到的头文件包含进来，并预定义显示函数和全局变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"encoder.h"</span> <span class="comment">//包含编码器函数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sys.h"</span>   <span class="comment">//包含系统头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span> <span class="comment">//包含系统寄存器定义声明的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> Encoder_Left,Encoder_Right;   <span class="comment">//左右编码器的脉冲计数</span></span><br></pre></td></tr></table></figure></p><p>(4) （7）在主函数中调用延时函数、显示函数和编码器函数的初始化函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">delay_init();      <span class="comment">//延时函数初始化</span></span><br><span class="line">    OLED_Init();     <span class="comment">//OLED初始化</span></span><br><span class="line">        Encoder_Init_TIM2();            <span class="comment">//编码器接口初始化</span></span><br><span class="line">        Encoder_Init_TIM4();            <span class="comment">//编码器接口初始化</span></span><br></pre></td></tr></table></figure></p><p>(5) （8）定义主循环，在主循环中调用超声波读取函数和显示函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Encoder_Left=Read_Encoder(<span class="number">2</span>);       <span class="comment">//读取左侧编码器值</span></span><br><span class="line">    Encoder_Right=Read_Encoder(<span class="number">4</span>);      <span class="comment">//读取右侧编码器值</span></span><br><span class="line">    oled_show();          <span class="comment">//显示屏打开</span></span><br><span class="line">    delay_ms(<span class="number">50</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(6) （9）编写OLED显示函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oled_show</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//显示右侧编码器返回值</span></span><br><span class="line">    OLED_ShowString(<span class="number">0</span>,<span class="number">10</span>,<span class="string">"Encoder_Right"</span>);</span><br><span class="line">    <span class="keyword">if</span>(Encoder_Right &gt;=<span class="number">0</span>)OLED_ShowString(<span class="number">20</span>,<span class="number">20</span>,<span class="string">""</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">20</span>,Encoder_Right,<span class="number">4</span>,<span class="number">12</span>);  </span><br><span class="line">    <span class="keyword">else</span> OLED_ShowString(<span class="number">20</span>,<span class="number">20</span>,<span class="string">"-"</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">20</span>,<span class="number">4</span>-Encoder_Right,<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//显示左侧编码器返回值</span></span><br><span class="line">    OLED_ShowString(<span class="number">0</span>,<span class="number">40</span>,<span class="string">"Encoder_Left"</span>);</span><br><span class="line">    <span class="keyword">if</span>(Encoder_Left&gt;=<span class="number">0</span>)OLED_ShowString(<span class="number">10</span>,<span class="number">50</span>,<span class="string">""</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">50</span>,Encoder_Left,<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">else</span> OLED_ShowString(<span class="number">10</span>,<span class="number">50</span>,<span class="string">"-"</span>),</span><br><span class="line">        OLED_ShowNumber(<span class="number">45</span>,<span class="number">50</span>,-Encoder_Left,<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//=============刷新======================//</span></span><br><span class="line">    OLED_Refresh_Gram();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="第四步-编译并下载，观察实验现象"><a href="#第四步-编译并下载，观察实验现象" class="headerlink" title="第四步 编译并下载，观察实验现象"></a>第四步 编译并下载，观察实验现象</h4><p>（10）本实验采用仿真器为STLink V2，将仿真器与小车相连，注意正负极不要接反，如图7所示。<br> <img src="https://img-blog.csdnimg.cn/20190910114211384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图7仿真器与下载线连接图</p><p>（11）编译程序：点击如图8所示的编译按键。<br> <img src="https://img-blog.csdnimg.cn/20190910114224823.png" alt="在这里插入图片描述"><br>图8Keil编译环境下的编译按键</p><p>（12）当编译完成后，如果没有问题，Build Output栏会出现无错误、无警告的提示，如图9所示。<br> <img src="https://img-blog.csdnimg.cn/2019091011423472.png" alt="在这里插入图片描述"><br>图9编译通过后Build Output栏提示信息</p><p>（13）下载程序：点击如图所示的下载按键，程序就会下载到STM32的芯片中。下载按键如图10所示。<br> <img src="https://img-blog.csdnimg.cn/20190910114241815.png" alt="在这里插入图片描述"><br>图10Keil编译环境下的下载按键</p><p>（14）观察实验现象，OLED显示屏上显示出当前电机的转速，用手从不同方向转动电机，观察数值的变化，结果如图11所示。<br> <img src="https://img-blog.csdnimg.cn/20190910114255167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图11平衡车上的编码器测量数据</p><h2 id="【思考题】"><a href="#【思考题】" class="headerlink" title="【思考题】"></a>【思考题】</h2><h3 id="1、选择题"><a href="#1、选择题" class="headerlink" title="1、选择题"></a>1、选择题</h3><p>题目1：编码器传回的正交编码中，两个信号的相位差是多少（B）<br>A：60度<br>B：90度<br>C：120度<br>D：180度</p><p>题目2：若要配置一个8位的编码器，在encoder.h中的自动重载值应该设为多少（B）<br>A：8<br>B：255<br>C：256<br>D：65535</p><h3 id="2、简答题"><a href="#2、简答题" class="headerlink" title="2、简答题"></a>2、简答题</h3><p>题目1：简要说明如何将编码器的输出转换为方向信息和速率信息。<br>编码器输出为AB两相脉冲信号，A相和B相之间的相位差为90度。单片机在接收到AB相输入后，可以根据收到相位的先后顺序确定电机的转向，根据脉冲序列的频率确定电机的转速。</p><p>题目2：结合相关资料，试说明如何通过IO和中断对编码器的输出数据进行解码。</p><p>（开放性题目，答案不唯一）配置两个IO口为上升下降沿触发中断，设置全局变量表示转速、方向，设置表示跳变的标志位，指定其中一个输入，若该输入触发中断，则转速变量加1，检测相应的寄存器，若为上升沿触发则跳变标志位置1，若为下降沿触发则跳变标志位置0；当另一输入进入中断时，可以根据自身是上升沿还是下降沿触发结合方向标志位，确定自身是超前于另一信号，还是滞后于另一信号，从而确定方向。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 传感器 </tag>
            
            <tag> 霍尔 </tag>
            
            <tag> 编码器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双目摄像头标定流程</title>
      <link href="/2019/07/15/tech/img-cal/"/>
      <url>/2019/07/15/tech/img-cal/</url>
      
        <content type="html"><![CDATA[<p>本文选择使用Matlab进行标定。</p><p>标定过程分3步，接下来分步详细展开：</p><ol><li>使用棋盘格生产图像</li><li>使用图像在Matlab中标定</li><li>使用标定系数</li></ol><h2 id="第一步：使用棋盘格生产图像"><a href="#第一步：使用棋盘格生产图像" class="headerlink" title="第一步：使用棋盘格生产图像"></a>第一步：使用棋盘格生产图像</h2><ol><li>打印棋盘格纸（这一步建议选择矩形棋盘格，否则容易因为原点不同出现标定偏差，本文版本放在文末了）</li><li>在目录下创建两个文件夹：frameRight、frameLeft</li><li>执行ImageCaptureFromCamera.py</li><li>分别使得棋盘在两个摄像头视野中的不同角度，按空格键创建图片</li></ol><h2 id="第二步：使用图像在Matlab中标定"><a href="#第二步：使用图像在Matlab中标定" class="headerlink" title="第二步：使用图像在Matlab中标定"></a>第二步：使用图像在Matlab中标定</h2><ol><li>参考Matlab官网介绍（<a href="https://cn.mathworks.com/help/vision/ug/stereo-camera-calibrator-app.html?s_tid=gn_loc_drop）" target="_blank" rel="noopener">https://cn.mathworks.com/help/vision/ug/stereo-camera-calibrator-app.html?s_tid=gn_loc_drop）</a></li><li>打开Matlab的Stereo Camera Calibrate应用</li><li>添加图片，1选择Left目录，2选择Right目录，长度填入真实棋盘长度（18）mm</li><li>径向畸变选择3参数，选择切向畸变</li><li>开始校正</li><li>导出参数</li></ol><h2 id="第三步：使用标定系数"><a href="#第三步：使用标定系数" class="headerlink" title="第三步：使用标定系数"></a>第三步：使用标定系数</h2><ol><li>参考Opencv官网（<a href="https://docs.opencv.org/3.3.1/d9/d0c/group__calib3d.html#ga617b1685d4059c6040827800e72ad2b6）" target="_blank" rel="noopener">https://docs.opencv.org/3.3.1/d9/d0c/group__calib3d.html#ga617b1685d4059c6040827800e72ad2b6）</a></li><li>调用Opencv的stereoCalibrate()函数</li><li>参数对应关系如下：<br>Matlab | Opencv<br>RotationOfCamera2 |  R<br>TranslationOfCamera2  |  T<br>CameraParameters1.IntrinsicMatrix |  left_camera_matrix<br>CameraParameters1.RadialDistortion | left_distortion<br>CameraParameters1.TangentialDistortion | left_distortion<br>CameraParameters2.IntrinsicMatrix  | right_camera_matrix<br>CameraParameters2.RadialDistortion  |right_distortion<br>CameraParameters2.TangentialDistortion | right_distortion</li></ol><p>注意，distortion：Opencv的参数是一个，Matlab有两个需要进行组合，组合方式如下：<br><img src="/img/tech/20190715175101.png" title="matlab"></p><p>camera_matrix：Opencv的参数是由Matlab参数转置得到的。<br><img src="/img/tech/20190715175102.png" title="matlab"></p><p>特别感谢：清华大学的董同学指导。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目摄像头 </tag>
            
            <tag> 标定 </tag>
            
            <tag> Opencv </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测距方案 - 基于双目摄像头和特定颜色物体</title>
      <link href="/2019/07/15/proj/img-sm/"/>
      <url>/2019/07/15/proj/img-sm/</url>
      
        <content type="html"><![CDATA[<p>方案基于Matlab2018，Python 2.7、Opencv 3.4实现，实现流程如下：</p><ol><li>首先，使用Matlab，进行双目摄像头的标定； </li><li>其次，识别特定颜色； </li><li>最后，使用双目测距公式得到特征点的距离。</li></ol><h2 id="摄像头标定"><a href="#摄像头标定" class="headerlink" title="摄像头标定"></a>摄像头标定</h2><p>首先进行摄像头的标定，具体标定流程，点击<a href="https://www.zhenxiangsimple.com/2019/07/15/tech-img-sm/">https://www.zhenxiangsimple.com/2019/07/15/tech-img-sm/</a> 查看</p><h2 id="识别特定颜色物体"><a href="#识别特定颜色物体" class="headerlink" title="识别特定颜色物体"></a>识别特定颜色物体</h2><p>在cvt颜色空间中，使用颜色对应范围进行过滤，详细代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTargetPoint</span><span class="params">(self,frameRectified)</span>:</span></span><br><span class="line">    hsvImg = cv2.cvtColor(frameRectified, cv2.COLOR_BGR2HSV)</span><br><span class="line">    maskImg = cv2.inRange(hsvImg, self.lower_range, self.upper_range)</span><br><span class="line">    <span class="comment"># Detect contour for both left and right images</span></span><br><span class="line">    (_, cntsImg, _) = cv2.findContours(maskImg, cv2.RETR_EXTERNAL,</span><br><span class="line">                    cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment"># If the spot is out of view, then go to next frame</span></span><br><span class="line">    <span class="keyword">if</span> len(cntsImg) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># find target obj</span></span><br><span class="line">    maxArea,maxIdx = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>,len(cntsImg)):</span><br><span class="line">        _,_,w,h = cv2.boundingRect(cntsImg[idx])</span><br><span class="line">        tmpArea = w * h</span><br><span class="line">        <span class="keyword">if</span> tmpArea &gt; maxArea:</span><br><span class="line">            maxArea = tmpArea</span><br><span class="line">            maxIdx = idx</span><br><span class="line">    <span class="comment"># compute the center of the contour in the frame</span></span><br><span class="line">    M = cv2.moments(cntsImg[maxIdx])</span><br><span class="line">    <span class="keyword">if</span> M[<span class="string">"m00"</span>] == <span class="number">0</span>:</span><br><span class="line">        cXTarget = cntsImg[maxIdx][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        cYTarget = cntsImg[maxIdx][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:        </span><br><span class="line">        cXTarget = int(M[<span class="string">"m10"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line">        cYTarget = int(M[<span class="string">"m01"</span>] / M[<span class="string">"m00"</span>])</span><br><span class="line">    <span class="comment"># draw the contour and center of the shape on the image</span></span><br><span class="line">    cv2.drawContours(frameRectified, cntsImg, maxIdx, (<span class="number">240</span>, <span class="number">0</span>, <span class="number">159</span>), <span class="number">1</span>)</span><br><span class="line">    cv2.circle(frameRectified, (cXTarget, cYTarget), <span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>,cXTarget,cYTarget)</span><br></pre></td></tr></table></figure><h2 id="测距公式计算"><a href="#测距公式计算" class="headerlink" title="测距公式计算"></a>测距公式计算</h2><p>其计算原理如下图所示，计算公式为：$实际距离 = 焦距 \times 摄像头间距 \div 视差$，opencv官网给的参考链接：<a href="https://docs.opencv.org/3.3.1/d9/d0c/group__calib3d.html" target="_blank" rel="noopener">https://docs.opencv.org/3.3.1/d9/d0c/group__calib3d.html</a></p><center><img src="/img/proj/20190715172704115.png" width="450" height="300" title="测距原理图"></center>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 图像相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目摄像头 </tag>
            
            <tag> 测距 </tag>
            
            <tag> 特定颜色物体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理的过程和知识</title>
      <link href="/2019/07/15/proj/manage-510/"/>
      <url>/2019/07/15/proj/manage-510/</url>
      
        <content type="html"><![CDATA[<p>5个过程组包括启动、规划、执行、监控和收尾，10个知识领域包括对项目的范围、进度、成本、质量、资源、风险、采购及相关方等领域管理的知识。</p><h2 id="10个知识领域"><a href="#10个知识领域" class="headerlink" title="10个知识领域"></a>10个知识领域</h2><h4 id="4-项目整合管理"><a href="#4-项目整合管理" class="headerlink" title="4. 项目整合管理"></a>4. 项目整合管理</h4><p>4.1 制定项目章程<br>4.2 制定项目管理计划<br>4.3 指导与管理项目工作<br>4.4 管理项目只是<br>4.5 监控项目工作<br>4.6 实时整体变更控制<br>4.7 结束项目或阶段</p><h4 id="5-项目范围管理"><a href="#5-项目范围管理" class="headerlink" title="5. 项目范围管理"></a>5. 项目范围管理</h4><p>5.1 规划范围管理<br>5.2 收集需求<br>5.3 定义范围<br>5.4 创建WBS<br>5.5 确认范围<br>5.6 控制范围</p><h4 id="6-项目进度管理"><a href="#6-项目进度管理" class="headerlink" title="6. 项目进度管理"></a>6. 项目进度管理</h4><p>6.1 规划进度管理<br>6.2 定义活动<br>6.3 排列活动顺序<br>6.4 估算活动持续时间<br>6.5 制定进度计划<br>6.6 控制进度</p><h4 id="7-项目成本管理"><a href="#7-项目成本管理" class="headerlink" title="7. 项目成本管理"></a>7. 项目成本管理</h4><p>7.1 规划成本管理<br>7.2 估算成本<br>7.3 制定预算<br>7.4 控制成本</p><h4 id="8-项目质量管理"><a href="#8-项目质量管理" class="headerlink" title="8. 项目质量管理"></a>8. 项目质量管理</h4><p>8.1 规划质量管理<br>8.2 管理质量<br>8.3 控制质量</p><h4 id="9-项目资源管理"><a href="#9-项目资源管理" class="headerlink" title="9. 项目资源管理"></a>9. 项目资源管理</h4><p>9.1 规划资源管理<br>9.2 估算活动资源<br>9.3 获取资源<br>9.4 建设团队<br>9.5 管理团队<br>9.6 控制资源</p><h4 id="10-项目沟通管理"><a href="#10-项目沟通管理" class="headerlink" title="10. 项目沟通管理"></a>10. 项目沟通管理</h4><p>10.1 规划沟通管理<br>10.2 管理沟通<br>10.3 监督沟通</p><h4 id="11-项目风险管理"><a href="#11-项目风险管理" class="headerlink" title="11. 项目风险管理"></a>11. 项目风险管理</h4><p>11.1 规划风险管理<br>11.2 识别风险<br>11.3 实施定型风险分析<br>11.4 实施定量风险分析<br>11.5 规划风险应对<br>11.6 实施风险应对<br>11.7 监督风险</p><h4 id="12-项目采购管理"><a href="#12-项目采购管理" class="headerlink" title="12. 项目采购管理"></a>12. 项目采购管理</h4><p>12.1 规划采购管理<br>12.2 实施采购<br>12.3 控制采购</p><h4 id="13-项目相关方管理"><a href="#13-项目相关方管理" class="headerlink" title="13. 项目相关方管理"></a>13. 项目相关方管理</h4><p>13.1 识别相关方<br>13.2 规划相关方参与<br>13.3 管理相关方参与<br>13.4 监督相关方参与</p><h2 id="5个过程组"><a href="#5个过程组" class="headerlink" title="5个过程组"></a>5个过程组</h2><ol><li>启动</li><li>规划</li><li>执行</li><li>监控</li><li>收尾</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 项目管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
            <tag> 5个过程组 </tag>
            
            <tag> 10个知识领域 </tag>
            
            <tag> 第六版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>物联网方案 - 数据采集和控制系统（Web+微信小程序）</title>
      <link href="/2019/07/12/proj/iot-shjcj/"/>
      <url>/2019/07/12/proj/iot-shjcj/</url>
      
        <content type="html"><![CDATA[<p>当前方案是为硬件方案厂商做的数据采集及信息管理系统，核心包括两部分，分别如下：</p><ol><li>用于采集数据的后端服务器</li><li>用于显示统计数据的前端，包括Web端和微信小程序端</li></ol><center><img src="/img/proj/20190712173432.png" width="250" height="200" title="系统整体框图"></center><h2 id="亮点"><a href="#亮点" class="headerlink" title="亮点"></a>亮点</h2><ol><li>全系统拥有独立知识产权，可根据具体业务进行定制开发</li><li>数据采集和管理服务器分离，保证数据安全稳定</li><li>Web和微信小程序，实现设备状态查看和控制</li></ol><h2 id="Web端"><a href="#Web端" class="headerlink" title="Web端"></a>Web端</h2><p>Web端用于进行设备的权限及经销商管理，以及整体的数据分析。</p><p><img src="/img/proj/20190712162910163.png" width="400" height="250" alt="主页面统计信息"><img src="/img/proj/20190712163151975.png" width="400" height="250" alt="设备报警信息页"><img src="/img/proj/20190712163340508.png" width="400" height="250" alt="设备列表页"></p><h2 id="微信小程序端"><a href="#微信小程序端" class="headerlink" title="微信小程序端"></a>微信小程序端</h2><p>小程序端用于进行少量的设备核心信息查看和控制。</p><p><img src="/img/proj/20190712165129104.png" width="200" height="320" alt="系统登录"><img src="/img/proj/20190712164941132.png" width="200" height="320" alt="设备机组状态"><img src="/img/proj/20190712165044938.png" width="200" height="320" alt="设备开关机"></p><p>若对方案感兴趣，或有需要了解方案详情，欢迎来撩<br><img src="/img/proj/20190712120342767.png" width="200" height="200" title="个人微信"></p>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> Web设备管理 </tag>
            
            <tag> 服务器分离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为应用市场 隐私政策</title>
      <link href="/2019/07/12/tech/android-yszc/"/>
      <url>/2019/07/12/tech/android-yszc/</url>
      
        <content type="html"><![CDATA[<p>欢迎您使用云计算器（以下简称“本服务”），云计算器是由深圳互动网络科技有限公司（以下简称“本公司”）向云计算器用户提供的计算器工具。为保证您的权益，便于更好地使用云计算器及相应的配套服务，请您务必在注册前认真阅读本协议，若您阅读并接受本协议，使用云计算器提供的产品和服务，即视为您受本协议的约束，若您不同意本协议，请勿使用本网站任何产品和服务。<br>一、服务内容<br>云计算器运用自己的系统通过互联网络为用户提供语音、图片及传统手动输入等计算服务。用户使用本服务需要下载云计算器客户端软件，同时，用户必须：<br>1、自行配备上网所需设备，包括个人电脑、调制解调器或其他必备上网装置。<br>2、自行负担个人上网所支付的与此服务有关的电话费用、网络费用。<br>二、服务的提供、修改及终止<br>1、您保证在您同意接受本协议并注册成为云计算器用户时，您是具备完全民事权利能力和完全民事行为能力的自然人。<br>三、用户隐私制度<br>1、本公司将会采取合法、合理的措施保护用户的个人信息，非经法定原因或用户事先许可，本公司不会向任何第三方透露您的非公开信息。以下情况除外：<br>1）用户授权云计算器透露这些信息。<br>2）相关的法律法规或监管机构、司法机构要求云计算器提供您的个人资料；国家司法机关符合法律规定并经法定程序的检查及其他操作。<br>3）任何第三方盗用、冒用或未经许可擅自披露、使用或对外公开您的个人隐私资料。<br>4）由您要求网站提供特定服务时，需要把您的姓名和地址提供给第三方的。<br>5）您在使用本服务、参加网站活动或访问网站网页时，自动接收并记录的浏览器端或手机客户端数据，包括但不限于IP地址、网站Cookie中的资料及您要求取用的网页记录。<br>6）云计算器从商业伙伴处合法获取的个人信息。<br>2、在适合的情况下，并在您同意的前提下，我们会利用您的信息来联络您，为您发送信息。<br>3、您应当妥善保管您的设备和密码及身份信息，对于因密码泄露、身份信息泄露、设备丢失所致的损失，由您自行承担。<br>四、用户行为规范除非法律允许或本公司书面许可，您使用本软件过程中不得从事下列行为：<br>1、删除本软件及其副本上关于著作权的信息。<br>2、对本软件进行反向工程、反向汇编、反向编译，或者以其他方式尝试发现本软件的源代码。<br>3、对本公司拥有知识产权的内容进行使用、出租、出借、复制、修改、链接、转载、汇编、发表、出版、建立镜像站点等。<br>4、对本软件或者本软件运行过程中释放到任何终端内存中的数据、软件运行过程中客户端与服务器端的交互数据，以及本软件运行所必需的系统数据，进行复制、修改、增加、删除、挂接运行或创作任何衍生作品，形式包括但不限于使用插件、外挂或非本公司经授权的第三方工具/服务接入本软件和相关系统。<br>5、通过修改或伪造软件运行中的指令、数据，增加、删减、变动软件的功能或运行效果，或者将用于上述用途的软件、方法进行运营或向公众传播，无论这些行为是否为商业目的。<br>6、通过修改或伪造软件运行中的指令、数据，增加、删减、变动软件的功能或运行效果，或者将用于上述用途的软件、方法进行运营或向公众传播，无论这些行为是否为商业目的。<br>7、自行或者授权他人、第三方软件对本软件及其组件、模块、数据进行干扰。<br>8、其他未经本公司明示授权的行为。<br>五、适用法律和管辖权<br>1、企鹅外汇注册所在地法律、法规应规范本协议以及本协议各方之间引起的争议，除非存在法律指定适用其他管辖法律。<br>2、在合约一方寻求实现本协议下的权利，或寻求宣告本协议下的任何权利或义务的任何民事诉讼或其他诉讼过程中，各合约方应承担其代理律师的费用和支出。<br>3、本协议的解释语言应为中文。<br>4、本公司可能通过多种语言将本协议或任何其他文件、信息和消息提供给合作方。本协议规定，合作方应当承认及确认本公司工作语言为中文。如果任何文件、信息和消息的非中文表述和中文表述之间出现矛盾和不一致的情况下，双方将以中文文件、信息和消息为标准。<br>六、免责条款<br>1、云计算器旨在为客户提供计算器工具服务。<br>2、本软件语音和图像识别所提供的信息来自科大讯飞，计算结果仅供参考，不能作为单一依据<br>3、任何由于黑客攻击、计算机病毒侵入或发作、因政府管制而造成的暂时性关闭等影响网络正常经营的不可抗力而造成的个人资料泄露、丢失、被盗用或被窜改等，平台应及时采取补救措施，不承担任何责任。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>隐私政策</title>
      <link href="/2019/07/12/tech/yszc/"/>
      <url>/2019/07/12/tech/yszc/</url>
      
        <content type="html"><![CDATA[<p>欢迎您使用本移动应用（以下简称“本服务”），本移动应用是由深圳互动网络科技有限公司（以下简称“本公司”）向本移动应用用户提供的计算器工具。为保证您的权益，便于更好地使用本移动应用及相应的配套服务，请您务必在注册前认真阅读本协议，若您阅读并接受本协议，使用本移动应用提供的产品和服务，即视为您受本协议的约束，若您不同意本协议，请勿使用本网站任何产品和服务。<br>一、服务内容<br>本移动应用运用自己的系统通过互联网络为用户提供语音、图片及传统手动输入等计算服务。用户使用本服务需要下载本移动应用客户端软件，同时，用户必须：<br>1、自行配备上网所需设备，包括个人电脑、调制解调器或其他必备上网装置。<br>2、自行负担个人上网所支付的与此服务有关的电话费用、网络费用。<br>二、服务的提供、修改及终止<br>1、您保证在您同意接受本协议并注册成为本移动应用用户时，您是具备完全民事权利能力和完全民事行为能力的自然人。<br>三、用户隐私制度<br>1、本公司将会采取合法、合理的措施保护用户的个人信息，非经法定原因或用户事先许可，本公司不会向任何第三方透露您的非公开信息。以下情况除外：<br>1）用户授权本移动应用透露这些信息。<br>2）相关的法律法规或监管机构、司法机构要求本移动应用提供您的个人资料；国家司法机关符合法律规定并经法定程序的检查及其他操作。<br>3）任何第三方盗用、冒用或未经许可擅自披露、使用或对外公开您的个人隐私资料。<br>4）由您要求网站提供特定服务时，需要把您的姓名和地址提供给第三方的。<br>5）您在使用本服务、参加网站活动或访问网站网页时，自动接收并记录的浏览器端或手机客户端数据，包括但不限于IP地址、网站Cookie中的资料及您要求取用的网页记录。<br>6）本移动应用从商业伙伴处合法获取的个人信息。<br>2、在适合的情况下，并在您同意的前提下，我们会利用您的信息来联络您，为您发送信息。<br>3、您应当妥善保管您的设备和密码及身份信息，对于因密码泄露、身份信息泄露、设备丢失所致的损失，由您自行承担。<br>四、用户行为规范除非法律允许或本公司书面许可，您使用本软件过程中不得从事下列行为：<br>1、删除本软件及其副本上关于著作权的信息。<br>2、对本软件进行反向工程、反向汇编、反向编译，或者以其他方式尝试发现本软件的源代码。<br>3、对本公司拥有知识产权的内容进行使用、出租、出借、复制、修改、链接、转载、汇编、发表、出版、建立镜像站点等。<br>4、对本软件或者本软件运行过程中释放到任何终端内存中的数据、软件运行过程中客户端与服务器端的交互数据，以及本软件运行所必需的系统数据，进行复制、修改、增加、删除、挂接运行或创作任何衍生作品，形式包括但不限于使用插件、外挂或非本公司经授权的第三方工具/服务接入本软件和相关系统。<br>5、通过修改或伪造软件运行中的指令、数据，增加、删减、变动软件的功能或运行效果，或者将用于上述用途的软件、方法进行运营或向公众传播，无论这些行为是否为商业目的。<br>6、通过修改或伪造软件运行中的指令、数据，增加、删减、变动软件的功能或运行效果，或者将用于上述用途的软件、方法进行运营或向公众传播，无论这些行为是否为商业目的。<br>7、自行或者授权他人、第三方软件对本软件及其组件、模块、数据进行干扰。<br>8、其他未经本公司明示授权的行为。<br>五、适用法律和管辖权<br>1、企鹅外汇注册所在地法律、法规应规范本协议以及本协议各方之间引起的争议，除非存在法律指定适用其他管辖法律。<br>2、在合约一方寻求实现本协议下的权利，或寻求宣告本协议下的任何权利或义务的任何民事诉讼或其他诉讼过程中，各合约方应承担其代理律师的费用和支出。<br>3、本协议的解释语言应为中文。<br>4、本公司可能通过多种语言将本协议或任何其他文件、信息和消息提供给合作方。本协议规定，合作方应当承认及确认本公司工作语言为中文。如果任何文件、信息和消息的非中文表述和中文表述之间出现矛盾和不一致的情况下，双方将以中文文件、信息和消息为标准。<br>六、免责条款<br>1、本移动应用旨在为客户提供计算器工具服务。<br>2、本软件语音和图像识别所提供的信息来自科大讯飞，计算结果仅供参考，不能作为单一依据<br>3、任何由于黑客攻击、计算机病毒侵入或发作、因政府管制而造成的暂时性关闭等影响网络正常经营的不可抗力而造成的个人资料泄露、丢失、被盗用或被窜改等，平台应及时采取补救措施，不承担任何责任。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>物联网方案 - 设备的自动化升级项目（某上市公司生产车间）</title>
      <link href="/2019/07/12/proj/iot-autoup/"/>
      <url>/2019/07/12/proj/iot-autoup/</url>
      
        <content type="html"><![CDATA[<p>项目核心包括软件系统和硬件系统两部分，用于提高车间管理效率：</p><ol><li>硬件系统实现通过传感器对原生产设备的数据采集和控制</li><li>软件系统实现生产数据的收集、存储、处理和展示，以及设备的基本控制</li></ol><center><img src="/img/proj/20190712115935818.png" width="250" height="200" title="系统整体框图"></center><h2 id="方案亮点："><a href="#方案亮点：" class="headerlink" title="方案亮点："></a>方案亮点：</h2><ol><li>软硬件一体解决方案，全系统拥有独立知识产权</li><li>跟企业ERP对接，为生产任务分派提供建议</li><li>实时统计各设备、员工及车间的产能和效率</li></ol><h2 id="硬件模块"><a href="#硬件模块" class="headerlink" title="硬件模块"></a>硬件模块</h2><ol><li>自主设计主控板卡<br>硬件部分，针对设备数据采集及远程控制的需求，自主设计研发了主控板卡进行设备端各模块的管理。</li><li>基本工作原理<br>工作原理是，通过光电传感器，根据设备动作和产品状态进行统计，实现生产数据的实时且准确采集，并定时将所有数据上传给服务器进行管理。</li><li>状态监控功能<br>温、湿度传感器可以进行环境状态的监控，同时支持警报器及三色灯等状态显示模块。</li></ol><center><img src="/img/proj/20190712115237198.png" width="250" height="200" title="硬件主控板卡"></center><h2 id="软件模块"><a href="#软件模块" class="headerlink" title="软件模块"></a>软件模块</h2><ol><li>自主设计与研发<br> 软件部分，根据客户对数据管理和应用的需求，进行自主设计和研发的软件系统，包括实时通信服务器和信息管理服务器两部分，将两个系统进行分离保证数据的安全与稳定。</li><li>实时通信功能模块<br> 其中实时通信服务器，负责接受并存储来自所有生产设备（目前200台）的信息，并对设备进行远程控制。</li><li>信息管理服务模块<br> 信息管理服务器，用于对设备状态及生产统计报表（设备、员工、车间）进行实时展示，同时基于准确的生产数据，进行订单完成时间预估和新订单排单建议。</li></ol><p>若对方案感兴趣，或有需要了解方案详情，欢迎来撩<br><img src="/img/proj/20190712120342767.png" width="200" height="200" title="个人微信"></p>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
          <category> 物联网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软硬件一体解决方案 </tag>
            
            <tag> 数据采集统计 </tag>
            
            <tag> ERP对接 </tag>
            
            <tag> 设备升级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《九门提督》</title>
      <link href="/2019/05/04/life/movice-jmtd/"/>
      <url>/2019/05/04/life/movice-jmtd/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;尽管盗墓相关的九门题材也是自己喜欢的，但这里的九门跟盗墓里说的九门不是一回事，整部剧都是政治正确，坏人做坏事会受到应有的惩罚，好人也会由于各自的苦衷或执念，迫不得已做一些违心的事情，最终每个人得到了该有的结果。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;很多中国人心中都有个武侠梦，也许正是因为这样，所以金庸古龙的小说才有这么多的受众，也可能是反过来，正因为金庸古龙的小说以及拍摄的影视剧在国内盛行，对我们的价值观进行了影响，所以心中才有了侠义江湖。<br>&emsp;&emsp;自己小时候都比较喜欢看古装的这些动作片，比如以唐朝狄仁杰、宋朝包拯、明朝东厂等等故事为背景的影视剧，当前这部也是基于明朝为背景来展开。看完电影整体感受就是过于政治正确，坏人都往一个人头上扣，最后必然会被自作孽不可活，而其他人不论立场在哪边都是心本善，只是不同立场的人各为其主，人在江湖身不由己。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;九门是明永乐年间，明成祖朱棣设立的军情处刺杀组织，用于监察文武百官，其中的成员被称为刺客，各刺客都是隐藏于京城的绝顶武功高手，目的是为皇帝和朝廷做一些见不得光的事情，或者直接处理一些棘手的事务。<br>&emsp;&emsp;男主是九门的总兵，为朝廷追查去向不明的军饷下落，去找吏部尚书喝茶，但被自己的九门提督的儿子（也是九门的人）暗算，后来发现提督的儿子才是罪魁祸首，只是提督为了保持自己的家族血脉不得已牺牲了九门，以九门兄弟们的生命为代价希望保护自己的儿子，怎奈男主武艺超群将九门兄弟一一击破，最后在为朝廷完成使命将提督儿子干掉后，向提督送上了自己的人头，报答了提督对自己的栽培。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动作片 </tag>
            
            <tag> 古装 </tag>
            
            <tag> 明朝 </tag>
            
            <tag> 刺客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《人间·喜剧》</title>
      <link href="/2019/05/04/life/movice-rjxj/"/>
      <url>/2019/05/04/life/movice-rjxj/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这个电影看起来有些无厘头，但跟周星驰的无厘头又不同。看完电影感慨有影院愿意上映，第一反应就是任达华撑起了电影，但是细想其实也算是喜剧电影的一种探索，只是跟传统的喜剧不同，不再是一味的增加细节的包袱，而是基于黑帮故事作为背景进行创作，在传统的黑帮风格中加入喜剧元素来表现喜剧，显然喜剧效果并不是特别好。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;不知是广电总局的约束，还是是观众口味的变化，现在看的带黑帮性质的电影很少了，当然这部剧是作为喜剧进行上映主要就是体现一种喜剧效果，之前看的古惑仔各种江湖义气，打打杀杀是其表现力的一种手段，但底层就是对金钱、利益和权力的追逐，这部片子将底层逻辑和手段都更换为具有较强喜剧色彩的内容。<br>&emsp;&emsp;之前被黑帮保护的严加看管的核心要么是钻石、黄金，要么是仿制假币的模板，现在的是老大的精子，各路老大由于各自原因，都把自己的精子作为最珍视的宝贝；之前黑帮的争夺的方式要么是抢商业银行，偷盗金银财宝，要么争抢地盘收取保护费，这里居然偷抢精子银行，也算是一种喜剧效果。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;艾伦是一家公司的打工仔，但被拖欠工资2万工资，另该公司老板的儿子欠任达华1百万，两人因为同时到公司经理办公室拿钱而碰巧遇到，进而一起经历了一些荒唐的无厘头故事。<br>&emsp;&emsp;当然作为喜剧电影，故事里的坏人都是要死掉或者被警察抓起来的，最终任达华因为多疑，导致自己兄弟跟自己反目，最终相互激战后双双毙命，很多情节其实更多应该只是为了喜剧效果而进行的设计，比如，任达华保存精子是因为之前被人用刀偷袭了小兄弟，艾伦卡在墙中间还被用绳子绑住，进退不得一直卡了好长时间。<br>&emsp;&emsp;感觉该部剧并没有达到喜剧的效果，也许是自己的笑点变了或者笑点高了，也许被各类娱乐节目的快餐文化消费后，短平快的喜剧娱乐节目对核心笑料的展现，更容易满足人的笑点，也许慢慢的喜剧电影都不再是那种让人边看边哈哈大笑类型，更多会走向立意或者会心一笑的方向。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 喜剧片 </tag>
            
            <tag> 黑帮 </tag>
            
            <tag> 任达华 </tag>
            
            <tag> 艾伦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《绿皮书》</title>
      <link href="/2019/05/04/life/movice-lps/"/>
      <url>/2019/05/04/life/movice-lps/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这是一部基于种族歧视题材的电影，基于真实历史故事进行改编，现在看来也许很多事情有些不可思议，但返回历史现场也许一切都是那么自然，尤其是在奴隶制时代奴隶被当作商品进行交易。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;看完电影整体感受就是温暖，即使社会有其特有的环境和我们普通人无法违背的规则，但法理之外还有人情，就像那句“都说大河向东流，我家门前水向西”，大环境是我们无法违抗的，但在我们生活的小环境中也许很多规则都是基于人的规则，而每个小环境的累加就会慢慢改变大环境，最终家国一体。<br>&emsp;&emsp;这两年国内的电影市场，感觉快被明星或者流量IP搞死了，好久没这么好的电影看到了，也许真实的故事更容易让人有切身的感受，更容易代入情景去感受和体会主人公的心境，而不只是一个基于虚无缥缈的玄幻小说当作故事，尽管自己也很喜欢权力的游戏这部剧，但相对来讲更愿意看到绿皮书这样的影视剧。<br>&emsp;&emsp;尽管绿皮书是基于美国故事的电影，但看了后依旧备受感动，但感觉这个电影的中文名字不够响亮，如果换个更有流量的中文名，估计会有更高的票房，但也许这类电影本身也没有打算追求票房，只是拍摄导演的情怀，真希望国内电影也多一点这样的，而不是一个鲜肉只是刷个脸，台词也靠对嘴型，蹦蹦跳跳就赚走几千万。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;电影中一反过去的白人是高高在上的好教养，黑人是底层生活的各种低素质人群，而是黑人雇主接收了最好的教育，接收了上层社会的生活，而白人司机却是一位生活在底层的普通的打工者，每日为生计而奔波。跟所有白人一样，一开始白人司机也有较强的种族歧视，一个场景是白人司机家里请来的黑人工人，工作完后喝过水的杯子都被其丢掉，即使其家庭经济本身已经比较拮据了。<br>&emsp;&emsp;作为司机的白人，跟着雇主去到种族歧视更严重的南部进行巡演，随着往南走歧视越来越严重，两人一起在一路上经历了很多的故事，最终也相互支持和理解成为了好朋友。<br>&emsp;&emsp;有个餐厅由于不能接收黑人使用其厕所，所以男主不得已在中途休息时，花一个小时返回酒店上完厕所后继续进行下半场表演。在最后一站矛盾升级到了最大，也是在一家歧视严重的餐厅，邀请其进行表演的餐厅，由于肤色原因不能接收男主在该餐厅进餐，即使已经有400为上层人士特地过来餐厅观看其表演，即使男主有为该表演签订合同，最终男主还是取消了该场表演。<br>&emsp;&emsp;峰回路转，在经历了最后的矛盾激化后，在回家的路上经过一个黑人为主的酒吧，在酒吧里男主的表演得到了周围人的鼓励和认可，男主甚至表示之后每个月都要过来进行类似的一次免费表演，强烈的对比反差。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剧情片 </tag>
            
            <tag> 种族歧视 </tag>
            
            <tag> 美国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《从零开始读懂金融学》</title>
      <link href="/2019/05/04/books/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%87%82%E9%87%91%E8%9E%8D%E5%AD%A6/"/>
      <url>/2019/05/04/books/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E8%AF%BB%E6%87%82%E9%87%91%E8%9E%8D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这本书是关于经济及金融相关的基础书，全书共294页，整体分两部分，前面一部分介绍金融中的一些基本的经济概念，从各金融市场概念到各类金融机构的一般性介绍；后面一部分围绕个人理财进行相关概念的介绍和原理的说明，整体来讲如果对经济及金融知识感兴趣，<strong>推荐阅读</strong>。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;这本书是自己这些年读的经济相关通俗图书中，阅读体验最棒的一本，看了下是14年6月第一次出版，2018年1月这本书已经第18次印刷， 截至本文编辑时，其在京东自营中金融与投资销量榜分类中排名第18位（好像跟18杠上了），可见其在读者中还是特别受欢迎的。<br>&emsp;&emsp;尽管自己对一些基本的经济和金融知识有所了解，甚至5年前就业余时间考过了证券从业，但从书中还是从横向相对系统的学习到了不少金融学概念，也加深了挺多经济学知识的理解。作者名为斯凯恩感觉像个外国人，但从其文笔内容来看更多是站在国人的角度来写，所以应该是个中国人，也许只是个笔名，就像鲁迅之于周树人，估计是为了纪念经济学家凯恩斯。</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>&emsp;&emsp;书中的大多数内容，虽然不是特别深入和系统，但是从横向进行了相对详细的说明和对比，对于基础知识和入门者的理解还是特别有帮助的，接下来列一些自己印象颇深的点。</p><ol><li>关于保险公司，自己过去一直以为保险公司赚钱的主要途径是“承保盈利”，即吸收客户缴纳的保费收入减去发生保险事故后对客户的赔付的支出，如果保险公司自始至终保费收入大于赔付支出，则差额即为承保盈利；但书中描述说全世界的保险公司很少通过承保盈利，而是基于客户的保费进行再投资来获得盈利。</li><li>关于保险公司，以前在想自己投保后保险公司倒闭怎么办，书中描述保险公司倒闭概率非常低，原因在于国家对保险公司的监管严格，同时有再保险公司可以为保险公司提供保险服务。</li><li>关于贴现，以前记不住贴现里面的名称，书中通过跟贷款进行对比自己就理解了。票据贴现是指持票人拿着未到期票据卖给商业银行，申请提前拿钱一边取得现金，并支付或少提取现在到票据到期时间之间的利息；而转贴现是商业银行之间的贴现或资金拆借，即一个商业银行将票据转让给其它商业银行；再贴现是商业银行向人民银行的贴现，即中央银行作为最后付款人。</li><li>关于挤兑，之前只是从感性上知道银行一旦发生同时大量提款就会发生兑付，导致银行倒闭，没想过为什么，在阅读过程中意识到，商业银行赚钱的主要方式就是存贷利差，即贷款收取的利率减去存款付出的利率，而如果大家都去把存款取出则其将没有钱可以用于放贷，由于存在已经带出去还没到期的钱，加上一定的存款准备金则一定无法全部满足储户提款。</li><li>关于金融财团，书中描述了几个大的国际金融巨头的故事，比小说还精彩，比如洛克菲勒、罗斯柴尔德等。</li><li>关于汇率，本身没什么特别难的知识，只是跟自己之前学习相比，感觉书中对汇率的陈述非常通俗易懂，比如我国的汇率是直接标价方式，即一单位外币对应的人名币来表示，因此汇率提高表示人民币相对数值增加，即人民币贬值或外币升值；前些年的大量贸易顺差导致的人名币升值压力，以及升值对国内国际的影响等等，描述的通俗易懂。</li></ol><center><img src="/img/books/从零开始读懂金融学.jpg" width="150" height="200" title="从零开始读懂金融学"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融学 </tag>
            
            <tag> 经济学 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《穷查理宝典》</title>
      <link href="/2019/05/04/books/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/"/>
      <url>/2019/05/04/books/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>作者：孤独不苦<br>已取得发表授权</p><ol><li>保持诚实，因为从长远来看，撒谎的成本更高，撒一个谎需要一百个谎来圆它。</li><li>跨学科学习，所有明文规定的学科分界都不能阻挡求知的心。</li><li>有自己的知识模型，在生活中用它来分析问题，然后不断用更好的迭代升级它，最重要的模型来自硬科学(数学，物理，化学，工程学)，其他的包括经济学，会计学，心理学，生物学等</li><li>关于投资，有两个诀窍：①是找好被标错价的大鱼，然后下重注，长期持有②是比你的对手活的长，复利将点石成金</li><li>不要过深陷入意识形态(包括但不限于宗教和政党)，会影响你的判断力</li><li>过得幸福的诀窍是别碰那些会让你不幸福的东西：嫉妒，怨恨，毒品和酒精，我自己加上的是懒惰和拖延。</li><li>终生阅读，终生学习，因为书可以让你以最低的成本向历史上那些最伟大的人学习。</li><li>在自己的能力圈内做事，但不要忘记通过各种手段(如读书）扩大自己的能力圈</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 孤独不苦 </tag>
            
            <tag> 巴菲特 </tag>
            
            <tag> 查理·芒格 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 做事做人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《跟美国幼儿园老师学早教》</title>
      <link href="/2019/04/29/books/%E8%B7%9F%E7%BE%8E%E5%9B%BD%E5%B9%BC%E5%84%BF%E5%9B%AD%E8%80%81%E5%B8%88%E5%AD%A6%E6%97%A9%E6%95%99/"/>
      <url>/2019/04/29/books/%E8%B7%9F%E7%BE%8E%E5%9B%BD%E5%B9%BC%E5%84%BF%E5%9B%AD%E8%80%81%E5%B8%88%E5%AD%A6%E6%97%A9%E6%95%99/</url>
      
        <content type="html"><![CDATA[<p>作者：Zoe<br>已取得发表授权<br>&emsp;&emsp;红字部分其实我觉得是教育父母的，大家可以看一下，其实我觉得看了那么多的育儿书，我觉得最大的作用是让我在育儿路上不那么焦虑，父母的状态好了，一切都会OK。</p><center><br>    <img src="/img/books/跟美国幼儿园老师学早教1.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教2.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教3.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教4.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教5.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教6.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教7.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教8.jpg" title="跟美国幼儿园老师学早教"><br>    <img src="/img/books/跟美国幼儿园老师学早教9.jpg" title="跟美国幼儿园老师学早教"><br></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美国 </tag>
            
            <tag> 家庭教育 </tag>
            
            <tag> Zoe </tag>
            
            <tag> 幼儿园老师 </tag>
            
            <tag> 早教 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《父母的语言 · 3000万词汇塑造更强大的学习型大脑》</title>
      <link href="/2019/04/25/books/%E7%88%B6%E6%AF%8D%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
      <url>/2019/04/25/books/%E7%88%B6%E6%AF%8D%E7%9A%84%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>作者：Sunshine<br>已取得发表授权</p><center><br>    <img src="/img/books/父母的语言-1.jpg" title="父母的语言"><br>    <img src="/img/books/父母的语言-2.jpg" title="父母的语言"><br>    <img src="/img/books/父母的语言-3.jpg" title="父母的语言"><br>    <img src="/img/books/父母的语言-4.jpg" title="父母的语言"><br>    <img src="/img/books/父母的语言-5.jpg" title="父母的语言"><br></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sunshine </tag>
            
            <tag> 学习型大脑 </tag>
            
            <tag> 家庭教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《非暴力沟通》</title>
      <link href="/2019/04/25/books/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/"/>
      <url>/2019/04/25/books/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p>作者：锦书致南终<br>已取得发表授权</p><p>《非暴力沟通》 既表达自己又沟通他人<br>可以很清晰地表达出自己的愤怒，但是不会用语言轻易地伤害别人，因为伤害别人并无助于解决问题<br>不带评论的观察是人类智力的最高形式</p><h1 id="第一步：事实"><a href="#第一步：事实" class="headerlink" title="第一步：事实"></a>第一步：事实</h1><p>学会区分观察和评论，讲事实！<br>孔子讲的君子不器</p><h1 id="第二步：感受"><a href="#第二步：感受" class="headerlink" title="第二步：感受"></a>第二步：感受</h1><p> 讲出感受<br>人生的三个阶段：情绪的奴隶、<br>面目可憎（自己想做什么就去做，别人和我无关，会得罪很多人）<br>生活的主人（孔子的中庸之道）表现：乐于助人心中充满爱，帮助别人是出于爱，并不是出于恐惧内疚和惭愧，损人无法利己</p><h1 id="第三步：需求"><a href="#第三步：需求" class="headerlink" title="第三步：需求"></a>第三步：需求</h1><p>感受的根源来自自己的需求，所以盯着自己的需求，关键词“我想要…”一定是需求没有得到满足<br>“一个人只要生气，一定是某种需求没有得到满足”</p><h1 id="第四步：请求帮助"><a href="#第四步：请求帮助" class="headerlink" title="第四步：请求帮助"></a>第四步：请求帮助</h1><p>希望对方怎么做的方法请求帮助，真的想要怎么做说出来，“要什么而不是不要什么很重要”<br>  明确谈话目的，并且在提出要求以后，请求对方而不是命令对方反馈，因为没有一个人有资格命令别人，“你以后对我好点”×<br>“我希望你以后对我好点”×<br>“我希望你以后可以多给我点零花钱”√记得＋具体的需求！！！<br>在这个过程中，学会倾听，千万不要让对方停下来，或者打断对方，“建议、比较、说教、安慰、回忆、否定、同情、询问、辩证、纠正”都无助于体会对方的情境，但是在沟通中最重要的就是体会对方的感受“我能够理解你现在的感受，真的很难过………”<br>当你能够准确表达出对方的感受，他的情绪会大幅度好转。<br>当你很生气地时候，把自己的需求讲出来，这样才有可能帮助对方解决问题。<br>痛苦是来自于我们的需求没有得到满足。<br>表达愤怒的方法：要盯着自己的需求，而不是盯着情绪。<br>表达感激三步骤：①对方做了什么使我们的生活得到改善②我们的哪些需求得到满足③现在的心情是怎么样</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锦书致南终 </tag>
            
            <tag> 非暴力 </tag>
            
            <tag> 事实 </tag>
            
            <tag> 感受 </tag>
            
            <tag> 需求 </tag>
            
            <tag> 请求帮助 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git版本管理工具，最简使用说明</title>
      <link href="/2019/04/25/tech/git/"/>
      <url>/2019/04/25/tech/git/</url>
      
        <content type="html"><![CDATA[<h1 id="代码库关系"><a href="#代码库关系" class="headerlink" title="代码库关系"></a>代码库关系</h1><p> <center><br>    <img src="/img/tech/20190425183119.png" title="git版本库关系"><br>    </center></p><h1 id="最简命令"><a href="#最简命令" class="headerlink" title="最简命令"></a>最简命令</h1><ol><li>git add .</li><li>git commit -m 修改说明</li><li>git pull </li><li>git push origin dev<h1 id="一般使用流程"><a href="#一般使用流程" class="headerlink" title="一般使用流程"></a>一般使用流程</h1></li><li>提交到本地代码库</li><li>从线上代码库拉取别人的代码<br>2.1 解决冲突（如有）<br>2.2. 提交到本地代码库</li><li>提交到线上代码库</li></ol><hr><h2 id="1-提交到本地代码库"><a href="#1-提交到本地代码库" class="headerlink" title="1. 提交到本地代码库"></a>1. 提交到本地代码库</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> git add 文件名或(.)表示所有文件</span><br><span class="line"><span class="number">2.</span> git commit -m <span class="string">"提交说明"</span></span><br></pre></td></tr></table></figure><h2 id="2-从线上代码库拉取别人的代码"><a href="#2-从线上代码库拉取别人的代码" class="headerlink" title="2. 从线上代码库拉取别人的代码"></a>2. 从线上代码库拉取别人的代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="2-1-解决冲突"><a href="#2-1-解决冲突" class="headerlink" title="2.1 解决冲突"></a>2.1 解决冲突</h3><p>&emsp;&emsp;修改代码中冲突的内容，解决冲突就是将自己跟别人同时修改的部分代码合并了。工具会通过HEAD结构将自己的部分和别人的部分区分开来，其中AAAAAAAAA是自己刚提交的版本，BBBBBBB为远程服务器上的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;HEAD</span><br><span class="line">AAAAAAAAAAAAAAA</span><br><span class="line">========</span><br><span class="line">BBBBBBBBBBBBBBB</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;id</span><br></pre></td></tr></table></figure></p><h3 id="2-2-提交到本地代码库"><a href="#2-2-提交到本地代码库" class="headerlink" title="2.2 提交到本地代码库"></a>2.2 提交到本地代码库</h3><p>同1</p><h2 id="3-提交到线上代码库"><a href="#3-提交到线上代码库" class="headerlink" title="3. 提交到线上代码库"></a>3. 提交到线上代码库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本管理 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《分手男女》</title>
      <link href="/2019/04/23/life/movice-fsnv/"/>
      <url>/2019/04/23/life/movice-fsnv/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这是一部2006年上映的老片了，这次回看表现现在的生活上依旧上没觉得过时，仍然可以抓住我的眼睛，让我耐心的看完整部电影，而且看完后依旧觉得这就是真实生活，一方面是电影本身的表达能力厉害，即使现在的影视效果发展很多了，对依然可以基于之前的技术占有一席之地；另一方面，也许只要有人的地方就会有电影中的情景，因此类似描述日常关系的故事永远也不会过时，最多只是随着技术的发展，视觉表现力、情绪感染力以及立意创新度等方面进行升华。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;电影女主是大名鼎鼎的詹妮弗·安妮斯顿，可能有人会不熟悉这个名字，但说到老友记里的瑞秋应该很多人都知道了。电影中男女两人因为生活中相互的不理解，两人各自都站在自己的立场为感情为家庭付出，都不认为自己有错，而是更多的看到自己付出和对方缺点，最终在跟朋友的一次家庭聚会结束后，因为洗碗的事情成为导火索，产生了分歧最终选择分手。<br>&emsp;&emsp;分手后，双方各自沉浸在自己的世界里，各自做一些事情来引起对方的注意，或者发泄自己心中的不快，经过两人几次的相互折磨后，双方将房子卖了，最终双方也都开始尝试去理解对方，在分手后的一段时间后双方的一次偶遇，让双方都看到了对方的成长，对他们也许是新的开始。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;本电影给自己最大的震撼还是在文化的不同，在电影中多处都有体现，一方面体现的是个人对自由的追求，另一方面其他人之间对自由的尊重，两个例子电影中的片段可以说明：</p><ol><li>第一是篇头男主对女主的示好，尽管有时觉得会比较烦人但其勇气是值得肯定的，在得知女士跟自己女朋友一起过来看比赛的情况下，依旧对其表示友好和爱慕，台词简单粗暴从第一面像似就谈到了永久性的选择及未来结婚的话题，如果相同的情景发生的国内，一方面女孩子根本不会搭理他，另一方面女孩子男朋友估计是会过来示威的，当然在国内出现这样情况的概率也比较低，因为一旦发现别人有女朋友或男朋友，通常就不会有幻想或者再进一步动作。这个跟道德或者性格无关，只是文化观念所致。</li><li>男女主一起筹钱付了首付也住在了一起，因为生活中的一地鸡毛发生了矛盾，女方选择分手后两人依旧住在一起，只是女主睡卧室，男主睡沙发，一方依旧敢于将裸体示于另一方，而另一方也不觉得有何不妥；一方可以邀请自己的新男友来家里做客，另一方也表示尊重和接受，就好像两人是合租在这间房一样，这样的事情本身应该很难发生在国内，或者国内很难接受这样的行为。一方面如果分手也许都不会在一起多待一天，肯定会有一方立马从房间搬走，另一方面，即使迫于条件限制两人依旧在同一屋檐，两人也可能会继续吵闹升级矛盾，而不会这么平淡的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剧情片 </tag>
            
            <tag> 家庭剧 </tag>
            
            <tag> 文化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《菊与刀》</title>
      <link href="/2019/04/16/books/%E8%8F%8A%E4%B8%8E%E5%88%80/"/>
      <url>/2019/04/16/books/%E8%8F%8A%E4%B8%8E%E5%88%80/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这是一本上世纪50年代出版的一本，由美国人写来介绍日本文化的书，很多事情当局者迷，也许只有站在旁观者的角度才能看到事情的全貌，或者说跳出环境以观察者的角色，来通过对自己观察到的现象跟自己理解的矛盾进行碰撞，才能更好的理解一些日本人自身无法察觉或者日本人理所当然接受但其他文化却不可理解的价值观。<br>&emsp;&emsp;现在的日本已经跟那时候应该有很大不同，但其一些关于文化的传承应该还是保持着，就像现在我们的很多观念跟新中国刚成立时候已经有非常大的变化，但很多历史文化的东西也有保留和继承。即使不论现在的日本是一种什么样的状态，只是以那时候来了解日本文化，也是有挺多的借鉴意义。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;自己最大的收货是产生了对文化的敬畏，在读这本书之前，一直都不是特别理解“文化的差别”这个事情，直到看了这本书才感受到较大的冲击。以前一直以为，只要最底层的价值观是一致的，具体各种文化的不同仅仅表现在，如何理解一件事情或只是表达的不同而已；但是，事实上，文化的差异不仅仅体现在表现上对一件事情的理解不同，也可能连最底层的价值观也不一致的，才真正体会到文化的强大之处。<br>&emsp;&emsp;比如，以前我一直觉得助人为乐是一种友好的品德，从小被教育扶老奶奶过马路、拾金不昧、要有雷锋精神等等，但也许别的文化里是无法随意接受他人恩惠的，这本书中讲到日本人对于他人给予自己的恩惠会成为自己的一个心里负担，因此大家通常也害怕给别人带来负担，所以不主动去帮助他人，这被称为是值得鼓励的美德，跟自己从小构建的三观完全不一致。</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><p>&emsp;&emsp;整体来讲日本文化跟中国文化有非常多相似的地方，但也有很多不同的点，自己依然会被部分思想和行为所震撼。有几个自己印象比较深的点，或者说跟我们文化差异较大的点：</p><ol><li>关于名誉：日本人看重自己的名誉胜过生命，而名誉的理解又跟我们传统的理解不太一样，《四十七士物语》被称为日本文化的精髓，47位武士为完成自己的主公的使命，不惜将伤害甚至杀害自己的家人、亲朋好友及牺牲自己的生命，最终得到了亲朋好友及全国人的尊重。</li><li>关于家庭：日本人将家庭和生活分的特别清楚，一方面一个家庭中长幼关系明确，即使吃饭洗漱都是有尊卑先后关系的，即使在家里也不太像国内一样有温馨的家庭氛围；另一方面，将性跟爱可以分开来处理，妻子允许丈夫出去找妓女，也帮丈夫做准备和支付订单。</li><li>关于等级：日本特别看重等级观念，不允许发生越级或不尊重上级的事情，也严格的遵守各种制度准则，即使在家庭中也是这样。在家庭中，父亲权利最大，其次母亲，然后才是自己的妻儿，书中描述婚姻完全由父母指定，如果母亲不喜欢儿媳妇，要求儿子离婚，儿子即使不舍得或者爱自己老婆也必须离婚，而只有离婚才能得到大家的认可。</li></ol><center><img src="/img/books/菊与刀.jpg" width="150" height="200" title="菊与刀"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文化 </tag>
            
            <tag> 日本文化 </tag>
            
            <tag> 传统文化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 强化学习</title>
      <link href="/2019/04/12/tech/ml-qhxx/"/>
      <url>/2019/04/12/tech/ml-qhxx/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;强化学习的原理，就是通过结果的反馈来对有效规则进行强化，并弱化无效或者较差的规则的一种学习原理。跟常规的监督学习不同之处在于，在学习器的训练前没有标记样本的结果，而需要通过尝试来得到各行为的结果，进而来对训练本身进行反馈。</p><h1 id="任务与奖赏"><a href="#任务与奖赏" class="headerlink" title="任务与奖赏"></a>任务与奖赏</h1><p>&emsp;&emsp;任务与奖赏是强化学习的一个基础概念，就是基于一个状态下通过执行某个动作（任务）使得状态发生改变，通过对改变后的状态进行对比来决定当前任务的好坏，如果状态变得更好则对任务进行奖赏。</p><h1 id="k-摇臂赌博机"><a href="#k-摇臂赌博机" class="headerlink" title="k-摇臂赌博机"></a>k-摇臂赌博机</h1><p>&emsp;&emsp;K摇臂赌博机是一种由K个摇臂的赌博机，玩家在放入游戏币后可以选择一个摇臂进行操作，而所有摇臂本身有不同的概率来赢得奖励，具体摇臂本身出的奖赏也只是一个概率值并非确定值，玩家需要自己根据尝试的结果来判断概率后，去最大化自己的奖赏。这个规则跟强化学习中的单步任务的模型一致，即在行为中仅考虑单步操作的最大奖赏，常用策略有$\epsilon$贪心算法和Softmax算法。<br>&emsp;&emsp;$epsilon$贪心法是以一定的概率进行随机尝试，即当随机值的大于概率$\epsilon$则在k个摇臂中随机选择一个进行尝试，当随机值小于概率$\epsilon$时选择已尝试的摇臂中最大平均奖励的那个，当k个摇臂的概率分布较宽即不确定性较大时，概率值$\epsilon$需要选择较大值，反之亦然。Softmax算法利用已有的结果中各摇臂奖赏的概率进行摇臂的选择迭代，即如果各摇臂的奖赏概率相当，则选择各摇臂的概率相当，若某个摇臂的奖赏出现次数明显较大，则其被选中的概率也较大。</p><h1 id="有模型学习"><a href="#有模型学习" class="headerlink" title="有模型学习"></a>有模型学习</h1><p>&emsp;&emsp;有模型学习是指在已知一个模型的环境中进行学习。该方法基于一个初始的模型（通常是随机模型），首先进行模型评估（代入模型计算奖励），然后基于最大化奖励的目标对模型参数进行改进，再对改进的模型进行评估，进而再对模型进行改进，不断迭代直到模型收敛或者不再改变为止。</p><h1 id="免模型学习"><a href="#免模型学习" class="headerlink" title="免模型学习"></a>免模型学习</h1><p>&emsp;&emsp;尽管有模型学习的计算比较理想，但现实中环境的的转移概率和奖赏函数往往很难确定，甚至很难直到环境中的状态数，因此常有学习算法不依赖于环境建模，这类学习被称为免模型学习。</p><h1 id="值函数近似"><a href="#值函数近似" class="headerlink" title="值函数近似"></a>值函数近似</h1><p>&emsp;&emsp;前面描述的学习都是基于状态空间有限的情况下，而在有限的状态空间内值函数对应于一个由县委的数组，如果状态空间本身不是有限的，比如本身是连续的，则可以直接对连续状态空间的值函数进行学习，由于本身真实的值函数是未知的，因此对该类问题的求解称为值函数近似。</p><h1 id="模仿学习"><a href="#模仿学习" class="headerlink" title="模仿学习"></a>模仿学习</h1><p>&emsp;&emsp;强化学习的经典任务中，需要对多步决策后的累计奖励结果进行反馈计算，但这种基于累积奖赏对很多步之前的决策进行学习和判断，其计算量和搜索空间比较大，因此引入一种模仿学习的概念，即不止是对最终结果的累积奖赏进行分析，而是在过程中引入参考项进行模仿学习，这样的操作就类似于监督学习了，则可以直接使用其他监督学习的工具。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 反馈 </tag>
            
            <tag> 奖励 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 规则学习</title>
      <link href="/2019/04/12/tech/ml-gzxx/"/>
      <url>/2019/04/12/tech/ml-gzxx/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;规则学习就是指通过样本学习一个明确的规则，用以对待分类样本进行分类，目标是产生一个能覆盖尽可能多的样本的规则集。规则常分为命题规则和一阶规则，命题规则指使用具体原子命题和逻辑关系组合成的简单陈述句，一阶规则是由可以描述属性的原子公式，从描述来看命题规则属于一阶规则的特殊情况。<br>&emsp;&emsp;由于一个样本有多个属性，所以会出现同一个样本被多条规则覆盖，如果发生则常使用投票法、排序法和元规则法进行解决，投票法是选择分类最多的规则数，排序法指预先对规则本身的优先级进行排序，选择优先级最高的规则，元规则法指预先为规则的执行指定一个原则，根据原则来确定规则的选择。</p><h1 id="序贯覆盖"><a href="#序贯覆盖" class="headerlink" title="序贯覆盖"></a>序贯覆盖</h1><p>&emsp;&emsp;序贯覆盖指基于样本集进行规则学习，而每学习得到一条规则，就从样本集中将规则可以覆盖的样本去除，直到所有样本集为空或仅剩一种分类，则所有样本都有规则被覆盖。<br>&emsp;&emsp;规则的学习有自顶向下和自底向上两种思路，自顶向下是先使用一般性的规则描述，然后增加细化描述用来覆盖更具体的分类，这种从大到小的方式具有较强的泛化能力，适合本身具体的命题规则；自底向上策略则相反，是先使用特殊的规则开始，然后不断减少约束条件来增加对样本的覆盖率，适合一半特性的一阶规则。</p><h1 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h1><p>&emsp;&emsp;由序贯覆盖的过程可知这是一个贪心的搜索过程，容易导致局部最优或出现过拟合，类似决策树中的对过拟合的处理，需要增加剪枝。剪枝分为预剪枝和后剪枝，前者指规则学习过程中进行剪枝，后者指规则学习完成后进行剪枝。</p><h1 id="一阶规则学习"><a href="#一阶规则学习" class="headerlink" title="一阶规则学习"></a>一阶规则学习</h1><p>&emsp;&emsp;由于常规的命题逻辑表达能力有限，所以使用一阶逻辑来表示，称为一阶规则学习，即使用更一般的一阶公式代替具体的一维命题进行表达。一阶规则可以表达递归概念即：<br>$更好(X,Y)  \longleftarrow 更好(X,Z) \wedge 更好(Z,Y)$</p><h1 id="归纳逻辑程序设计"><a href="#归纳逻辑程序设计" class="headerlink" title="归纳逻辑程序设计"></a>归纳逻辑程序设计</h1><p>&emsp;&emsp;归纳逻辑程序设计是采用自底向上的规则生成方式，基于一阶规则增加了更复杂的逻辑表达式嵌套和函数，有了更强的表达能力，但也会由于函数的嵌套导致规则有无穷多个，因此为了简化也有一些常用的策略有最小一般泛化和逆归结。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 规则学习 </tag>
            
            <tag> 命题规则 </tag>
            
            <tag> 一阶规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 概率图模型</title>
      <link href="/2019/04/12/tech/ml-gltmx/"/>
      <url>/2019/04/12/tech/ml-gltmx/</url>
      
        <content type="html"><![CDATA[<h1 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h1><p>&emsp;&emsp;隐马尔可夫模型是马尔可夫链的一种形式，马尔可夫链可以理解为一个状态变量受到其他所有状态的条件依赖关系，可以由一个状态代替，而不用去处理较多的状态，如果将状态使用时序表示，可以描述为系统的下一时刻的状态仅有当前时间状态决定，跟之前的状态无关。隐马尔可夫模型的状态值不能直接观察到，但能通过某个状态值推断出对应的观测值，同时而状态之间是一种马尔可夫链关系。<br>&emsp;&emsp;该模型常用语语音识别和自然语言处理，在吴军老师的数学之美中有更简洁易懂的解释。</p><h1 id="马尔可夫随机场"><a href="#马尔可夫随机场" class="headerlink" title="马尔可夫随机场"></a>马尔可夫随机场</h1><p>&emsp;&emsp;马尔可夫随机场包含马尔可夫和随机两个概念，是一种满足马尔可夫性质的随机过程，马尔可夫简单说就是未来只跟现在有关，跟过去历史无关的一种样本状态；随机过程就是一连串随机状态的一种定量关系描述。整体来讲，马尔可夫随机场就是用于描述那些满足马尔可夫性质的随机状态的模型。<br>&emsp;&emsp;全局马尔可夫性是指给定两个变量子集的分离集，则这两个变量子集条件独立；将其细化可以得到局部马尔可夫性和成对马尔可夫性两个推论，局部马尔可夫性指给定比变量的邻接变量，则该变量条件独立于其他变量，成对马尔可夫性指给定所有变量，两个非邻接的变量条件独立。</p><h1 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h1><p>&emsp;&emsp;条件随机场是一种判别式无向图，用于对多个变量在给定观测值后的条件概率进行建模，即对于一组给定随机分布的输入观测值，来建立随机分布的输出状态的条件概率分布模型。<br>&emsp;&emsp;条件随机场跟上面的马尔可夫随机场的本质上一样，区别是马尔可夫随机场考虑的是观测变量之间联合概率，而条件随机场分析的是观测变量到状态的条件概率，换句话说条件随机场可以理解为研究给定随机观测变量条件下，状态随机变量的马尔可夫随机场。</p><h1 id="学习与推断"><a href="#学习与推断" class="headerlink" title="学习与推断"></a>学习与推断</h1><p>&emsp;&emsp;本节主要说概率图模型中对具体分布参数的学习和模型的推断，参数的学习可以使用极大似然估计或最大后验概率估计求解，若将参数视为待推测变量，则参数估计跟推断过程十分接近，可以吸收到推断问题中。常用的推断方法分为精确推断和近似推断两类，精确推断常用有变量消去法和信念传播法。<br>&emsp;&emsp;变量消去法是基于图模型的条件独立性，把多个变量的积的求和问题转化为部分变量交替进行求和和求积问题，实现了对部分变量的消去；信念传播法是基于变量消去法的思想，对各变量进行累计和传播，更好的解决了多个边际分布的重复计算问题。</p><h1 id="近似推断"><a href="#近似推断" class="headerlink" title="近似推断"></a>近似推断</h1><p>&emsp;&emsp;近似推断一般分为随机化采样和确定性近似两类，随机化采样的原理是直接使用样本进行目标期望值的计算，而不用先通过样本计算出概率分布，然后再基于分布计算对应的期望值，其中MCMC采样法是通过构造“平稳分布为p的马尔可夫链”来产生样本。变分推断是使用已知的简单分布来逼近需要推断的复杂分布的一种确定性近似方法。</p><h1 id="话题模型"><a href="#话题模型" class="headerlink" title="话题模型"></a>话题模型</h1><p>&emsp;&emsp;话题模型主要用于处理离散型的数据，基本原理就类似对一篇文章进行话题划分的过程，主要也用于信息检索和自然语言处理领域。先对文章中出现词的词频进行统计，然后将词指派给不同话题，再通过话题来对词进行随机采样，最终可以使用话题来表示文档；或者说，一篇文章中的词是基于一定概率出现在某个话题中，而反过来某个话题也是以一定概率含有某个词。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 图模型 </tag>
            
            <tag> 贝叶斯模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 半监督学习</title>
      <link href="/2019/04/11/tech/ml-bjdxx/"/>
      <url>/2019/04/11/tech/ml-bjdxx/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;半监督学习是指让学习器的训练不仅仅依赖于对训练样本的标记，而是可以利用未标记的样本实现自主学习的一种方式。相对应的常规基于已标记的样本进行模型训练，然后使用训练的结果对待预测数据进行预测的方式称为主动学习。</p><h1 id="生成式方法"><a href="#生成式方法" class="headerlink" title="生成式方法"></a>生成式方法</h1><p>&emsp;&emsp;生成式方法是直接假设所有的样本数据，不论是否进行了标记，都由同一个未知的模型生成，因此可以通过该模型将未标记的数据跟学习目标建立联系，最终使用EM算法（目标和参数相互迭代）求解得到模型，进而可以实现未标记样本的分类。<br>&emsp;&emsp;如上所述，假定数据分布属于某个模型后，记得得到对应模型的的生成式半监督学习模型，常用的有高斯混合模型、混合专家模型及朴素贝叶斯模型等。但是，如果模型的假设不准确，及模型跟样本分布不一致，则可能会出现较差的结果，具体模型的假设通常需要一定的先验知识，或者对样本数据的领域知识。</p><h1 id="半监督支持向量机"><a href="#半监督支持向量机" class="headerlink" title="半监督支持向量机"></a>半监督支持向量机</h1><p>&emsp;&emsp;半监督支持向量机是支持向量机在半监督学习方向的拓展，标准的支持向量机的目标是找到最大间隔划分的超平面，而板件的支持向量机的目标是穿过低数据密度区域的划分超平面，当然，相同点都是针对二分类问题的学习方法。</p><h1 id="图半监督学习"><a href="#图半监督学习" class="headerlink" title="图半监督学习"></a>图半监督学习</h1><p>&emsp;&emsp;对于一个样本数据集，可以映射为一个图，每个样本集可以对应于图中的节点，如果两个样本之间的相似度高或相关性强，则节点之间可以建立一条边，边的强度对应于样本之间的相似度。<br>&emsp;&emsp;该方法有两个缺陷，第一，存储上开销较大，是空间复杂度为$O(m^2)$，因此很难处理大样本集；第二，图的构建过程仅考虑训练样本集，无法判断待测样本，因此有新样板或待测样本时需要重进建图。</p><h1 id="基于分歧的方法"><a href="#基于分歧的方法" class="headerlink" title="基于分歧的方法"></a>基于分歧的方法</h1><p>&emsp;&emsp;前面介绍的方法都是基于单个学习器的，而基于分歧的方法使用多学习器，考虑多学习器之间的分歧的选择，来决定未标记数据的结果，协同训练是常用的基于分歧的方法。<br>&emsp;&emsp;协同训练的原理是，首先选择多个学习器分别基于已标记样本训练得到分类器，然后在未标记样本中选择最大概率的分类作为伪标记，最后将伪标记提供给其他学习器进行训练；持续迭代这种交叉学习，直到所有学习器的结果不再变化，或者学习次数达到某个预定值。</p><h1 id="半监督聚类"><a href="#半监督聚类" class="headerlink" title="半监督聚类"></a>半监督聚类</h1><p>&emsp;&emsp;聚类本身是一种无监督学习方法，不过常规的样本中都有一些监督的信息，因此可以利用这些监督信息来进行半监督聚类学习，常见的监督信息分两类：第一类基于样本之间关系的必连和勿连，必连指样本必属于同一类，勿连指样本必不属于同一类；第二类是存在已标记的样本。<br>&emsp;&emsp;对于第一类监督信息，约束k均值算法是常用的半监督聚类方法，原理是在保持必连和勿连的前提下，寻找距离当前样本最近的类别，直到分类不再变化。对于第二类监督信息，约束种子k均值算法是常用方法，原理是在保持已标记样本所属分类不变的前提下，寻找距离当前样本最近的类别，直到分类不再变化。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《机器学习》</title>
      <link href="/2019/04/11/books/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/04/11/books/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;周志华的这本清华大学出版社出版的机器学习，据说一度在各大电商平台计算机类书籍中排行都在前三，可见现在人工智能的热度以及大家对其未来的预期之高，不论是否能坚持读完或者能否理解部分内容，只要买了书都算是一种上进心吧。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;感觉本书位于专业和科普中间但偏向专业性，书中给出了不少的公式和推导，如果忽略所有的数学公式，本书适合作为机器学习方向的科普读物；但是，书中部分章节又有对公式的部分推导，推导过程部分也没展开，作为专业的图书又相对浅显。因此感觉这本书定位不明确，也许正因为如此，也许相关方面的书实在太少了，让这本书这么盛行。<br>&emsp;&emsp;开始几个章节会比较枯燥，随着阅读深入就会被其内容吸引，自己在看的时候没太关注数学公式，只是去了解每个模块对应的概念和思想，当做读小说里的故事情节。有很多概念之前都听过，所以在书中见到还是挺熟悉，不过，不知道买这么书的人有多少真正看了内容，能否有特别的收获。</p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>&emsp;&emsp;了解了机器学习相关的一些学习方法和基本思路，对于没有从事相关行业的自己来讲，相当于给自己建立了一个标签或者目录，这个也许已经够了，在真正需要的时候能根据自己的认知再去有针对性的深入了解，应该就是俗话说的广泛撒网，重点培养。<br>&emsp;&emsp;自己也在每章扫过一遍后，根据自己的理解简单写了点总结，方便日后回忆和遍历，下面是各模块目录，序言中将章节分为三部分，说第三部分是第二部分是进阶，但其实难度并没有增加，不过还是遵照其分类的笔记如下：</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><ol><li><a href="https://www.zhenxiangsimple.com/2019/03/19/tech-ml-gn/">基础概念</a><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2></li><li><a href="https://www.zhenxiangsimple.com/2019/03/28/tech-ml-jcs/">决策树</a></li><li><a href="https://www.zhenxiangsimple.com/2019/03/29/tech-ml-sjwl/">神经网络</a></li><li><a href="https://www.zhenxiangsimple.com/2019/03/30/tech-ml-zcxlj/">支持向量机（SVM）</a></li><li><a href="https://www.zhenxiangsimple.com/2019/03/30/tech-ml-bysflq/">贝叶斯分类器</a></li><li><a href="https://www.zhenxiangsimple.com/2019/03/30/tech-ml-jcxx/">集成学习</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/02/tech-ml-jl/">聚类</a></li><li><a href="hhttps://www.zhenxiangsimple.com/2019/04/09/tech-ml-jwdlxx/">降维</a><h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2></li><li><a href="https://www.zhenxiangsimple.com/2019/04/09/tech-ml-tzxsxx/">特征选择和稀疏学习</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/11/tech-ml-jsxxll/">计算学习理论</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/11/tech-ml-bjdxx/">半监督学习</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/12/tech-ml-glt/">概率图模型</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/12/tech-ml-gzxx">规则学习</a></li><li><a href="https://www.zhenxiangsimple.com/2019/04/12/tech-ml-qhxx">强化学习</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 数学基础 </tag>
            
            <tag> 理论基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 计算学习理论</title>
      <link href="/2019/04/11/tech/ml-jsxxll/"/>
      <url>/2019/04/11/tech/ml-jsxxll/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本章节以概念介绍为主，计算学习理论为了研究通过“计算”来进行“学习”的理论，即研究机器学习的理论基础，目标是分析学习任务的困难本质，为学习算法提供理论保证，并根据分析结果指导算法的设计。</p><h1 id="PAC学习"><a href="#PAC学习" class="headerlink" title="PAC学习"></a>PAC学习</h1><p>&emsp;&emsp;PAC指概率近似正确（Probably Approximately Correct），是计算学习理论最基本的学习理论，是指以比较大的概率学习得到误差满足预定上限的模型。</p><h2 id="PAC辨识"><a href="#PAC辨识" class="headerlink" title="PAC辨识"></a>PAC辨识</h2><p>&emsp;&emsp;在指定的误差范围内，学习算法可以得到一个映射关系满足误差，则称为该算法PAC辨识，数学表达为：<br>对$0&lt;\epsilon,\delta&lt;1$，若存在学习算法，使得其映射函数h满足：<br>$P(E(h) \le\epsilon) \ge1-\delta$<br>则，称该学习算法，能从映射空间中中PAC辨识该映射关系（概念类C）</p><h2 id="PAC可学习"><a href="#PAC可学习" class="headerlink" title="PAC可学习"></a>PAC可学习</h2><p>&emsp;&emsp;如果任意分布，存在学习算法对某一映射关系能够PAC辨识，则称对该关系PAC可学习。</p><h2 id="PAC学习算法"><a href="#PAC学习算法" class="headerlink" title="PAC学习算法"></a>PAC学习算法</h2><p>&emsp;&emsp;若学习算法使得映射关系为PAC可学习的，切算法的运行时间也是多项式函数$poly(\frac{1}{\epsilon},\frac{1}{\delta},size(x),size(c))$，称映射关系是高效PAC可学习，该算法为PAC学习算法。</p><h2 id="样本复杂度"><a href="#样本复杂度" class="headerlink" title="样本复杂度"></a>样本复杂度</h2><p>&emsp;&emsp;样本数量m，满足算法所需的$m\ge poly(\frac{1}{\epsilon},\frac{1}{\delta},size(x),size(c))$的最小m，称为学习算法的样本复杂度。</p><h1 id="有限假设空间"><a href="#有限假设空间" class="headerlink" title="有限假设空间"></a>有限假设空间</h1><p>&emsp;&emsp;假设空间包含任意目标概念的可能性越大，从中找到某个具体目标概念的难度也越大，如果假设空间有限称为有限假设空间，否则称为无线假设空间。</p><h2 id="可分情形"><a href="#可分情形" class="headerlink" title="可分情形"></a>可分情形</h2><p>&emsp;&emsp;可分情形指目标概念c属于假设空间$H$，对于PAC可学习的有限假设空间，所需的样本数目为：$m\ge \frac{1}{\epsilon}(ln|H|+ln\frac{1}{\delta})$，随着样本数量m的增加，泛化误差收敛到0，收敛速度为$O(\frac{1}{m})$。</p><h2 id="不可分情形"><a href="#不可分情形" class="headerlink" title="不可分情形"></a>不可分情形</h2><p>&emsp;&emsp;相对应情况为目标概念c不属于假设空间H，学习算法无法学习到目标概念c的$\epsilon$接近，但可以在假设空间中找出最小泛化误差的假设，找出对应假设的$\epsilon$接近也可以。</p><h1 id="VC维"><a href="#VC维" class="headerlink" title="VC维"></a>VC维</h1><p>&emsp;&emsp;假设空间的VC维指，样本能被假设空间标记为所有可能时候，对应的样本数量。对二分类问题来讲，若样本数量为m，则假设空间可以将所有样本标记的结果有$2^m$个。</p><h1 id="Rademacher复杂度"><a href="#Rademacher复杂度" class="headerlink" title="Rademacher复杂度"></a>Rademacher复杂度</h1><p>&emsp;&emsp;Rademacher复杂度考虑了一定的数据分布，VC维的泛化误差是分布无关、数据独立的，而基于Rademacher复杂度的泛化误差界是与分布有关的，即其泛化误差界依赖于具体学习问题的数据分布。</p><h1 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h1><p>&emsp;&emsp;算法稳定性在衡量输入发生变化时，输出是否会发生较大变化。稳定性分析不必考虑驾驶空间中所有可能的假设，只需要根据算法自身的稳定性来讨论输出的泛化误差界。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 学习理论 </tag>
            
            <tag> 计算学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 特征选择和稀疏学习</title>
      <link href="/2019/04/09/tech/ml-tzxsxx/"/>
      <url>/2019/04/09/tech/ml-tzxsxx/</url>
      
        <content type="html"><![CDATA[<h1 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h1><p>&emsp;&emsp;特征选择可以理解为降维（<a href="https://www.zhenxiangsimple.com/2019/04/09/tech-ml-jwdlxx/">点击查看文章</a>），就是在样本的众多属性数据中选择部分属性或特征作为学习的数据，常见的特征选择分为过滤式、包裹式和嵌入式三类。一方面可以减轻后期学习的计算量，尽量避免维数灾难问题，另一方面，可以降低学习难度，毕竟维数减少后使用较少的维度更容易找到样本之间的关系。</p><h2 id="1-过滤式选择"><a href="#1-过滤式选择" class="headerlink" title="1.过滤式选择"></a>1.过滤式选择</h2><p>&emsp;&emsp;指先对数据集进行特征选择，然后再训练学习器，而特征选择过程跟训练过程无关，相当于先用特征选择过程对初始样本的特征进行了过滤，然后使用过滤后的样本属性特征进行学习器的训练。常用Relief算法的思想是为样本的各属性计算统计分量，来选择分量值较大即具有较强分类能力的属性。</p><h2 id="2-包裹式选择"><a href="#2-包裹式选择" class="headerlink" title="2.包裹式选择"></a>2.包裹式选择</h2><p>&emsp;&emsp;跟过滤式不同，包裹式选择直接把最终要使用的学习器也作为特征子集的评价标准，也可以理解为，包裹式特征选择的目的就是，为指定的学习器选择最优的特征子集。常见LVM算法的思想是针对一个学习器，选择随机选择一个特征子集跟当前的子集进行比较，如果新选的随机子集的误差更小，或者误差相同情况下特征数少，则用新的特征子集代替初始子集。</p><h2 id="3-嵌入式选择"><a href="#3-嵌入式选择" class="headerlink" title="3.嵌入式选择"></a>3.嵌入式选择</h2><p>&emsp;&emsp;跟前两者不同，嵌入式选择是将特征选择过程和学习器的训练过程融为一体，两者在同一个优化过程中同步完成，即在学习器训练过程中自动进行了特征选择。</p><h1 id="稀疏学习"><a href="#稀疏学习" class="headerlink" title="稀疏学习"></a>稀疏学习</h1><h2 id="稀疏表示与字典学习"><a href="#稀疏表示与字典学习" class="headerlink" title="稀疏表示与字典学习"></a>稀疏表示与字典学习</h2><p>&emsp;&emsp;对于样本数据的属性来讲，如果部分维度的属性值为0，或与当前学习任务无关，则可以在学习器的训练过程将这些属性去除或忽略，最终简化模型，而很多时候某一属性大多数样本为0，也有部分样本有值，因此无法将整个属性全部忽略，则可以通过稀疏矩阵的方式来表达当前属性，成为稀疏表示。另外，通常情况下并不知道哪些属性是可以忽略的，因此需要对样本的属性进行学习，来找到合适的字典，从而实现对样本属性的稀疏表示。<br>&emsp;&emsp;在实际的应用中，稀疏表示和字典学习是同步进行的，因此其实际训练过程可以交替学习，即得到稀疏表示后进行字典学习，并在学习到字典集合后再进行稀疏优化，不断迭代直到达到预设的结束条件，比如字典数减少到预设的数量。</p><h2 id="压缩感知"><a href="#压缩感知" class="headerlink" title="压缩感知"></a>压缩感知</h2><p> &emsp;&emsp;前面稀疏表示是从样本属性自身实际的值进行表示，而压缩感知是在考虑，如何利用样本属性自身具有的稀疏性，从部分观测样本属性中恢复原始样本属性，主要分为<strong>感知测量</strong>和<strong>重构恢复</strong>两个步骤。感知测量是考虑如何对原始属性进行稀疏表示，可以使用傅里叶变换，小波变换及前面的字典学习等；重构恢复是压缩感知的核心，考虑如何基于稀疏表示恢复到原始样本。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 特征选择 </tag>
            
            <tag> 稀疏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 降维与度量学习</title>
      <link href="/2019/04/09/tech/ml-jwdlxx/"/>
      <url>/2019/04/09/tech/ml-jwdlxx/</url>
      
        <content type="html"><![CDATA[<h1 id="k临近学习"><a href="#k临近学习" class="headerlink" title="k临近学习"></a>k临近学习</h1><p>&emsp;&emsp;其原理是，对于给定的待测试样本，基于某种距离找出训练集中与其最靠近的k个训练样本，然后基于这k个邻居的属性来进行计算，使用k个邻居的“均值”作为待测试样本的最终分类值。当前分类方法受距离计算原理影响，可能不同的距离会得到不同的分类结果；也收到k的取值影响，可能也会由于k的范围不同得到不同的分类区间。</p><h1 id="低维嵌入"><a href="#低维嵌入" class="headerlink" title="低维嵌入"></a>低维嵌入</h1><p>&emsp;&emsp;当样本属性有较高维度时，其样本之间距离的计算量会非常大，为了尽可能减少计算量可以使用降维的方法，即将高维的原始样本通过数学变换得到一个低维的空间，同时尽可能保持原来样本之间的关系。可以简单理解成，将高维空间的数据映射或者变换到低维空间，一方面因为部分维度即可体现当前样本的关键分类属性，另一方面维度的变换后更便捷的查看分类信息，常用的有线性变换。</p><p>$X^* = W^TX$</p><h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><p>&emsp;&emsp;常规数学上的主成分分析是对数据的维度进行特征提取，仅获取对样本数据影响较大的几个主要的维度，忽略其他的维度信息。当前小节提到的主成分跟常规的思路一样，做法上可以理解为将所有样本的维度投影到一个超平面上，使得投影结果之间的间距尽可能大，即可以区分原来的样本；同时各样本到超平面的距离尽可能近。</p><h1 id="核化线性降维"><a href="#核化线性降维" class="headerlink" title="核化线性降维"></a>核化线性降维</h1><p>&emsp;&emsp;常规的降维方法是使用线性降维，但很多现实的任务中线性变换不太容易找到，或者丢失的数据信息太多，所以也引入非线性降维，一种常用的方法是，基于核技巧对线性降维方法进行核化。</p><h1 id="流形学习"><a href="#流形学习" class="headerlink" title="流形学习"></a>流形学习</h1><p>&emsp;&emsp;是指那些在局部具有欧氏空间性质，可以使用欧氏距离进行距离计算的样本属性空间，借鉴了拓扑流形概念的降维方法。常用方法有等度量映射和局部线性嵌入，前者是使用近使用邻居节点作为计算节点来计算，并选择所有路径中最短的路径作为两个节点之间的距离；后者也是使用邻居节点进行计算，但后者保留了初始节点之间的线性关系。</p><h1 id="度量学习"><a href="#度量学习" class="headerlink" title="度量学习"></a>度量学习</h1><p>&emsp;&emsp;度量学习的意思是直接以方便距离计算为目标的降维方式，而不是先完成降维之后再进行距离计算，毕竟降维的目标也是方便最终的空间比初始空间的计算性能更好。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《金刚：骷髅岛》</title>
      <link href="/2019/04/03/life/movice-kld/"/>
      <url>/2019/04/03/life/movice-kld/</url>
      
        <content type="html"><![CDATA[<h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;科学家在军队及探险成员的陪同下，去一个小岛（骷髅岛）上进行科学考察，遇到了史前巨兽，整个故事都围绕这群考察团在岛上的奇遇。在岛上，他们遇到的动物体型超大，蚂蚁蜘蛛都比树还要高，有个场景是在森林中遇到一只蜘蛛要吃其中一位成员，蜘蛛的腿比树还要高，身体在树顶之上，当然最终人类通过枪械将蜘蛛带走了。<br>&emsp;&emsp;故事中的金刚是一只巨型猩猩，在岛上维护着动物界的治安和稳定，但人类第一次进入该领域时，飞机的飞行高度都没有超过金刚站起来，看到巨形金刚后人类进行交战损失惨重，军队老大从此决定不惜一切代价要找金刚报仇，殊不知金刚并非恶意攻击者，而其中比较恶意的是一个蜥蜴怪，生性残暴但忌惮金刚，所以常年居于地下，在金刚受到人类攻击后受伤，加上人类使用炸弹对地质的破坏把蜥蜴怪逼了出来，最终人类和金刚合作将蜥蜴怪打死，然后人类离开了小岛，金刚在岛上继续维持生态平衡。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;从情节中想到三个故事：</p><ol><li><strong>傲慢与偏见</strong>：军队老大始终想干掉金刚的过程就像一开始的偏见导致出现误会，每个人都有自己的立场和视角，也许开始只是无意中的误会，最终也会形成不可挽回的损失，也许偏见者本身并不自知，甚至在别人解释和劝解后，也很难扭转原有的偏见。</li><li><strong>黑暗森林</strong>：从人类遇见金刚后没了解情况直接进行了攻击，三体中讲过一个黑暗森林的比喻，就是在一个黑暗的森林中，猎人如果知道对面有别的猎人，其第一反应和最安全的做法就是开枪，把另一方干掉，或者先开一枪。即使对方没有恶意，也要先下手为强。</li><li><strong>生存不是儿戏</strong>：对于蜥蜴怪来讲，吃其它动物并非只是凶残，这只是它生存必须方式，就像原始草原上的狮子老虎；而对于金刚来讲，限制蜥蜴怪出没，也是对蜥蜴进行限制，当然即使没有金刚的帮助也会达成另一个平衡，只是动物的种类不同而已。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 动作片 </tag>
            
            <tag> 剧情片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 聚类</title>
      <link href="/2019/04/02/tech/ml-jl/"/>
      <url>/2019/04/02/tech/ml-jl/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;聚类通常目标是将样本分为几个同的类别，而分类前的样本数据本身通常并没有对应的类别，也称为无监督学习，或者说样本是在聚类后才知道了哪些样本属于一类，而被分好的类别名称是需要用户根据其特征来命名，在分类前是不知道的。</p><h1 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h1><p>&emsp;&emsp;对聚类后的结果进行有效性评估的一种度量方法，通常希望聚类后的样本在类内部相似度高，在不同类之间相似度低，常用的衡量指标有两种：</p><h2 id="外部指标"><a href="#外部指标" class="headerlink" title="外部指标"></a>外部指标</h2><p>&emsp;&emsp;外表指标指，将聚类结果跟另一个参考模型进行比较，常用的评价指标有：</p><ol><li>Jaccard系数（JC：Jaccard Coefficient）</li><li>FM指数（FMI：Fowlkes and Mallows Index）</li><li>Rand指数（RI：Rand Index）<h2 id="内部指标"><a href="#内部指标" class="headerlink" title="内部指标"></a>内部指标</h2>&emsp;&emsp;内部指标指，直接基于聚类结果进行性能的评估，常用的评估指标有：</li><li>DB指数（DBI：Davies-Bouldin Index）</li><li>Dunn指数（DI：Dunn Index）<h1 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h1><h2 id="有序属性"><a href="#有序属性" class="headerlink" title="有序属性"></a>有序属性</h2>&emsp;&emsp;对于有序属性的样本之间距离的计算，常用的有：</li><li>闵可夫斯基距离：$dist_{mk}(x_i,x_j)=(\sum_{u=1}^{n}|x_{iu}-x_{ju}|^p)^{\frac{1}{p}}$</li><li>欧氏距离（p=2）：$dist_{ed}(x_i,x_j)=||x_i-x_j||^2=\sqrt{\sum_{u=1}^{n}|x_{iu}-x_{ju}|^2}$</li><li>曼哈顿距离（p=1）：$dist_{man}(x_i,x_j)=||x_i-x_j||=\sum_{u=1}^{n}|x_{iu}-x_{ju}|$<h2 id="无序属性"><a href="#无序属性" class="headerlink" title="无序属性"></a>无序属性</h2>$VDM_p(a,b) = \sum_{i=1}^{k}|\frac{m_{u,a,i}}{m_{u,a}}-\frac{m_{u,b,i}}{m_{u,b}}|^p$<h1 id="原型聚类"><a href="#原型聚类" class="headerlink" title="原型聚类"></a>原型聚类</h1>&emsp;&emsp;原型聚类顾名思义就是基于某个原型进行聚类的方法，根据不同的原型有不同的聚类算法，常用的原型算法如下：<h2 id="k均值算法"><a href="#k均值算法" class="headerlink" title="k均值算法"></a>k均值算法</h2>&emsp;&emsp;核心原理就是不断求各样本到当前各类别之间的距离，每个样本选择距离最近的类别，每次所有样本分类结束后重新求得各类别的中心位置，再继续迭代，直到所有样本分类不再变化。<br>$E=\sum_{i=1}^{k}\sum_{x\in{C_i}}||x-u_i||^2$<h2 id="学习向量量化"><a href="#学习向量量化" class="headerlink" title="学习向量量化"></a>学习向量量化</h2>&emsp;&emsp;核心原理跟k均值算法类似，区别仅在与对每个类别的调整方式，k均值是对所有样本计算结束后对所有样本求均值，而学习向量是根据每个样本计算完成后立即调整类别的中心位置，将样本归类的类别向当前样本靠近，其他所有类别远离当前样本。<h2 id="高斯混合聚类"><a href="#高斯混合聚类" class="headerlink" title="高斯混合聚类"></a>高斯混合聚类</h2>&emsp;&emsp;核心原理跟k均值算法一致，区别在于其距离的计算不是使用欧氏距离，而是使用概率模型，认为样本服从高斯分布，从而使用对应的高斯分布对各样本计算，每次计算万所有样本后根据所有样本的计算结果求得新的高斯分布函数，直到达到计算次数或偏差达到阈值内。其中$u_i,\Sigma_i,\alpha_i$分别表示第i个高斯分类的均值、协方差矩阵和权重。<br>$P(x)=\sum_{i=1}^k\alpha_ip(x|u_i,\Sigma_i)$</li></ol><h1 id="密度聚类"><a href="#密度聚类" class="headerlink" title="密度聚类"></a>密度聚类</h1><p>顾名思义就是基于样本的分布密度来进行分类，其聚类原理是从样本的密度来判别样本之间的关系，从而确定分类类别，最终不断聚类得到最终的聚类结果。其实现过程即为，先设定一些最小密度和分类最大距离阈值，找到满足阈值条件的一个样本作为核心，根据核心样本筛出当前分类，然后从剩下样本中继续寻找，直到将样本分类完。</p><h1 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h1><p>&emsp;&emsp;核心原理就是将样本分类为不同层次的数据，形成类似树形的结构，常用自底向上或者自顶向下两种方式，前者是先对所有样本进行初步分类，不断合并小的分类形成更大的分类，直到达到预定的分类个数，AGNES即为自底向上分类的一种聚类算法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
            <tag> 无监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学日常 之 做个好人</title>
      <link href="/2019/04/02/life/life-%E4%BF%8A%E5%81%9A%E4%B8%AA%E5%A5%BD%E4%BA%BA/"/>
      <url>/2019/04/02/life/life-%E4%BF%8A%E5%81%9A%E4%B8%AA%E5%A5%BD%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;文明礼仪是中华民族的传统美德，人无礼而不生，事无礼则不成，构建和谐文明校园，是学院每位师生的共同愿望。但在我们的校园中，仍然存在许多不文明行为现象：将饮食品带入教室、在教室产生的垃圾无人带走、公共场所吸烟、烟头随地丢、垃圾随地扔、缺乏环保意识、宿舍卫生差、食堂用餐离开后残羹留桌、谈恋爱中不文明行为等，各式各样，给周围带来诸多困扰。<br>&emsp;&emsp;为此，我们要加强自身文明道德修养，文明礼仪不仅是个人素质、教养的体现，也是个人道德和社会公德的体现，更是城市的素养、更是国家的脸面。所以，我们作为具有五千年文明史的“礼仪之邦”，就更应该用文明的行为举止，合理的礼仪来待人接客。这也是弘扬民族文化、展示民族精神的重要途径。<br>&emsp;&emsp;作为大学生，我们要树立节约意识、要注意言行举止、要学会谦虚礼让、要懂得树立诚信、要提高主动意识，坚持做到：讲究卫生自觉打扫、文明用语不说脏话、尊敬师长尊重同学、仪表端庄注重场所、举止得体注意礼仪、爱护公物不搞破坏、勤俭节约杜绝浪费、诚实守信遵规守纪等。<br>&emsp;&emsp;文明一词从小就灌输了给我们每一个人，但现在回想一下我们是否都做到了呢？其实不然，我们或多或少有时都会忽略了他，其中就包括了礼仪。有礼走遍天下，无礼寸步难行。对于我们即将步入社会的学生而言，礼仪是工作中必不可少的一门学问，或者说是一门技能。大学里就有专门的课程来去学习，由此可以看出其的重要性，这也是我们不能忽视的一部分。想想要是我们都注重礼仪，可能社会上就不会再有像菜市场那样的叫骂声，人人都会温声细语待人和谐；可能就不会因为一点小事而大打出手；可能就不会再有家族矛盾的冲突。<br>&emsp;&emsp;讲好文明用语，首先应有个好心情。有人说好心情是可以互相感染的，你有一个好心情，给司机一句问候，一个微笑，一定会把好心情传递给司机。当然，在实际生活中一定没有这么容易，保持一天的心情，面带微笑也是不可能的，这样就要求要有持之以恒的精神，尽力做到从身边做起，做一个文明人，心中牢记文明礼貌，将文明传递下去。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿俊 </tag>
            
            <tag> 所见所思 </tag>
            
            <tag> 大学生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《都挺好》</title>
      <link href="/2019/04/01/life/movice-dth/"/>
      <url>/2019/04/01/life/movice-dth/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;上个礼拜《都挺好》结尾播出了，看的一堆感慨，被苏大强实力圈粉，从最开始的各种作，各种自我放飞到最后几集忽然回归常人思路，尽管他自己最后也得了老年痴呆，但好在儿女孝顺，最终一家人选择了和解，最终家和万事兴的结局，映衬了标题“都挺好”。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;自己好像有快10年时间没看过一部完整的电视剧了，上次应该是大学时候看越狱和纸牌屋。今天要说的这部电视剧是家里人多次强烈推荐下看的，被认为跟剧情中的老大苏明哲有很多共通之处，看完之后感觉确实有不不少相似的特点。其实，回想剧中人物，每个人开始都个性鲜明，只是为了政治正确，最后都向好的方向发展了。<br>&emsp;&emsp;整体看，不是特别理解剧情火起来的理由，难道是因为苏大强太招人恨？剧中每个人人设特点明确，爸爸苏大强自私自卑，妈妈赵美兰强势，老大苏明哲愚孝好面，老二苏明成娇惯自尊，老三苏明玉独立好强。尽管开始老二老三由于家庭地位问题积怨很深，但是，由于血浓于水最后相互和解，其乐融融。整部剧开始一大半时间在烘托矛盾，后半部分把老二的所有积累全部归零，从零开始后一家人忽然关系缓解，尽管部分细节过渡的有点生硬，但整体来说故事还算圆满。或者说，矛盾点是老二从家里得到了过多的利益，通过将老二所有利益全部归零把矛盾解决掉，老三帮老二一把后矛盾关系转为亲情，从而化解矛盾后都挺好了。<br>&emsp;&emsp;最开始看的时候，就能预想到最终结果肯定是一家团聚，毕竟标题是“都挺好”。剧中老蒙装病及好几个故事感觉就是为了拖沓而讲个故事，编剧为了凑字数，也是一开始就猜到了结果。另外，其实开始时候并不想让苏明玉原谅，认为如果最终团圆了，编剧就是在鬼扯，但到最后大团圆时候还是觉得温馨。</p><h1 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h1><p>&emsp;&emsp;最近关于老爸苏大强的各种表情包风靡朋友圈，将其不讲理或者作的影视形象做成漫画，并加上一些文字进行自己产品或者理念的宣传，蛮有意思。不论编剧还是演员自身，剧中纵然有很多细节不合理的地方，但整体来讲不妨碍剧情的完整和人物的塑造。不论是整部剧，还是其中一个人物形象被广泛传播，不论是形象漫画还是人物金句，都算是一部剧的成功，甚至该剧都上了《经济学人》，得到了外媒的关注。</p><center><img src="/img/life/20190401135911216.png" width="150" height="150" title="苏大强"><img src="/img/life/20190401140358988.png" width="150" height="150" title="苏大强"><img src="/img/life/20190401140406187.png" width="150" height="150" title="苏大强"><img src="/img/life/20190401140412465.png" width="150" height="150" title="苏大强"></center><p>&emsp;&emsp;很多人说老二特别过分，整部剧中没什么出彩的地方，或者说是家庭中最好不需要的角色。其实我觉得，他才是剧情的矛盾核心，少了之后故事就不成立了，好在剧中老二有较强的自尊心，依旧孺子可教。而且，老二这样的性格特点，其实每个家庭中都有，甚至每个人身上都有这种特点，只是表现出来的轻重程度不一样。简单说，就是一种对他人的帮助心安理得，剧中将老二设置为现流行的妈宝男，不过走出家庭，在社会上，这样的人其实并不少见，其实这算人的本性。也许，抬头看看身边，或者低头看看自己随处可见。</p><p>&emsp;&emsp;也很多人说老大过于愚忠，对老爸过于迁就。大多数人都有顺杆往上爬的意思，尤其对于一个被老婆压抑了一辈子的人，一下子放飞之后无理取闹起来也是反差太大。但是，其实《菊与刀》这本书在描述了日本文化的一些研究，日本文化中对自己父母长辈的遵从跟这个比有过之而无不及，哪怕父母是错误的，也一定要服从。其中有个日本电影，一男子为了救一姑娘跟别人凑了一大笔钱，但钱被自己母亲偷了，他在知道后独自承担这笔费用，并没有责怪母亲，结果自己老婆带着自己儿子投河自尽了，可是，剧情中事情被大家知道后，没人因此怪罪母亲；同时，观看电影的日本观众也不认为应该怪罪母亲。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家庭剧 </tag>
            
            <tag> 电视剧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 贝叶斯分类器</title>
      <link href="/2019/03/30/tech/ml-bysflq/"/>
      <url>/2019/03/30/tech/ml-bysflq/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;贝叶斯分类器是一类基于贝叶斯公式的分类算法的总称，它不是指某一个具体算法，基于贝叶斯订立的这些分类算法可以统称为贝叶斯分类。</p><h1 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h1><p>&emsp;&emsp;可以理解为高中数学中的条件概率公式：<br>$P(A|B) = \frac{P(B|A) P(A)}{P(B)}$</p><h1 id="贝叶斯决策论"><a href="#贝叶斯决策论" class="headerlink" title="贝叶斯决策论"></a>贝叶斯决策论</h1><p>&emsp;&emsp;从名称就可以知道，这是使用贝叶斯定理进行决策的一种方法论，简单说是在概率框架下进行的决策分类方法。使用的最优的分类器可以表示为：</p><p>$h(x)=argmax_{c\in{y}}P(c|x)=argmax_{c\in{y}}\frac{P(x|c)P(c)}{P(x)}$</p><h1 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h1><p>&emsp;&emsp;似然估计是一个比较常用的统计学参数估计的方法，用于解决当一件事情发生后，描述其发生的概率有多大的问题；算法本身是基于一个已知样本的概率分布函数，但不确定分布函数参数的样本，进行测试计算后得到分布函数的参数值。</p><h1 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h1><p>&emsp;&emsp;对样本增加一个假设：样本的所有属性条件之间相互独立，即每个属性独立的对样本的分类结果产生影响，因此可以得到如下的关系：</p><p>$P(x|c)=\prod_{i=1}^{d}P(x_i|c)$</p><p>因此，最终的分类器可以表示如下：</p><p>$h(x)=argmax_{c\in{y}}\frac{P(c)}{P(x)}\prod_{i=1}^{d}P(x_i|c)$</p><p>其中，$P(c)=\frac{|D_c|}{|D|},P(x_i|c)=\frac{|D_{c,x_i}|}{|D_c|}$，若$P(x_i|c)$中有一项为0，即某一个属性值在训练集中没有出现过，则会导致整个分类器的结果为0，为了解决这个问题，引入了拉普拉斯修正方法，即将$P(c),P(x_i|c)$对应的所有分类样本统一增加所有一个因子如下：</p><p>$P(c)=\frac{|D_c|+1}{|D|+N},P(x_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$</p><p>其中，N表示训练集找那个所有类别数，$N_i$表示第i个属性可能的取值数。</p><h1 id="半朴素贝叶斯分类器"><a href="#半朴素贝叶斯分类器" class="headerlink" title="半朴素贝叶斯分类器"></a>半朴素贝叶斯分类器</h1><p>&emsp;&emsp;由于上面的朴素贝叶斯分类器要求所有属性完全独立，这种情况在实际情况中非常少见，通常一个样本的多样属性之间多多少少都会有一些相关性，因此为部分属性之间的强关系增加一些依赖信息，一方面忽略弱关系可以简化计算，另一方面也保留了最主要的关系。</p><h1 id="贝叶斯网络"><a href="#贝叶斯网络" class="headerlink" title="贝叶斯网络"></a>贝叶斯网络</h1><p>&emsp;&emsp;前面的半朴素贝叶斯分类器只是使用了部分属性之间的强关系，但还是有部分属性之间的关系被忽略了，为了能够将属性之间的关系更具体的描述出来，本算法使用数据结构中的图的概念来描述，图中每个节点由一个属性构成，若两个属性之间有关系，则节点之间就可以连成边。<br>&emsp;&emsp;若不确定网络结构，可以通过类似哈夫曼编码准则来选择一个网络。在确定了网络结构后，就相当于知道了各个属性之间的关系，则贝叶斯网络的学习过程相对简单，只需通过对训练样本进行计数，即可得出每个节点的条件概率表。在贝叶斯网络训练好之后，就可以直接通过已知属性的值精确计算得到待求解属性的值，从而实现分类。</p><h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p>&emsp;&emsp;之前讨论的贝叶斯分类器中的样本属性都是完备的，如果出现某些属性的值为空，则无法直接进行求解，EM算法通过两步交替迭代进行求解，首先根据已有参数$\theta$对未知变量值进行预测求解（Expectation），其次基于已知的观测值的样本进行模型求最大期望值，得到模型参数$\theta$（Maximization），然后使用得到的参数再次进行变量值预测…直至模型收敛。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 贝叶斯 </tag>
            
            <tag> 极大似然估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 集成学习</title>
      <link href="/2019/03/30/tech/ml-jcxx/"/>
      <url>/2019/03/30/tech/ml-jcxx/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;集成学习是指将多个学习器进行集成来完成学习任务，若集成中只包含同类型的学习器称为同质集成，同质集成对应的学习器称为基学习器；若集成使用的学习器不同类型称为异质集成，异质集成对应的个体学习器称为组件学习器。</p><h1 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h1><p>&emsp;&emsp;Boosting是提高单个学习器学习能力的一种方法，其原理是，首先基于训练样本得到一个学习器，然后根据当前学习器的表现对训练样本的分布比例或者训练样本自身的权重进行调整，使得当前学习器中学习错误的样本得到更多关注，基于调整后的样本得到一个新的学习器，直到学习器的数量达到预先设定的值（$T$），最后将所有学习器进行加权结合，表达式如下，其中$\alpha_t$为第t次训练得到的学习器对应的权重，$h_t$为第t次得到的学习器。</p><p>$H(x)=\sum_{t=1}^{T}\alpha_th_t(x)$</p><h1 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h1><p>&emsp;&emsp;Bagging是一种通过放回采样的方法得到不同的训练样本，使用不同训练样本对学习器进行训练，经过多次（$T$次）采样训练，最后对得到的不同学习器进行集成。具体的集成方法可以比较简单，对分类问题可以使用简单投票法，即少数服从多数的原则来选择所有分类器中分类最多的结果，对回归问题可以使用简单平均法，即对所有分类器的计算结果求均值。</p><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>&emsp;&emsp;随机森林是在Bagging的基础上，随机选择训练样本的属性，它是基于Bagging做的一种改进的方法，Bagging只是通过随机选择样本来增加学习器的多样性，而随机森林中学习器的多样性不止来自训练样本的扰动，还有来自属性的扰动。通常来讲，随机森林在学习器数量增加时的泛化能力和收敛速度好于Bagging，但学习器数量较少时其波动也较大，即随机森林的起始性能相对较差，但学习潜力较大。</p><h1 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h1><h2 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h2><p>&emsp;&emsp;由于训练样本不充分或存在噪声，所以加权平均法的权重有时候并不一定更好，通常来讲，如果单个学习器的性能相差较大时使用加权平均法，而相互接近时使用简单平均法。</p><h3 id="简单平均分："><a href="#简单平均分：" class="headerlink" title="简单平均分："></a>简单平均分：</h3><p>$H(x) = \frac{1}{T}\sum_{i=1}^{T}h_i(x)$</p><h3 id="加权平均法："><a href="#加权平均法：" class="headerlink" title="加权平均法："></a>加权平均法：</h3><p>$H(x) = \frac{1}{T}\sum_{i=1}^{T}w_ih_i(x)$</p><p>其中$w_i$是单个学习器$h_i$的权重，通常要求$w_i\ge0,\sum_{i=1}^{T}w_i=1$</p><h2 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h2><h3 id="绝对多数"><a href="#绝对多数" class="headerlink" title="绝对多数"></a>绝对多数</h3><p>&emsp;&emsp;仅选择票数过半的那个学习器的结果。</p><h3 id="相对多数"><a href="#相对多数" class="headerlink" title="相对多数"></a>相对多数</h3><p>&emsp;&emsp;选择票数最多的结果，如果得到多个相同数量的结果，则随机选择其中一个。</p><p>$H(x) = c_{argmax_j}\sum_{i=1}^{T}h_i^j(x)$</p><h3 id="加权投票"><a href="#加权投票" class="headerlink" title="加权投票"></a>加权投票</h3><p>&emsp;&emsp;基于相对多数投票法增加学习器对应的权重，跟加权平均类似，其中$w_i$是单个学习器$h_i$的权重，通常要求$w_i\ge0,\sum_{i=1}^{T}w_i=1$。</p><p>$H(x) = c_{argmax_j}\sum_{i=1}^{T}w_ih_i^j(x)$</p><h2 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h2><p>&emsp;&emsp;前面说的平均和投票，可以理解为一种简单的学习器，如果学习器的结果比较复杂或者学习器输出类型不一致时，也可以通过一个新的不同类型的学习器的来进行结合，即将学习器本身作为要学习和分类的测试样本，通常使用交叉验证法或留一法，留一法是指使用学习器没有使用的测试样本进行测试，交叉验证发是指将测试样本随机分为数量相当的几类，然后分别使用各学习器进行测试验证，最终得到一个新的学习器。</p><h1 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h1><p>&emsp;&emsp;在集成学习的模型中，单个学习器的准确性越高，多样性越大，其集成后的准确性越高。</p><h2 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h2><p>&emsp;&emsp;可以通过对各学习器的分类或回归结果，进行不同的计算规则来表示学习器之间的多样性，常用多样性的度量方式有：</p><ol><li>不和度量</li><li>相关度量</li><li>Q-统计度量</li><li>k-统计度量<h2 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h2>&emsp;&emsp;除了可以衡量学习器的多样性，也有一些方法可以增加学习器的多样性，核心原理是为学习器的学习过程增加扰动，或者说人为增加偏差量，常见增加扰动的地方有：</li><li>数据样本扰动</li><li>输入属性扰动</li><li>输出表示扰动</li><li>算法参数扰动</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 结合策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 支持向量机（SVM）</title>
      <link href="/2019/03/30/tech/ml-zcxlj/"/>
      <url>/2019/03/30/tech/ml-zcxlj/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>&emsp;&emsp;支持向量机是一种，使用线性模型将测试样本一分为二的一种模型，并且两类样本的区别越大越好(间隔越远越好)，通过不同方式的升级，使得模型具有较高的鲁棒性，并可以解决一些非线性分类问题，简单来讲模型的优化过程如下：</p><ol><li><strong>基本型</strong>：当训练样本<font color="green">线性可分</font>时，通过训练样本得到一个支持向量机，使用该模型将样本精确的分为两类</li><li><strong>软间隔</strong>：当训练样本<font color="blue">近似线性可分</font>时，训练样本允许一小部分样本被分类错误，通过损失函数来限定错误率。</li><li><strong>核函数</strong>：当训练样本<font color="red">线性不可分</font>时，使用一个核函数将模型映射到线性可分的空间（通常是更高甚至无限维空间），然后再在目标空间求解得到一个线性支持向量机模型，对样本分类。</li></ol><h1 id="支持向量机（SVM）基本型"><a href="#支持向量机（SVM）基本型" class="headerlink" title="支持向量机（SVM）基本型"></a>支持向量机（SVM）基本型</h1><p>&emsp;&emsp;其基本函数表达如下，对应的示意图如下图：<br>$min_{w,b}(\frac{1}{2}||W||^2)$</p><p>$s.t.  y_i(w^Tx_i + b) \ge0,i=1,2,…,m$</p><center><img src="/img/tech/20190330103728196.png" width="200" height="150" title="SVM基本型示意图"></center><h1 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h1><p>&emsp;&emsp;数学书在求取有约束条件的优化问题时，拉格朗日乘子法和KKT条件是非常重要的两个求取方法，对于等式约束的优化问题，可以应用拉格朗日乘子法去求取最优值；如果含有不等式约束，可以应用KKT条件去求取。<br>&emsp;&emsp;对于上面的支持向量机基本型，进行拉格朗日乘子法和KKT条件的变化，变换后的拉格朗日函数如下：<br>$L(w,b,\alpha) = \frac{1}{2}||W||^2 + \sum_{i=1}^{m}\alpha_i(1-y_i(w^Tx_i+b))$</p><p>令，函数对$w,b$的微分为0，即$\frac{\partial{L}}{\partial{w}}=0,\frac{\partial{L}}{\partial{b}}=0$得到对偶问题：</p><p>$max_\alpha\sum_{i=1}^{m}\alpha_i-\frac{1}{2}\sum_{i=1}^{m}\sum_{j=1}^{m}\alpha_i\alpha_jy_iy_j{x_i}^Tx_j$</p><p>$s.t. \sum_{i=1}^{m}\alpha_iy_i=0,\alpha_i\ge0,i=1,2,…,m$</p><h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p>&emsp;&emsp;将样本空间映射到有线性划分的空间的函数，常用核函数有：</p><ol><li><p>线性核：$k(x_i,x_j)={x_i}^Tx_j$</p></li><li><p>多项式核：$k(x_i,x_j)=({x_i}^Tx_j)^d，d\ge1$为多项式次数</p></li><li><p>高斯核：$k(x_i,x_j)=exp(-\frac{||x_i-x_j||^2}{2\sigma^2}),\sigma&gt;0$为高斯带宽</p></li><li><p>拉普拉斯核：$k(x_i,x_j)=exp(-\frac{||x_i-x_j||}{\sigma}),\sigma&gt;0$</p></li><li><p>Sigmoid核：$k(x_i,x_j)=tanh(\beta{x_i}^Tx_j+\theta)$</p></li></ol><h1 id="软间隔"><a href="#软间隔" class="headerlink" title="软间隔"></a>软间隔</h1><p>&emsp;&emsp;防止过拟合现象，允许少量样本存在被误分类的情况，并引入损失函数，常见的损失函数如下，其对应关系如下图：</p><ol><li>hinge损失函数：$f_{hinge}(z) = max(0,1-z)$</li><li>指数损失函数：$f_{exp}(z) = exp(-z)$</li><li>对数损失函数：$f_{log}(z) = log(1+exp(-z))$ <center><img src="/img/tech/20190330103802640.png" width="200" height="150" title="损失函数关系示意图"></center></li></ol><h1 id="支持向量回归（SVR）"><a href="#支持向量回归（SVR）" class="headerlink" title="支持向量回归（SVR）"></a>支持向量回归（SVR）</h1><p>&emsp;&emsp;将软间隔误差量化为数学表示，当误差小于约值时，认为损失为0，这有一个2倍误差的间隔带。本方法（SVR）跟支持向量机（SVM）是同一原理的分类方式，只是支持向量机的结果是离散的分类结果，比如（0、1），而回归问题相当于计算结果可以是任意的连续值。<br>&emsp;&emsp;另外使用支持向量机的思路进行回归问题的解决，跟传统的回归问题相比的不同在于，传统回归问题，是当计算值和目标值完全相同时才认为损失为0，而当前方法相当于在模型两边存在一个间隔带作为缓冲，若训练样本落入此间隔带内则被认为是预测正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 支持向量机 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 神经网络</title>
      <link href="/2019/03/29/tech/ml-sjwl/"/>
      <url>/2019/03/29/tech/ml-sjwl/</url>
      
        <content type="html"><![CDATA[<hr><p>&emsp;&emsp;不论神经网络的模型是否真的跟生物自身的神经网络相似，也不是特别重要，可以不用太关心，能大概理解它的一个构造思想即可。通常大家不会具体到要去通过代码实现神经网络模型，所以不必太在意其数学公式和具体计算，只需要关心其大概原理，本文就说说相关的一些概念。</p><h1 id="M-P神经元模型"><a href="#M-P神经元模型" class="headerlink" title="M-P神经元模型"></a>M-P神经元模型</h1><p>&emsp;&emsp;基本原理就是将输入样本数据，通过赋予不同权值后，将各项输入值求和得到输出值，通过数学公式简单表示如下，其中$w_{ij}$为神经元$x_i$和$y_j$之间的权重。<br>$y_j=\sum_{i=1}^{k}(x_i\times w_{ij})$</p><h1 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h1><p>&emsp;&emsp;感知机或者叫感知器是只有单层功能神经元的模型，是最简单的一种神经网络模型，相当于从输入直接到输出，没有中间隐含层神经元。</p><h1 id="BP网络"><a href="#BP网络" class="headerlink" title="BP网络"></a>BP网络</h1><p>&emsp;&emsp;英文全称是error Back Propagation，中文意思是误差逆传播，其实顾名思义就是有信息可以从输出传递到输入端，而之前简单的感知机是只有输入到输出的计算。核心包含两部分，一部分是从输入到输出对误差的计算，另一部分从输出到输入对神经元之间权重和自身阈值的迭代，其算法流程如下：</p><hr><p>输入：训练集$D={(x_k,y_k)}_{k=1}^m$，          学习率：$\eta$<br>过程：</p><ol><li>在(0,1)范围内随机初始化网络中所有连接权和阈值</li><li>repeat</li><li>&emsp;&emsp;for all $(x_k,y_k)\in D$  do</li><li>&emsp;&emsp;&emsp;&emsp;根据当前参数，计算当前样本输出$y_k$</li><li>&emsp;&emsp;&emsp;&emsp;计算输出层神经元的梯度项$g_j$</li><li>&emsp;&emsp;&emsp;&emsp;计算隐层神经元的梯度项$e_h$</li><li>&emsp;&emsp;&emsp;&emsp;更新连接权$w_{hj},v_{ih}$和阈值$\theta_j，\gamma_h$</li><li>&emsp;&emsp;end for</li><li>until 达到停止条件</li></ol><p>输出：连接权与阈值确定的多层前馈神经网络</p><hr><h1 id="全局最小"><a href="#全局最小" class="headerlink" title="全局最小"></a>全局最小</h1><p>&emsp;&emsp;对于常规的神经网络模型是使用梯度下降算法进行迭代，但梯度下降可能就会导致达到局部最小值，就好像爬山时候在有多个山头的山脉里，第一次只是先爬到了一个矮的山丘，有一些策略可以跳出局部最优达到全局最优，如下：</p><ol><li>使用多组不同的起始参数值</li><li>一定比例上接受次优解（模拟退火算法）</li><li>对梯度方向加入随机量，即使以及达到了梯度为零，那也因为随机量而还可以继续迭代</li></ol><h1 id="其它网络模型"><a href="#其它网络模型" class="headerlink" title="其它网络模型"></a>其它网络模型</h1><p>&emsp;&emsp;除了BP网络外，还有一些常用的算法如下，具体我也没了解过，供各位自行参考：</p><ol><li>RBF（Radial Basis Function） 径向基函数网络：单隐成前馈神经网络</li><li>ART（Adaptive Resonance Theory）自适应谐振理论网络</li><li>SOM（Self-Organazing Map）自组织映射网络</li><li>级联相关网络（Cascade-Correlation）</li><li>Elman网络</li><li>Boltzmann机</li><li>深度学习：很深层的神经网络</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
            <tag> MP模型 </tag>
            
            <tag> BP网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 决策树</title>
      <link href="/2019/03/28/tech/ml-jcs/"/>
      <url>/2019/03/28/tech/ml-jcs/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;决策树，是使用树形结构进行决策或者判定的一种方法。本文说一下，机器学习中决策树里的一些常用计算规则或数学概念。</p><h1 id="分类方式"><a href="#分类方式" class="headerlink" title="分类方式"></a>分类方式</h1><p>&emsp;&emsp;决策树的分类是基于样品对象的某一个属性值为标准的，如果样品有多个维度的属性，则需要确定以哪些属性作为优先分类的条件，以及如何排序分类的条件，即确定一个分类属性后如何确定后面的属性，甚至如果有的属性值不存在时该如何处理等等。</p><ol><li>信息熵：$Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k$，其中D为测试样本，$p_k$为测试样本中分类为k的比例，$|y|$是样本分类总数。</li><li>信息增益：$Gain(D,a)=Ent(D)-\sum_{v=1}^{V}\frac{|D^v|}{|D|}Ent(D^v)$，其中$a$为测试样本对应的某一个维度的属性，$D^v$为测试样本中属性$a$的值为$v$的样本，|$D^v$|表示$D^v$对应的样本数量。</li><li>增益率：$Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}$，其中$IV(a)=-\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}$</li><li>基尼系数：$Gini(D,a)=1-\sum_{k=1}^{|y|}{p_k}^2$<br>&emsp;&emsp;通过计算每个属性的信息增益，选择增益最大的属性作为优先分类的属性，选择完第一个后，之后的属性维度用同样的方式继续进行计算得到次优属性。</li></ol><h1 id="执行分类"><a href="#执行分类" class="headerlink" title="执行分类"></a>执行分类</h1><h2 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h2><p>&emsp;&emsp;由于生成的决策树过程容易存在过拟合，就是对测试样本的个体属性当作了所有样本的一般属性，因此需要对它进行剪枝（去掉过于细节的模型），以简化学到的决策树。决策树的剪枝，通常提前结束树的子节点生成，或者从已生成的树上剪掉一些节点或子树，从而简化生成的决策树模型。<br>&emsp;&emsp;<strong>预剪枝</strong>：对每个节点进行划分，直到当前节点不能继续增加泛化性能未知<br>&emsp;&emsp;<strong>后剪枝</strong>：先生成一个完成的决策树，然后自底向上计算，如果子树没有增加泛化性能，则使用叶子节点代替子树</p><h2 id="连续值"><a href="#连续值" class="headerlink" title="连续值"></a>连续值</h2><p>&emsp;&emsp;如果测试样本属性为非离散，或者测量值是无规则的数据值，比如物体重量、长度等，则可以使用属性的某个中间值将属性离散化。</p><h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>&emsp;&emsp;如果样本在对应属性上存在缺失，则可以将当前属性等比例分配到存在的属性值中去，比如，若颜色有红色黄色两种，对应样本数量比例为8：2，则如果有当前属性缺失的样本，则将该样本设定为0.8为红色，0.2为黄色。</p><h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>&emsp;&emsp;为每个非叶子节点建立一个线性分类器，而不是仅仅作为一个划分不同方向的单个属性值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 决策树 </tag>
            
            <tag> 分类 </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《名人传》</title>
      <link href="/2019/03/26/books/%E5%90%8D%E4%BA%BA%E4%BC%A0/"/>
      <url>/2019/03/26/books/%E5%90%8D%E4%BA%BA%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;法国罗曼罗兰的一部作品，里面写了贝多芬，米开朗琪罗和托尔斯泰，分为三个部分来分别展示作者看到的三位大师的状态。</p><h1 id="贝多芬"><a href="#贝多芬" class="headerlink" title="贝多芬"></a>贝多芬</h1><p>&emsp;&emsp;贝多芬传的写法，跟传统的名人传记不太一样，不是一味的罗列名人本身一些历史事件，也没有表述名人效应的受人敬仰，只是从旁观者的角度去描述，名人作为一个普通人的生活和思想，顺便展示了贝多芬跟自己一些亲朋好友之间的书信往来，文字间也可以看出贝多芬生活的不幸和乐观。<br>&emsp;&emsp;贝多芬作为音乐大师，创作了不少伟大作品，尤其那几首命运交响曲家喻户晓，至今两百多年依旧俘获人心。伟人的伟大不止是其个人能力的超群，还有其在命运的玩笑下依旧不屈不挠，作为音乐人却因为疾病双耳听觉减弱，到最后完全失聪。尽管听力出现问题时也不敢跟朋友讲，但即使后来失去听觉，仍旧没有像命运低头，进而创作出来很多伟大作品，我们作为普通人也还是要向其这种乐观生活态度学习。</p><h1 id="米开朗琪罗"><a href="#米开朗琪罗" class="headerlink" title="米开朗琪罗"></a>米开朗琪罗</h1><p>&emsp;&emsp;米开朗琪罗在国内的名声没有贝多芬那么响亮，不是因为其对人类的贡献小，我猜测只是因为贝多芬被选入了小学语文课程，课文选材团队欣赏贝多芬的不止是其天才的创作能力，更多是其在多灾多难的条件下体现出的坚韧不拔的品质，或其成就跟自己苦难形成的鲜明的反差，相对而言米开朗琪罗更多可以宣扬的只是天才和智慧的能力，而天赋是不能习得的品质。<br>&emsp;&emsp;书中并没有详细展示或者评论米开朗琪罗的作品的伟大，尽管其伟大之处也在于其作品本身，而是显示一个有血有肉的艺术家，不仅有自己作为大师的能力，也有作为普通人的生活和无奈。书中部分内容通过旁观者的角度，部分以主人公视角来展示其对完美的追求，一方面由于自己性格的软弱而对权威的顺从，从而接下了自己没有精力全部完成的订单；另一方面也有对他人的不信任，很多事情都亲历亲为，甚至自己去采石场选石头做材料并负责将原料运到自己创作的地方。<br>&emsp;&emsp;米开朗琪罗作为艺术大师，受到从普通人、皇室到教皇几乎所有人的尊重和敬仰；也作为普通人，受到自己朋友及家人的敬畏，一方面大家爱护他的天赋，也有人觊觎他的财富，另一方面也不喜欢他对人不屑和古怪的脾气。他有时对权贵不屑，有时也忌惮权贵，不过，对小人物却显得相对大度，经常可以为小人物倾注自己的感情和心血，也许这就是其作为普通人的善良。<br>&emsp;&emsp;</p><h1 id="托尔斯泰"><a href="#托尔斯泰" class="headerlink" title="托尔斯泰"></a>托尔斯泰</h1><center><img src="/img/books/名人传.jpg" width="150" height="200" title="名人传"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贝多芬 </tag>
            
            <tag> 米开朗琪罗 </tag>
            
            <tag> 托尔斯泰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 之 基础概念</title>
      <link href="/2019/03/19/tech/ml-gn/"/>
      <url>/2019/03/19/tech/ml-gn/</url>
      
        <content type="html"><![CDATA[<ul><li>数据集（data set）：一组用于机器学习的数据的集合</li><li>示例（instance）：数据集中的一条数据记录</li><li>特征向量（feature vector）：一个示例在数学上的表示</li><li>训练数据（trainning data）：使用机器学习用来建立模型的数据</li><li>样本空间（sample space）：训练数据中用于作为条件的数据，即预测时的输入值</li><li>标记空间（label space）：训练数据中用于作为结果的数据，即预测时的被预测值</li><li>分类（classification）：被预测值的结果数据是离散数据</li><li>回归（regression）：被预测值是连续数据</li><li>聚类（clustering）：被预测值在训练阶段并没有被明确指定</li><li>训练（training）：使用训练数据对机器学习算法进行训练</li><li>监督学习（supervised learning）：训练阶段有明确的标记数据，即初始状态有为数据做好数据标记，分类和回归都属于监督学习</li><li>无监督学习（unsupervised learning）：跟监督学习相对的概念，聚类属于无监督学习</li><li>泛化（generalization）：使用训练得到一个可用模型的过程，对新的样本数据的适用性好可以理解为模型的泛化能力强，也就是常规理解的归纳，即从各独立的示例中总结出的一般性规律的意思</li><li>特化（specialzation）：将训练出来的模型应用于新样本的过程，就是常规的演绎，即将一般规律应用于具体的独立的示例</li><li>错误率（error rate）：分类错误的样本数占样本总数的比例</li><li>精度（accuracy）：精度 = 1 - 错误率</li><li>训练误差（trainning error）：学习器在训练集上的误差</li><li>泛化误差（generalization error）：学习器在新样板上的误差</li><li>过拟合（overfitting）：把训练样本的自身特点当做所有潜在样本的一般性质进行学习，导致泛化性能下降。</li><li>欠拟合（underfitting）：跟过拟合相对，指对训练样本的一般性质学习的不够</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 基本概念 </tag>
            
            <tag> 训练模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《思考·快与慢》</title>
      <link href="/2019/03/19/books/%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2/"/>
      <url>/2019/03/19/books/%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;这本书阅读是耗时相对久的一本书，开始说两个系统时候觉得想法比较新奇，但到中间说偏见部分感觉有点啰嗦和拖沓，所以到中间时候放下了一段时间，去读了别的小说，在看完小说再回来读剩下几个章节时候，才发现剩下这些对一个人思考方式的细腻把握和多维度切分，很多章节读起来都是不禁叫绝。<br>&emsp;&emsp;本书篇幅相对较长，400多页有40万字，作者在2002年获得了诺贝尔经济学奖，尽管大家都将本书归类于经济学读物（也有行为经济学等），但个人还是觉得属于心理学范畴的内容。本书出版自2012年，算是获奖后的对自己工作的思考的一部著作，尽管不是其获奖的作品，但其中的思想对于认识自己还是有一些帮助，让自己认识到作为人的局限性。</p><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>&emsp;&emsp;本书共有5章38节，5章分别是：1.系统1，系统2；2. 启发法与偏见；3.过度自信与决策错误；4.选择与风险；5.两个自我。主要围绕人在面对各类不同事情时候的状态，来逆向推理其思考过程，作者引入了两个系统的比喻方式来对人思考过程进行量化对比，可以理解成开车时候的不同档位，对于自动挡的车其实也是有个底层的档位变化，只是系统自动根据速度实现了切换，但本身发动机是需要不同档位进行扭合来传动的。<br>&emsp;&emsp;第一章，系统1，系统2，作者首先引入了两个系统，来量化人的思考过程，系统1是凭经验和本能或者叫肌肉记忆来快速给出反应的，而系统2是需要人花费时间和精力进行深度思考的；两种方式在不同的场景下共同发挥各自特长，系统1总是能第一时间给出结论，尽管结论不一定对甚至不合理，系统2尽管思考后可以有相对准确的结果，但系统2消耗资源多所以并非时刻运行；我理解，我们平时的训练就是将系统2需要思考的东西，固话到系统1只需要本能反应。<br>&emsp;&emsp;第二章，启发法与偏见，主要是讲一些日常生活中人们在心理上容易出现的偏见。比如锚定效应，是说在不知觉一个完全不相关的暗示就会对决策产生决定性的影响；比如回归平均值效应，是讲很多事情之间也许不具有因果性，而只是单个事情本身的偶然性突变后回归平均值的结果；比如小数定律和小概率事件对人心里的影响等等。<br>&emsp;&emsp;第三章，过度自信与决策错误，主要在说即使是一个专业素养很高的专家，也会被自己的情绪或者一些偶然因素左右，不一定总是能做到理性和可靠。大多数人忽略环境因素，对自己的判断都是过于自信，而实际上其可重复性并不稳定，因此需要多听听其它人的意见或者先做好最坏的打算，即事情开始前先想失败后的处理方式。<br>&emsp;&emsp;第四章，选择与风险，主要在说一个人的思考方式如何影响其选择的，这一章里的内容将人在思考过程中的一些风险进行细分实验，表达了人的非理性特点，即面对风险和收益的选择是非理性的。之前有篇文章是在读到“能带来长远收益的风险政策”这一小节时写的（<a href="https://www.zhenxiangsimple.com/2019/03/15/life-抛硬币/">从抛硬币的实验中，看到的奋斗人生</a>）。<br>&emsp;&emsp;第五章，两个自我，是将经验自我和记忆自我之间的矛盾，即一个人实际体验到的经历并非完全会被自己记住，而记忆里更多受到峰值效应和结尾效应的作用，即在整个经历过程中的最痛苦/快乐的时间和结束时候自己的感受。因此，而记忆自我更可能被系统1直接用于做决策，所以很多人会因此犯下低级错误。</p><h1 id="喜欢句子摘录"><a href="#喜欢句子摘录" class="headerlink" title="喜欢句子摘录"></a>喜欢句子摘录</h1><ul><li>快慢系统（系统1、2）之间切换轮转，在做复杂问题是不要有其它干扰。</li><li>系统1是直觉的快速感性决定，系统2是思考的懒惰理性的决定：</li><li>眼见不一定为实，不自主忽略不存在的证据，仅集中在当前证据。</li><li>大概率更准确，小样本易出错。</li><li>人们不愿意从普遍的现象中推到出特殊性，如同愿意从特殊现象中归纳出普遍性一样。</li><li>直觉是有迹可循的，其方法是：<ol><li>一个可预测的，有规律可循的环境</li><li>一次通过长期训练学习这些规律的机会</li></ol></li><li>未来是不可预测的：通常是个人的认知错觉或技能错觉，不应该相信高度主观的自信就是准确性的指示器。</li><li>公式比直觉更可靠和稳定。</li><li>选择不是期望值最大化，而是效用值最大，因为边际效用递减，所以选择确定值而非不确定的大概率值。</li><li>回归平均值：自觉性预测易受到下面因素影响<ol><li>小概率事件</li><li>自我感觉</li></ol></li></ul><center><img src="/img/books/思考快与慢.jpg" width="150" height="200" title="思考·快与慢"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 行为经济学 </tag>
            
            <tag> 思考 </tag>
            
            <tag> 非理性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《乔布斯全书》</title>
      <link href="/2019/03/18/books/%E4%B9%94%E5%B8%83%E6%96%AF%E5%85%A8%E4%B9%A6/"/>
      <url>/2019/03/18/books/%E4%B9%94%E5%B8%83%E6%96%AF%E5%85%A8%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;整本书是围绕乔布斯和苹果的交集进行展开的，从乔布斯小时候上学时候开始的小故事，讲到苹果公司的建立和起伏，一直到最后乔布斯在苹果封神归仙。乔老爷刚去世后，传记类书籍风靡一时，那时候就想买来看的，后来各种原因一直没看，时隔8年多看了还是很激动。<br>&emsp;&emsp;说起苹果，回想第一次接触苹果手机已经10多年前了，2008年那时候自己开发过一款基于苹果IOS的APP，那时候都手机还是iphone3G，自己也是见证了苹果从只有个ipod到iphone，然后到ipad，因为自己开发的app，也是跟着这个顺序走的。记得最开始itunes只是支持手机版本，好像是2010年左右开放了PC版后自己的app也针对性做了适配，再后来出了ipad后同步到ipad，想起那时候自己还买苹果的正版系统雪豹，回想自己本科的生活费也要非常感谢乔老爷子。自己在2011年中旬已经不再开发apple的东西，不过，乔老爷也是那年底去世了。</p><h1 id="故事梗概"><a href="#故事梗概" class="headerlink" title="故事梗概"></a>故事梗概</h1><p>&emsp;&emsp;这本书不是传记系列，并没有对人物或者公司有针对性或者全面或者个性化的解读，只是作者从各方资料搜集故事的一个大杂烩，简单说说书中对乔老爷子一些记录。<br>&emsp;&emsp;<strong>出身：</strong> 乔老爷出生时，自己的亲身父母由于家庭原因没法抚养他，但自己亲身妈妈希望他能接受好的教育，所以对领养人也有一定的要求，就是要让他读大学，最终达成一致后，领养了他。<br>&emsp;&emsp;<strong>苹果：</strong> 上学期间，一直都是学校有名的捣蛋鬼，对同学各种恶作剧，但也有自己的爱好和圈子，一起创办苹果的沃兹就是因为对电子的爱好而相识，最开始沃兹的电脑或者叫产品只是一个开发板，被乔布斯成功卖掉后，逐步对电脑的完善和优化得到了市场的认可，然后苹果公司成为了上市公司，最终使得乔布斯在20岁刚出头就已经是亿万富豪。<br>&emsp;&emsp;<strong>驱逐：</strong> 上市后尽管有钱了，但管理上受到了市场及职业经理人的掣肘。尽管乔布斯个人能力突出，带领公司走向了一个个顶峰，但其对团队内部的管理不被董事会和团队成员理解，最终被驱逐出苹果公司。<br>&emsp;&emsp;<strong>摸索：</strong> 离开苹果后，乔布斯也才刚30岁，正是青年有梦的年纪，更何况是乔布斯，当然不可能沉沦堕落，加上虽然被驱逐出去苹果公司，但还是手持着大量苹果的股票，将股票卖出后手上有了大笔资金，因此成立了Next公司进行操作系统研发，并购买了皮克斯公司进行动画制作。<br>&emsp;&emsp;<strong>回归：</strong> 在乔布斯离开苹果后，尽管苹果的问题在一段时间内有所缓解，但经过几年的摸索还是一直在走下坡路，最终7年后苹果公司通过收购乔布斯的Next公司，将乔布斯重新召回苹果。至此，乔布斯经过这些年来兜兜转转又回到了苹果，尽管董事会和团队内部对其管理仍然无法认同，但却将苹果公司从谷底一路拉回了一个个高峰。</p><center><img src="/img/books/乔布斯全书.jpg" width="150" height="200" title="乔布斯全书"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乔布斯 </tag>
            
            <tag> 苹果 </tag>
            
            <tag> 传记体 </tag>
            
            <tag> 故事汇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从抛硬币的实验中，看到的奋斗人生</title>
      <link href="/2019/03/15/life/life-%E6%8A%9B%E7%A1%AC%E5%B8%81/"/>
      <url>/2019/03/15/life/life-%E6%8A%9B%E7%A1%AC%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>&emsp;&emsp;做个抛硬币的实验，对于一个质地正常的硬币，每次向上抛起，如果落下来是头像则输100块，如果落下来是字则赢200块，如果是你，你愿意接受这个实验吗？对于实验可能的结果和期望值如下表所示：<br>实验次数|实验结果|整体评价（期望值）<br>–|–|–<br>1|50%输100，50%赢200|赢50<br>2|25%输200，25%赢400，50%赢100|赢100<br>3|12.5%输300，37.5%赢300，12.5%赢600，37.5%平|赢150<br>4|…|赢200<br>k|…|赢($k\times 50$)<br>以第三次实验为例说明：12.5%的概率输掉300块，37.5%的概率是不赢不亏（平），37.5%的概率赢300块，12.5%的概率赢600块。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>&emsp;&emsp;从整体实验来看，不论是单次还是多次，期望值都是正的，只是随着独立实验次数的增多，期望值在不断增加，所以不论是接受一次实验还是多次实验，都是值得冒险的。但是，实际情况，大家的第一反应，甚至深思熟虑后的结果，也不一定会接受实验。<br>&emsp;&emsp;首先，如果是单次实验来看，单次赢的期望值只有50，而且有输100块的风险，所以如果只是进行一次实验，会有不少人需要好好考虑，甚至拒绝进行实验的。其次，如果可以进行多次实验，其损失的钱的概率已经越来越小，因此如果进行多次实验，大多数人都愿意接受实验。<br>&emsp;&emsp;将多次独立实验的情况换一种说法，将每次独立实验的主体换成不同的人，即有多个人都提供完全一样的独立实验，但每个实验只有一次机会，当然，随着实验主体的增多，其结果跟多次实验是一样的，所以，如果有多个实验主体的时候，大多数人都应该接受实验。<br>&emsp;&emsp;如果多次实验主体对应的实验不完全一样，导致各实验的输赢概率不同。如果，每个实验本身的期望值是正值，那么按照同样的推理过程，这样的多个实验仍然是应该接受的。将这样的概率放到我们生活工作中对比，我们在用一生的时间来得到来自外界给自己的实验，尽管有期望值为负的选项，但对于只要是期望值为正的选项，即使是有可能失败的挑战，也是值得尝试的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;虽然一个具体事情的判断，容易让人产生较强的得失顾虑，进而会沉浸在一件具体的事情中；但是，如果站在人生的几十年时间维度去考量，这些单个事件都只是一次独立或非独立的实验，对于期望值为正的事情，即使最终结果是输也只是本次成了小概率事件，坚持下去终会积沙成塔成就自己，这应该也是赌场能够赚钱的秘诀。<br>&emsp;&emsp;当然，首先找到对自己来讲，期望值为正的事情非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抛硬币实验 </tag>
            
            <tag> 概率 </tag>
            
            <tag> 期望值 </tag>
            
            <tag> 人的非理性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《房间》</title>
      <link href="/2019/03/07/life/movice-fj/"/>
      <url>/2019/03/07/life/movice-fj/</url>
      
        <content type="html"><![CDATA[<h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;这部电影是通过另一种方式讲述女孩被非法囚禁的故事，故事本身是源自小说，其实前些年国内在新闻和网络上也看到过不少关于拐卖妇女的故事。故事中，一些年轻女孩被拐卖到偏远地区，被囚禁起来直到女孩为买主生下小孩才肯被放出来过日子，由于交通极度不发达，几乎没有人能逃出来。故事中，有部分女孩逃走了或者后来被解救出去了，会因为想念自己的小孩，又返回去过日子的。Youku中这部电影的评论区第一条，有人说了自己的经历。</p><p><center><img src="/img/life/20190307222057171.png" width="400" height="100"></center><br>&emsp;&emsp;电影讲述的故事比较沉重，多次看到无法控制情绪，看到他们母子生活的辛酸和为儿子的生命里增添阳光。也许是7年时间的经历，将女主作为人的尊严和棱角都磨去了，在电影中女主被囚禁的过程中，每周或者间隔固定时间老尼克就会过来解决生理需求和采购基本生活用品，除了女主坚决不然他遇见和接触自己儿子外，他们俩人接触的其他的事情有种是一家和谐的家庭的错觉，并没有那种被关押后极力反抗的情绪。</p><h1 id="爱"><a href="#爱" class="headerlink" title="爱"></a>爱</h1><p>&emsp;&emsp;也许有人会想，7年时间应该有很多逃出去的机会，比如当老尼克输密码出门时是背对着屋里，可以进行攻击；比如老尼克睡觉时，可以进行袭击。但电影中对这些都没有叙述，也许这些在早期女主都有过反抗和尝试，但都遭受了毒打或者惩罚，所以后来慢慢也就失去了正面冲突的能力。就好像一个科学实验中，将蟋蟀放置一个杯子并将盖子盖上，每次跳起来都会因为碰到顶部盖子而摔回去，直到尝试很多次遍体鳞伤之后，即使实验人员把盖子拿走，蟋蟀跳起的高度从来没能再超过盖子。不过，随着自己儿子的长大，看着儿子对世界的认知越来越狭隘和简单，又燃起了心中的逃跑计划，最终跟儿子合作完成了逃跑。<br>&emsp;&emsp;家庭中的任何一个成员都是家庭里的核心，失去任何一位都可能对整个家庭造成致命的打击，女主自己被解救出来后，发现自己的父母已经离婚，在自己被囚禁的这件事情上，尽管她自己被伤害的最大也最直接，但其实自己的家人也都是受害人，爱自己也是爱家人。每个人都有自私的一面，家庭也是一个小的单元，也许不是时刻都能意识到自己作为家人成员的重要性，一旦失去后才能珍视。有个情景，被解救后的女主回家后在沙发上坐着跟妈妈吵架，妈妈说，不是只有你自己是受害者（女主被囚禁后，家人失去了女儿），你想想如果有人现在把Jack（女主的儿子）带走呢？</p><h1 id="星星之火"><a href="#星星之火" class="headerlink" title="星星之火"></a>星星之火</h1><p>&emsp;&emsp;这部电影从写实的角度描述被囚禁女孩的悲惨生活，也许是儿子的出世给了女主坚持的勇气，正如被警察解救出来后，女主在接受媒体采访时，被问到是否有想过结束自己的生命，是否想过在孩子出生时就让关押她的人将孩子带走，是否孩子在自己身边对他更好，一系列来自生命底层的问题抛向她时，7年的囚禁都坚持下来了，最终受不了记者的灵魂拷问险些自杀成功，最终因为儿子发现后被送往医院。<br>&emsp;&emsp;也许女主选择将儿子留在身边是自私的，但也许那就是她生命里的唯一的光点。女主也尽一切可能保护儿子，将儿子跟老尼克做了尽可能的分离。如果选择将儿子送走，也许自己无法坚持到被解救。没有人是圣人，当然记者的提问并非恶意，只是万千世界中会存在的各式各样的声音，我们需要听到和思考。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 剧情片 </tag>
            
            <tag> 犯罪片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《浮生六记》</title>
      <link href="/2019/03/01/books/%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/"/>
      <url>/2019/03/01/books/%E6%B5%AE%E7%94%9F%E5%85%AD%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;第一次大篇幅的阅读古典文，之前最多也只是几百字的一篇文章，比如中学时候的岳阳楼记、黔驴技穷等简单的文言文，或者名家的一些简单的唐诗宋词或者元曲。尽管本文主体是以文言文的形式写著，但也有编著者对其进行了注释和解析。<br>&emsp;&emsp;开始也是被书名吸引买的书，拿到书后翻开第一页还是被吓了一跳，毕竟从来没想过要看一整本文言文，尤其开始看前5页的时候，其实有些痛苦，有些文字不太认识，而且有些文字认识但含义不了解，甚至在表达上也相对生涩不太好理解。但是，随着阅读的深入，慢慢喜欢上了这种文风，这两天说话和写文章居然偶尔使用了一些古文里的词汇，而且使用的成语明显比平时更多了。<br>&emsp;&emsp;除了本书的古文形式的阅读对自己有一定的影响外，整体阅读过程也受到一定的启发，就是有些事情你没尝试过的时候，你别轻易给自己贴一个不行的标签，而有些你之前未尝试过或者不太敢主动尝试的事情，如果心里一直有个碎碎念，不妨找个机会给自己一个挑战，不论是主动还是被动，比如读一本英文小说。尽管买这本书完全是被名字吸引，算是被动得到了这个机会，但阅读完之后却又意外的收获，毕竟正常情况下我不会主动去购买整本书是文言文的书来阅读。</p><h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>&emsp;&emsp;本书是作者以第一人称的方式进行叙述自己的一些见闻，看整本书大多以“余”来进行叙事，对应于现在汉语就是“我”的意思。作者叫沈复，是清朝的一位作者，出身于一个普通中产家庭，不过后来家道中落，自己为一些政客作幕僚，就是现在参谋的意思。<br>&emsp;&emsp;整本书分6章，成文章节从前到后分别是“闺房记乐”、“闲情记趣”、“坎坷记愁”、“浪游记快”、“中山记历”、“养生记道”，每个章节的标题都有一个“记”字，就是本书的6记，整本书的内容像一本长长的日记，记录了各个阶段各类情况下作者自己的境遇和所见所闻。<br>&emsp;&emsp;&emsp;&emsp;第一章闺房记趣是说沈复的和自己老婆芸娘的一些浪漫故事，或者说一些相互欣赏又别出心裁的一些生活乐趣；第二章的闲情记趣写沈复自己小时候的一些小趣事；第三章坎坷记愁写沈复面临的家庭危机，面对老婆卧病多年，父亲去世，弟弟猜忌，以及儿子去世等等的愁苦坎坷；第四章浪游记快主要描述跟着政客做幕僚期间在全国各地游历的景色风景；第五章中山记历描述作者跟随朝廷命官一起到琉球国进行册封时候，在当地的一些民俗的见闻经历，这个中山是琉球国的古称，是一个国家的名字，位于台湾和日本之间的一些群岛，不是现在的广东省中山市，当时属于中国的藩属国，后来被日本抢占了；最后一章养生记道说作者老婆去世后，自己坚持做的一些养生的行为修养。</p><h1 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h1><ul><li>首先，阅读文言文是一个意外，也是挑战，但也带来了惊喜，另外这本书相对还算容易理解。</li><li>其次，对自己做事有个提醒，不能总是在一个固定的思维或者圈子里，有时跳出来看看，多跟不同圈子的人交流，- 也许会有不一样的惊喜。</li><li>然后，不论做什么，都要坚持到自己明白了，也许有些事起初不太顺利，只要是自己确定过可行性，或者有条件继续坚持，那就不妨坚持直到事情有了一个里程碑，或者自己明白了是该停止还是继续。</li><li>最后，自己有了一个新的计划，会在自己的书单中增加一本英文原著和一本繁体字读物，不论小说还是大众读物。</li></ul><center><img src="/img/books/浮生六记.jpg" width="150" height="200" title="浮生六记"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文言文 </tag>
            
            <tag> 清朝 </tag>
            
            <tag> 生活记事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>舅舅带外甥的一天日常</title>
      <link href="/2019/02/28/life/life-%E4%BF%8A%E5%B8%A6%E5%A8%83/"/>
      <url>/2019/02/28/life/life-%E4%BF%8A%E5%B8%A6%E5%A8%83/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;寒暑假是多少个学生日日夜夜所期盼着的，不知不觉间我大学的寒假就这样悄悄的向我走来了，突然感觉这时间真的过的有点快，仿佛暑假才刚刚从我身边走过，就这样我如期而至的回到了家里，之前跟我姐约好了放假回来时过去帮她带一下娃，就这样我的带娃生活就开始了。<br>&emsp;&emsp;放假了一般肯定都会睡个懒觉来补补觉，而我却会一大清早的被弄醒，当我还在睡梦中傲游时，就被一双小手像拔萝卜一样拉扯着我的手，睡意朦胧的我睁开了眼睛，看到了一张天真无邪的脸在我面前，并呼喊着我：“舅舅起床，别睡懒觉~”。对于我这种不喜欢大清早在睡觉时被人吵醒的人来说顿时就没有了脾气，我只好无奈的顺着他意起了来，带着他去刷牙洗脸，然后给他泡奶。就这样我今天的带娃生活就开始了。<br>&emsp;&emsp;对于两岁半的小孩来说，最主要的莫过于玩了，只要开心就尽情的去玩，因为年龄还小，不可能让他去学习那些五花八门的知识，那样太难为一个小孩子了，所以我的任务也就是陪他玩，看着他不让他受伤。他有一个专门属于他的玩具房，里面有他各式各样的玩具，就这样他又再次拉着我，把我带了进去。一进到里面我就感觉是玩具都是乱七八糟的，各种各样形形色色的玩具杂乱无章的在那躺坐着。相比于我以前哪会有一个专门放玩具的房间，哪会有那么多大小不一的玩具，哪会有那么多形状各异的玩具。<br>&emsp;&emsp;看着时间差不多，他也很安安逸逸的在那玩着他的玩具，我就跟他说舅舅去做饭你自己在这先玩着，他非常乖巧的答应了，只是不一会儿就会叫你一下。午饭过后当然就是午觉的时间啦，而带小孩最难的也莫过于要哄他睡觉，这好比是在跟他打一场比意志力的战斗，有时你还真的会被他打败比他先睡着，然后醒来时便会发现他坐在床边在那自顾自的玩着玩具。等他午觉起来就要给他再泡杯奶粉，然后带着他到楼下小区里玩他的滑板车，等他尽兴了，天色也差不多晚了就带他回家，这时候他爸妈也是差不多到点下班回家的了。<br>&emsp;&emsp;就这样我的假期大部分时间都是陪着他度过的，还没结婚的我却已经先提前体验当奶爸的生活了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿俊 </tag>
            
            <tag> 舅舅 </tag>
            
            <tag> 外甥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业，专升本的在校日常</title>
      <link href="/2019/02/26/life/life-%E4%BF%8A%E4%B8%93%E5%8D%87%E6%9C%AC/"/>
      <url>/2019/02/26/life/life-%E4%BF%8A%E4%B8%93%E5%8D%87%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;大学生活就这样如期而至的到来了，然而对于我这个没考上本科学校的学生来说就只有在专升本上多加把劲，将别人周末休息、玩的时间用在学习上，以此来拿到本科毕业证。<br>&emsp;&emsp;又一个周末的到来，跟平常上课一样，早早的就被闹钟吵醒，看着宿舍其他人还在那熟睡，周末可以睡懒觉，而我还要去上课，心里难免会有些情绪波动，但却又无可奈何，毕竟每个人走的路都不一样，打开宿舍门一丝寒风像我袭来，是我不得打了个寒战。早上的天气虽然清凉了一点，但去到教室看到在那陪伴着我的同学，就不知从哪传来了暖意，让我感觉大清早的天气也是暖的，这学期就只专攻三门课程。《网络经济与企业管理》从中我了解到了许多企业大咖对市场走向而制定的各种自己公司的方案、如何来管理公司、如何不被其它企业所打败…；《计算机原理》从中我了解到了十进制、原码补码…；《信息系统开发与管理》我了解到了企业系统的规划、系统的设计…。这些都是我在专科课本上没有看到过的，虽然比没报升本的辛苦一点，但从中我也是获益匪浅，还是有所收获的。<br>&emsp;&emsp;专升本的大家庭也不是一直学习如此枯燥无味的，我们自己组织过趣味运动会，其中当然是趣味多多的，还专门弄了一个元旦晚会，其中策划、节目等都是我们学生自己来制定，可以说是真的自导自演，这能很好的锻炼到我们的自主能力，节日我们还一起包过饺子…可谓是丰富了我们的生活。<br>&emsp;&emsp;升本的课程是会挺赶的，因为这学期学完下学期刚开学就要准备考试了，平均一门课就只有五六节课，然后就上考场了，所以就要靠自己去复习了。考试是需要自己去报名的，因为要抢离自己近的地区去考试，老师不可能顾及到那么多人，所以早早的就要起床用电脑去抢考场，然而由于访问人数过多，导致网站都要差点崩了，进去都很难，更别说报考了，就这样看着像爱滴魔力转圈圈。等了大半天最后还是只能请报好了的同学帮忙才弄好。<br>&emsp;&emsp;我的升本就这样不知不觉间进入到了备考阶段，无论何时我自己还是一到考试都会莫名的紧张，但这也是检验我牺牲休息时间所获得的成果。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专升本 </tag>
            
            <tag> 计算机专业 </tag>
            
            <tag> 阿俊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从汽车的天线，说说其中的物理知识</title>
      <link href="/2019/02/20/life/life-%E6%B1%BD%E8%BD%A6%E5%A4%A9%E7%BA%BF/"/>
      <url>/2019/02/20/life/life-%E6%B1%BD%E8%BD%A6%E5%A4%A9%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;现在小汽车已经成为日常家庭的常规交通工具，不过，经常看到汽车顶部有个天线，有的天线是一根棍状，有的像个鲨鱼鳍，也有汽车没有天线，那这个究竟是什么，有什么作用呢，本文基于此做一些解释。</p><h1 id="物理知识"><a href="#物理知识" class="headerlink" title="物理知识"></a>物理知识</h1><p>&emsp;&emsp;首先，说下金属导体的静电感应概念，在普通的金属导体内部有可以任意移动的自由电子，这些电子默认情况下在做无规则运动，如果没有外力作用，整个导体呈电中性。当导体处于电场中时，电子受到固定方向外力会发生定向移动，导体就会出现一端带正电一端带负电的现象。我们把导体中的电荷在外电场作用下，发生重新分布的现象叫做静电感应（导体上因感应而产生的电荷叫做感应电荷）。<br>&emsp;&emsp;其次，说说静电平衡状态，自由电子在电场中会持续做定向运动，随着自由电子的持续运动，感应电荷形成了新的电势差，如果感应电荷形成的电场跟导体所在环境电场，对导体中自由电子的力一样时，自由电子就会停止运动，即自由电子会运动到导体中的自由电子所受的力达到平衡而不再做定向运动的状态，这个状态就是静电平衡状态。<br>&emsp;&emsp;最后，说说法拉第笼，法拉第笼是由金属或导体材料构成的一个笼子，由于笼子本身是导体构成，因此这个笼子整体可以看做一个导体。当笼子处于电场或磁场中时，笼子自身即为一个等势体，因此笼子内部就会由于笼子的静电平衡实现信号屏蔽，这也就是电梯里面没有信号的原因（电梯本身可以看做一个金属盒子）。</p><h1 id="汽车天线介绍"><a href="#汽车天线介绍" class="headerlink" title="汽车天线介绍"></a>汽车天线介绍</h1><p>&emsp;&emsp;汽车本身的材料是属于导体结构的钢材构成，不过，由于并非完全封闭（有挡风玻璃、车窗及车天窗等位置是非金属材料），因此车体内有信号但信号相对较弱，需要通过天线来增加信号，关于天线增强信号的原理不在本篇范围，之后再找机会专门介绍（简单说就是一个电磁波到电流信号的转换器）。<br>&emsp;&emsp;常见的汽车天线有几种，如下：</p><ol><li>伸缩式天线，类似以前收音机可以伸长和缩短的那种天线，用于老式汽车，现在的汽车基本不再使用这种天线。<center><img src="/img/life/20190220143714243.png" width="150" height="200" title="伸缩式天线"></center></li><li>鞭形天线，这种天线是不能伸缩的，现在汽车上用的比较多。外观好看，但风噪比较大。<center><img src="/img/life/20190220141729732.png" width="150" height="200" title="鞭形天线"></center></li><li>鲨鱼鳍天线，这是目前比较受欢迎的一种天线形式，主要原因是漂亮，很多车主朋友会把自己的天线改装成为鲨鱼鳍。鲨鱼鳍天线最初是在宝马车研制出来并应用到车身上的，时尚的设计、动感的外观受到广大车主的喜爱，其他汽车厂商纷纷跟进。<center><img src="/img/life/20190220141855204.png" width="150" height="200" title="鲨鱼鳍天线"></center></li><li>玻璃天线，就是把天线嵌入到前挡风或者后挡风玻璃内部，所以一般装了玻璃天线的汽车，是看不到汽车后面这个小尾巴的。<br>&emsp;&emsp;玻璃天线现在也是比较主流的配置了，但玻璃天线在技术上又有几种形式：玻璃内嵌细金属丝天线、印刷在玻璃表面的天线、透明导电薄膜天线等。由于玻璃天线满足了汽车力学、美学和空气动力学的要求，所以很多厂商会选择这种。有个小问题，就是如果挡风玻璃坏掉了，就只能更换原厂的汽车天线玻璃，价格会高一点。<center><img src="/img/life/20190220142509199.png" width="150" height="200" title="玻璃天线"></center></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静电屏蔽 </tag>
            
            <tag> 法拉第笼 </tag>
            
            <tag> 物理知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有必要因为补脑目的，为宝宝的辅食增加核桃油吗？</title>
      <link href="/2019/02/19/baby/%E6%A0%B8%E6%A1%83%E6%B2%B9/"/>
      <url>/2019/02/19/baby/%E6%A0%B8%E6%A1%83%E6%B2%B9/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;先说自己的答案，完全没必要因为补脑目的，为宝宝的辅食增加核桃油，或者说对成人来讲吃核桃也不会让你变聪明。</p><h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>&emsp;&emsp;最近开始给宝宝增加辅食，不知道什么东西可以吃，什么不可以吃，但根据书上的指导开始尝试一些水果和蔬菜，不过，听身边的宝妈都在说，为了让宝宝有聪明的大脑，可以给宝宝的辅食中滴一些核桃油，理由是核桃具有补脑功能，现在吃不了核桃那就滴一些核桃油。<br>&emsp;&emsp;宝宝的智商超过一半在出生时已经由基因已经决定了，后天的培养主要从知识体系进行训练和固话，但只要宝宝营养不会太差（现代人的基本生存问题已经没有了），靠饮食对智商产生什么影响，大概率是假的。如果有人劝你吃什么来提高智商，要么那人无知，要么那人别有用心。<br>&emsp;&emsp;</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>&emsp;&emsp;一个人后天的成绩或者终生的成就受很多因素的影响，不止是一个智商高低就可以一概而论，很多成果是要人持之以恒的坚持多年的努力，当然也要有适当的运气才能获得，而智商通常只是其中一个不太重要的环节，下面从三个方面进行解释：</p><ol><li>人生是场马拉松，不是百米赛跑。也许对于一个目标来讲，坚持比智商更有价值，以跑1000米为例，以跑步的快慢代表智商的高低，有人跑的慢，那就多用一些时间，有人跑的快那就用少些时间，但不论快慢，只要从头坚持到尾就都可以跑完，但如果跑的快但只跑一半甚至不开始迈步，那就始终无法完成。很多人起初学习的很多东西都是父母的一厢情愿，随着年龄的渐长很多不必要的技能都还给是岁月，在这个专业化分工的社会中，一个全才已经不太能有太大作为，都需要有自己的专业，而这个专业不止是靠速度或者靠高智商的高起点，都需要时间的沉淀和自己潜心的积累。<br>&emsp;&emsp;就好像很多家长也担心自己的宝宝输在起跑线，很早让宝宝进行学前教育，或者上学比别人晚了（9月1日为分界，之后出身的宝宝需要晚一年上学），预产期在9月1日附近的争取提前剖腹产。其实，即使宝宝晚一两年上学工作又有什么关系呢，人生有几十年的光阴，不止是一两年的提前就能改变什么，每个人都有自己的机遇，不必太着急。</li><li>每个人对生活的理解不同。也许有的人追求名利，有的人追求财富，但也有的人追求平淡，有的人追求简单，很多爸爸妈妈总是担心自己的宝宝未来过的不好，只是每个人都有自己的历史使命和对生命的理解，除了他自己没人可以真正左右，所以家长也不必太杞人忧天。</li><li>没有证据证明核桃可以补脑，从以下几个方面解释：<ol><li>补脑的深层含义大概是提高智商或认知能力，迄今为止并有人任何直接证据可以证明，有任何食物可以直接提高人的智商和认知能力。</li><li>核桃在中药中有一味药材，学名是核桃仁，其作用不是健脑而是温补肺肾，定喘润肠。</li><li>以形补形是伪科学，即使核桃长得像人脑，吃了也不可以补脑，吃了鸡翅也长不出翅膀。食物入胃都会经过胃酸（蛋白酶）分解，不论原来是什么形状，都会被分解为最基本的单元。或者说，食物都需要经过消化、吸收、生物转化、输送等环节，才能通过血液循环把各类营养物质运送到全身各组织器官。</li><li>核桃中有易于身体的元素，在其它坚果中一样有，只是各营养成分的比例不同而已，并没什么特殊的。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 核桃油 </tag>
            
            <tag> 辅食 </tag>
            
            <tag> 补脑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《血战钢锯岭》</title>
      <link href="/2019/02/18/life/movice-xzgjl/"/>
      <url>/2019/02/18/life/movice-xzgjl/</url>
      
        <content type="html"><![CDATA[<h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;这是一部之前看过很感动，想再看一遍，现在看完打算之后还会再看的电影，电影源自真实的故事，当然有些桥段做了修改，<a href="https://movie.douban.com/review/8215330/" target="_blank" rel="noopener">点击查看真实事件</a>。看完后有两点想说说，第一是关于信仰，第二是关于尊重，第三是关于战争剧情。<br>&emsp;&emsp;关于信仰，男主因不肯杀生的信仰始终不愿意拿枪，似乎过于执拗，正常逻辑来讲完全无法解释，尤其其还要参军报销祖国，但这么矛盾的一对组合并不妨碍其个人的伟大，电影中男主的信仰很多次感动自己，也多次羡慕男主可以坚守的信仰，可是现实中的自己竟不知该信仰什么。<br>&emsp;&emsp;关于尊重，尽管所有人都认为男主是故作姿态，所有人都看不上他，也不想与他为舞，甚至当大家为此受到惩罚时，大家也还是选择尊重他的个人自由，让其自己选择拿起枪，而不会通过表面的方式，把枪放到他身上或者绊到他身上。<br>&emsp;&emsp;关于战争剧情，自己没有参加过也没有见过真实的战争，但整部电影看起来更写实，没有刻意美化战争，没有刻意简化战争，没有太多贬低敌人，没有太多夸大自己的勇气和智慧，也没有掩饰战争的残酷，我们国家经历过那么多的苦难，那么多的民族英雄，但拍出来的抗战片很多简直是在侮辱智商。</p><h1 id="故事剧情"><a href="#故事剧情" class="headerlink" title="故事剧情"></a>故事剧情</h1><p>&emsp;&emsp;电影从开始的轻松愉快，通过参军和军营训练，最后过渡到真实的战争，每个环节的编排都是环环相扣。在军营中由于信仰不被理解，从战友到教官，甚至军事法庭都对其行为表示不屑和抵制，最终靠非正常途径（老爸的关系）得以留着军队；在战场上，作为医疗兵不断完成着自己的使命，将一个个伤员不断从前线救回，尽管电影场景的布置让剧情看起来主角光环明显，但确实是真实事件的翻版，也许真实的情况没有人能完全复现。<br>&emsp;&emsp;军营里，由于男主的行为不被所有人认同，因此被所有人排斥。在宿舍中被舍友晚上殴打，在训练场被战友欺负，在平时生活中被自己领导压制，甚至为此宁愿背上拒服兵役的罪名被送上军事法庭，而在正义的法庭上也被法官不认同，这些反向的刻画更表现男主对信仰的坚持，以及对自己生命意义的追寻。<br>&emsp;&emsp;战场上，当一场战斗败下阵来，所有人退回营地时，他听到有人在呼叫救援，独自一人坚守了自己的职责，一天一夜的坚持最终救下70多伤员，在这样短兵相接的地方，也许一秒钟的迟疑就会送命，可是他始终在坚持，也许只是坚守这自己的责任，也许只是倾听内心的信仰，可能这就是精神。</p><h1 id="台词摘录"><a href="#台词摘录" class="headerlink" title="台词摘录"></a>台词摘录</h1><ul><li><p>All I saw was a skinny kid. And I didn’t know who you were. You’ve done more than any other man could have done in the service of this country. And I have never been more wrong about someone in my life. I hope one day you can forgive me.（我一直以为你只是个瘦小的孩子，并不知道你是什么样的人，你对这个国家的贡献比任何人都要多的多，我这辈子从来没有对其他人有过这么深的误解，我希望有一天你能原谅我。）</p></li><li><p>I would say that anyone is wrong to try to compromise somebody’s conviction. I don’t care whether it’s army or what it is. When you own a conviction, that is not a joke. That’s what you are.（我认为所有人的信仰都是值得被尊重的，不管是在军队，还是在别的什么地方，只要你有信仰，那就绝不是一个玩笑，那就是真实的你）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 历史剧 </tag>
            
            <tag> 战争片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《大汉十三将 之 血战疏勒城》</title>
      <link href="/2019/02/18/life/movice-dhssjxzslc/"/>
      <url>/2019/02/18/life/movice-dhssjxzslc/</url>
      
        <content type="html"><![CDATA[<h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;男主是谢苗，名字可能很多人陌生。有部电影大多数人应该都看过，自己也是在那部电影中知道这个人，叫做《新少林五祖》，跟李连杰搭档父子戏，小时候看的时候也是好不过瘾，后来查了原来就是今天这部戏的男主。<br>&emsp;&emsp;这部戏尽管有不少细节处理的有点矫情，不过整体看还是很过瘾，个人比较喜欢这种塞外的动作片，电影中有很多体现英雄主义的情节，也有不少体现作为将军的军事才能，当然虽然关于国家情怀的升华有些不太连贯，但故事还是比较完整。</p><p>&emsp;&emsp;不太理解现在大家的理解，是不是英雄就不能有儿女情长，英雄就一定要完美主义或者说智勇双全且无任何个人嗜好，好几部电影或小说要塑造一位英雄形象时，即使有位合适的女人，英雄也选择不近女色，不知道为什么英雄就从来没有个人情欲。拍摄的有血性有铮铮铁骨，有战争有英雄气概，有点遗憾的是形象塑造过于高大上了，少了点接地气的人情味。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;作为汉朝一名守卫边疆的将军，带领几百人在边疆的疏勒城内防守，城外有2万多名匈奴兵持续攻城近一年时间，城内断水断粮几近崩溃，好在城内将士百姓团结一心共御外敌，最终坚守到了朝廷的援军到来，援军赶来之际城内只剩下13人幸存。<br>&emsp;&emsp;双方都知道对方兵力，匈奴兵的大王自恃必胜的心态，为了尽可能少的牺牲自己的军队的同时拿下城池，所以几次战争在焦灼甚至马上取胜之时选择了退兵，也许这也就解释了为什么围城一年没有攻下。<br>&emsp;&emsp;最后一个镜头体现了英雄的视死如归，但场景感觉设计的不好，所有人坐在地上挪成团，匈奴人手拿长矛步步紧逼，都某一个时刻大家都停下来，匈奴王走人群后面慢慢走向最前面，问谢苗是否愿意投降，大家哈哈大笑异口同声说决不投降。不好在3点：</p><ol><li>前一个镜头还是所有人站在交杂在一起刀光剑影，后一个镜头就是大家一起坐在地上向一个方向挪动，思路不太好接上，尽管坐着更体现实力对比，但不如所有人站在被围着更能逻辑连续。</li><li>匈奴王劝降不成功下令杀，这时随便几个人长枪长戟就可以把汉将杀了，结果杀了半天还是就是最前面几位士兵有几个吐血的大特效，看得有点尴尬。</li><li>汉将被逼到坐在一起后，匈奴兵忽然停了等待匈奴王从后面缓缓走上前；所有人忽然同时听到了汉朝救兵到场，也许几秒钟就可以将汉朝将领全部居然同时停止进攻，然后匈奴王下令撤退自己选择单挑然后战死，完全不符合逻辑。</li></ol><p>&emsp;&emsp;有个小想法，可以改一下戏，不妨就是直接继续乱战，到最后援兵到来后，匈奴王为了自己将士鸣金收兵，然后自己为了给匈奴单于交代选择自尽，或者为了给自己将士撤退争取时间，独自一人抵御汉朝援兵而战死，这样即表现了汉朝守军的决心，也为敌人留足了颜面。<br>&emsp;&emsp;整体来说，电影值得看。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 谢苗 </tag>
            
            <tag> 动作片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《夺命金》</title>
      <link href="/2019/02/17/life/movice-dmj/"/>
      <url>/2019/02/17/life/movice-dmj/</url>
      
        <content type="html"><![CDATA[<h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;这是一部老片了，之前看过没太理解在说什么，其中的叙事也觉得杂乱无章，这次重看有一些新的感受，对其中的部分故事情节感同身受，也对整个故事有了新的理解。我觉得自己现在还没有能力把这个电影的影评写好，每次想写自己对一个事情的理解，总会被其中的故事细节牵扯，感觉自己还无法看到故事的全部。</p><ul><li>导演杜琪峰应该是推崇认真踏实和讲义气的情结，1000万最终分为两个500万，分别归属为本分工作的客户经理teresa（开始不愿意欺骗客户，所以业绩最低，当然在上司对业绩的压力下，也开始诱导客户，但最终因为自己良心不安选择了离职），和非常讲兄弟义气的刘青云，而刘青云还最终误打误撞获得超过1000万，可能只是为了剧情需要，而不是说更看重义气。</li><li>电影处于一个鱼龙混杂的状态，不论是有钱还是没钱都有自己的追求和困难，辛苦赚钱只求片瓦可以容身的人，也有收入超过6万可以买得起豪宅的警察，他们都在同一个城市，生活在同一个天空，有时连生命也都绑在一起的。</li><li>电影中对银行的客户经理的工作，轻描淡写的进行了展示，这两年自己对银行理财略有接触，虽然其中部分故事情节不一定真实，但其表达的东西确实是国内银行经理的现状，对于一些精明或者有个人判断力的客户不会听客户经理的推荐（尤其现在很多银行里客户经理自己对产品也不是特别专业，很多并非完全是适合客户的），对于一些买了信托或者理财的客户在客户经理看来，感觉就像似电影中表现出的呆滞，客户经理即使销售成功，如果还心存善良，也会有个人心理负担。</li><li>在经济不景气的情况下，各自都是为自己奔忙，或者说，当初大家都是为了生存选择在一起，现在在一起并不能使大家情况变得更好的时候，团队就会解散，即使古惑仔也是一样。古惑仔的义气也是需要经济基础的，如果在经济不好的年景，古惑仔老大自己也还是想办法捞钱，根本无暇顾及自己的弟子，最终也会作鸟兽散。</li></ul><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><ol><li>叙事方式选择了倒叙。先将所有人的角色的行为进行了叙述，然后分别以各人的角色进行独立介绍，到将大家都建立关系的环节。</li><li>故事是说，一个特别抠门的财务公司老板去银行取钱，原打算取1000万由于需求变化取了500万，剩余500万暂时放在了teresa那里。往停车场走的时候被自己员工跟踪，结果在跟自己员工搏斗过程中双双死亡，最终原本取出的1000万中，500万被teresa私吞，另外500万被原计划去抢劫的刘青云拿走了。</li><li>teresa是银行的客户经理，需要给客户卖信托，在所有经理中业绩排名最后，已经马上要被淘汰，电影中通过多个小情节来表示她的处境，她努力工作，但最终成绩平平，也许不只是业务知识不过关，只是没有过了自己良心那一关。第一个是大家一起开会，她的排名在最后，领导依次对除了自己以外的其它人做了点评，然后好像自己是局外人一样；第二个是下班后给客户打电话，在保安等不及后来催她下班。</li><li>刘青云是一个空有一腔义气的古惑仔，为自己社团老大A摆寿宴，靠老大的面子收了一些红包，但为了省钱14人挤在一桌也只能吃素，宴请当中一位兄弟B可能会吃官司，老大A也选择了不作为，只有刘青云想方设法自己筹钱为B保释，最终那位兄弟B自己的弟子见到刘青云低声下气凑齐钱后选择不再追随B。当然，电影中为刘青云的义气点了赞，刘青云因为兄弟义气，误打误撞拿了一大笔钱，最终实现了个人的财务自由。</li><li>任贤齐是一个警察，太太一直在看房，最近看上了一个海景房，风景漂亮也有实力购买，作为警察的任贤齐在一次出警时遇到一位辛苦赚钱的大伯，来到相关几十年，随着社会的变迁，做过不同的行业甚至也做过保安，最终社会还是没有自己的容身自己，情绪崩溃后拿着煤气罐冲进了电梯，好在最后任贤齐和他被安全救出，两人都是命悬一线。</li><li>推荐看，如果没看明白，就过段时间可以再看一遍。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 港台剧 </tag>
            
            <tag> 剧情片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《飞驰人生》</title>
      <link href="/2019/02/14/life/movice-fcrs/"/>
      <url>/2019/02/14/life/movice-fcrs/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;冲着韩寒的名号去看的电影，原以为仍旧走文艺片路线，但看了感觉开始尝试商业片，也许受到投资方的压力，不过整体来看剧情颇为感动，整体在讲一个人为了证明自己的追梦的励志故事，尽管故事相对老套，但台词和场景很多都值得去看看，也许跟韩寒本人是职业车手有关，电影看的过程也感觉特别真实。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;沈腾是本片的男主，尽管有些东西不太理解，但也有不少东西颇受感动，有几个场景电影院中听到不少笑声，但自己看到却感到莫名的辛酸。有时候梦想是个特别神奇的东西，不知道是什么和为什么，就是想朝着它往前走，就会有人愿意跟你一起走，似乎生命也有了意义。<br>&emsp;&emsp;不是特别理解的是，为什么男主希望参加比赛，究竟想证明什么，是证明自己的车技，还是想通过比赛来寻找初心，电影中有说到是为了给自己的职业生涯画个完美的句号，可是如果自己赢了最强的人，那还要继续比赛吗，如果输了还要继续证明自己吗？最后电影弱化了输赢，也许让观众来判断为什么要比赛，正如我为什么要工作和创业。电影中没有说是赢了还是输了，只是将比赛成绩一次进行了播报，需要关注自己来回忆另一人的成绩来判断。<br>&emsp;&emsp;男主在找到腾格尔拉赞助时，出100万想看沈腾和尹正唱歌跳舞，尽管钢管舞动作扮相都很搞笑，自己却看的辛酸不易，作为创业者深知拉投资的情况，不比这个容易多少，可是作为投资人也是拿着真金白银在支持你，没有谁的钱是风刮来的，都不容易。</p><h1 id="故事剧情"><a href="#故事剧情" class="headerlink" title="故事剧情"></a>故事剧情</h1><p>&emsp;&emsp;男主是一个职业赛车手，因为场外因素被抓进了监狱，5年后出狱，想通过赢得比赛来证明自己的实力，怎奈没有5年监狱生活让所有人都不看好，得不到赞助支持，在三位好友的帮助下，最终拼了一部赛车，并且最终赢得了比赛。<br>&emsp;&emsp;整体剧情比较简单，不过，在各个环节加了不少包袱也挺搞笑，有几个点印象深刻，感觉韩寒特别喜欢使用语言上的反转，增加台词的味道和笑料，就像《后悔无期》和《乘风破浪》里，不少台词都特别出奇：</p><ul><li>由于经费有限，印制第一套比赛服时候，全队服装都印了自己头像</li><li>最终比赛服，将赞助人女朋友的名字印在了胸前</li><li>在一个赞助商帮忙实现愿望的节目里，衣服因为没拉上大家只看到一个“求赞”</li><li>考驾照那里，跟教官之间语言的反转</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 剧情片 </tag>
            
            <tag> 韩寒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《天气预爆》</title>
      <link href="/2019/01/31/life/movice-tqyb/"/>
      <url>/2019/01/31/life/movice-tqyb/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;这两年，国内的喜剧演员也算是得到了比较不错的发展平台，各类娱乐节目的推陈出新让很多新的喜剧人被发掘，也有了成长了机会，通过这些喜剧节目比如“欢乐喜剧人”、“喜剧总动员”、“笑傲江湖”、“周六夜现场”以及“王牌对王牌”等等，认识了不少特别棒的喜剧人和喜剧团队，不过大多还是在娱乐节目中，可能参加娱乐节目的成本和风险相对可控。</p><h1 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h1><p>&emsp;&emsp;这两年国内都被宫廷剧垄断了，估计是模式比较成熟了，不过对于喜剧电影，感觉好些日子没看到什么好作品了，最近比较高曝光率的应该是沈腾吧，前些日子麻花团队的“西虹市首付”和“李茶的姑妈”，尽管有不错的口碑，但个人还是觉得拍的稀烂，也绝不会想看第二遍，故事尴尬，情节浮夸。<br>&emsp;&emsp;当前这部电影虽然情节玄幻，不过，特效和制作还算能看，只是电影中演员的表演痕迹太重了，或者是可能用力过猛。看电影过程有段时间有点看不下去了，感觉有些尴尬的情绪，但一直保持耐心坚持看完了，可能是出于对肖央在剧中个人情感的好奇，尽管一开始就已经猜到了结局，却毕竟还是有情绪可以拉着，也可以贯穿整部剧。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;故事本身比较简单，开始有风雨雷电四位天神，由于雷神的失职酿成了大错（人间炼狱），使得四位共同承受了责罚（被罚下天庭，且各自受到一个诅咒），被贬人间后雷神想在人间为所欲为，被寿星知道了，然后联合风雨电三神和一位凡人组成团队，最终将雷神打败恢复了人间的正常秩序，最终玉帝特批恢复了三神的天职。<br>&emsp;&emsp;剧中神话人物被跌落凡间后，也许只是普通人，但他们自己看来却是得到了完全相反的诅咒，比如雷公在天上是英雄气概到人间是没有男人气概，风神在天上风光无限到人间是下九流，雨神在天上是要雨得雨到人间成了什么事情也做不好，电母在天上受尽荣宠在人间不得有肌肤之亲。他们原本比凡人更有优势，却被自身优势的神力束缚了思想，导致最终却过不好正常人的生活，在电影最后，三神打破了雷神的压制后，幸福的过完了当前一生。<br>&emsp;&emsp;整体来讲，这部喜剧片也算最近以来难得还行的，也许大家的品味已经有一定门槛了，但跟那些为了流量翻拍IP的网络剧比，也算良心作品。本片挺多电影细节处理的比较细腻，有很多小的包袱算是看电影中会得到的小惊喜，不过也有不少网络段子是比较老的梗了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 喜剧片 </tag>
            
            <tag> 神话故事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《印度暴徒》</title>
      <link href="/2019/01/30/life/movice-ydbt/"/>
      <url>/2019/01/30/life/movice-ydbt/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;最近这些年引入国内的印度电影相对质量都不错，也许是因为经济学的优势商品特点（越是好的商品越容易经过长途跋涉到客户面前，因为同样路费对于越贵的商品其相对成本越低，所以越贵的商品越能够承受路费），也许是因为名人效应（名人大多爱惜自己的羽毛，对剧本和投资都有较高的要求，这部片主演是阿米尔汗）</p><h1 id="关于舞蹈"><a href="#关于舞蹈" class="headerlink" title="关于舞蹈"></a>关于舞蹈</h1><p>&emsp;&emsp;印度电影里总是有舞蹈。印象里，如果让人一句话描述印度电影的特点，那就是剧情会忽然加入一段舞蹈，让人摸不着头脑，比如真在追逐打闹忽然强行插入了一段独舞或相互追踪的人开始一起跳舞，尽管很多优秀的电影也没有舞蹈（比如阿米尔汗的摔跤吧爸爸），但主流的电影都有舞蹈。所以印度电影给人整体印象就是莫名其妙的插入舞蹈，连17年成龙主演的有印度元素的“功夫瑜伽”，也包含了不少印度的这种舞蹈。<br>&emsp;&emsp;印度电影中舞蹈的意义。关于印度电影为什么要加入舞蹈，之前看过节目解释有两种，第一种，是因为印度本地生活的居民说着不同的语言，为了吸引更多的人看电影或者进行文化交流，所以在电影中加入舞蹈方便通过肢体进行表达，同时也展示了喜庆之气；第二种，舞蹈是印度教的一个特色，印度教的一位神叫湿婆，湿婆创立了舞蹈，所以印度电影为了对印度文化的推广加入了舞蹈。<br>&emsp;&emsp;印度电影为国际化也做了不少妥协。尽管舞蹈也很美，至少很有地方特色，但毕竟国际化上还是会受到特殊文化的约束，相信未来这也是印度电影的一个趋势。本片中虽然也有女二号的独舞，但不再像之前那种无厘头的强行舞蹈，而是进行了剧情安排，女二号的舞蹈是为了给英国人进行表演助兴的个人独舞或舞蹈团体表演。</p><h1 id="关于剧情"><a href="#关于剧情" class="headerlink" title="关于剧情"></a>关于剧情</h1><p>&emsp;&emsp;整体电影剧情的一波三折让人耳目一新，各环节介绍清晰连贯。尽管剧情有一定的历史依据，但即使没有相关知识也能理解其中的故事。情节本身比较浮夸，但男主将多类人玩弄于手掌之中，在各类人之间游刃有余的表演还是特别让人期待。<br>&emsp;&emsp;通过一个简单的却符合主角定位的情景做开胃菜，出场方式让人对主角的颇为惊讶，然后开始上硬菜，去面对一方海盗，一直到电影后半程才对海盗的情怀进行升华，一直到电影结尾才展示男主真实的内心，表达对外强的抵制。从我们视角看，类似前些年比较流行的抗日神剧，整体来讲故事不错，值得观看。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 印度暴徒 </tag>
            
            <tag> 印度电影 </tag>
            
            <tag> 舞蹈 </tag>
            
            <tag> 阿米尔汗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow开发 之 基础概念及常用数据类型介绍</title>
      <link href="/2019/01/30/tech/tensorflow-datatype/"/>
      <url>/2019/01/30/tech/tensorflow-datatype/</url>
      
        <content type="html"><![CDATA[<h1 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h1><p>&emsp;&emsp;简单说就是一个特定的计算逻辑或者说算法模型。</p><center><img src="/img/tech/20190130210226.png" width="500px" height="300px" title="数据流图示例"></center><h1 id="Session（会话）"><a href="#Session（会话）" class="headerlink" title="Session（会话）"></a>Session（会话）</h1><p>&emsp;&emsp;简单说就是使用实际数据和模型进行运算，使用步骤包括定义，执行和关闭三步，语法如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义</span></span><br><span class="line">sess = tf.Session(target=执行引擎[可选],graph=数据流图[可选],config=启动时配置[可选])</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">sess.run(带操作的变量或操作本身)</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure></p><h1 id="Tensor（张量）"><a href="#Tensor（张量）" class="headerlink" title="Tensor（张量）"></a>Tensor（张量）</h1><p>&emsp;&emsp;简单说就是<font color="blue"><strong>同一数据类型</strong></font>的<font color="blue"><strong>多维数据</strong></font>。我们生活在3维世界中，高于3维的数据现实中比较难现象，以常用的0-3维数据为例说明如下表所示，其中有两个特点：</p><ol><li>同一数据类型（方便计算）</li><li>多维数组</li></ol><table><thead><tr><th>数组维数</th><th>名称</th><th style="text-align:left">Python示例</th></tr></thead><tbody><tr><td>0维</td><td>数量</td><td style="text-align:left">1</td></tr><tr><td>1维</td><td>向量</td><td style="text-align:left">[1,2]</td></tr><tr><td>2维</td><td>矩阵（数据表）</td><td style="text-align:left">[[1,2],[3,4]]</td></tr><tr><td>3维</td><td>数据立方</td><td style="text-align:left">[[[1,2],[3,4]],[[5,6],[7,8]]]</td></tr><tr><td>n维</td><td>n阶张量</td><td style="text-align:left">[…]</td></tr></tbody></table><h1 id="Operation（计算节点）"><a href="#Operation（计算节点）" class="headerlink" title="Operation（计算节点）"></a>Operation（计算节点）</h1><p>&emsp;&emsp;简单说就是函数计算，相当于通过函数对特定步骤的计算，常规的语法中的基础数学函数基本都有，常用的计算操作类型如下：</p><table><thead><tr><th>操作类型</th><th style="text-align:left">函数名称</th></tr></thead><tbody><tr><td>算术运算</td><td style="text-align:left">add、multiply、mod、sqrt、sin、trace、fft、argmin</td></tr><tr><td>随机运算</td><td style="text-align:left">random_normal、random_shuffle、random_gamma</td></tr><tr><td>数组运算</td><td style="text-align:left">size、rank、split、reverse、cast、one_hot、quantize</td></tr><tr><td>字符串运算</td><td style="text-align:left">substr、encode_base64、string_to_bash_bucket</td></tr><tr><td>图像运算</td><td style="text-align:left">encode_png、resize_images、hsv_to_rgb、adjust_gamma</td></tr><tr><td>逻辑控制</td><td style="text-align:left">identity、logical_and、equal、less、is_finite、is_nan</td></tr><tr><td>数据流控制</td><td style="text-align:left">enqueue、dequeue、size、take_grad、apply_grad</td></tr><tr><td>初始化</td><td style="text-align:left">zeros_initializer、random_normal_initializer、orthogonal_initializer</td></tr><tr><td>神经网络</td><td style="text-align:left">softmax、dropout、pool、bias_add、erosion2d</td></tr><tr><td>梯度裁剪</td><td style="text-align:left">clip_by_norm、clip_by_value、clip_by_global_norm</td></tr></tbody></table><h1 id="Variable（存储节点）"><a href="#Variable（存储节点）" class="headerlink" title="Variable（存储节点）"></a>Variable（存储节点）</h1><p>&emsp;&emsp;简单说就是一种变量，生成一种常驻于内存中的特殊类型的张量，用于在数据流图计算中存储特定节点的状态。数据类型有字符串、整型、浮点型和复数类型，使用的语法为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">tmpVariable = tf.Variable(initial-value=初始值，dtype=数据类型[可选],name=变量名称[可选])</span><br><span class="line"><span class="comment"># 变量赋值</span></span><br><span class="line">tmpVariable.assign(<span class="number">1.0</span>) <span class="comment">#类似 tmpVariable = 1.0</span></span><br><span class="line">tmpVariable.assign_add(<span class="number">1.0</span>) <span class="comment">#类似 tmpVariable += 1.0</span></span><br><span class="line"><span class="comment"># 使用变量</span></span><br><span class="line">z = tf.matmul(x,y) <span class="comment">#类似 z = x * y</span></span><br></pre></td></tr></table></figure></p><p>实际代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量定义示例</span></span><br><span class="line">tmpStr = tf.Variable(<span class="string">"hello"</span>,tf.string)</span><br><span class="line">tmpInt = tf.Variable(<span class="number">100</span>,tf.int16)</span><br><span class="line">tmpFloat = tf.Variable(<span class="number">1.0</span>,tf.float64)</span><br><span class="line">tmpComplex = tf.Variable(<span class="number">1</span>+<span class="number">2j</span>,tf.complex64)</span><br><span class="line"><span class="comment"># 变量赋值示例</span></span><br><span class="line">my1 = tf.Variable(initial_value=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],dtype=tf.int16,name=<span class="string">'one'</span>)</span><br><span class="line">my2 = tf.Variable(initial_value=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=tf.int16,name=<span class="string">'two'</span>)</span><br><span class="line">[my1,my2]</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line">sess.run([my1,my2])</span><br><span class="line"><span class="comment"># 相当于 my1 += my2 </span></span><br><span class="line">sess.run(my1.assign_add(my2))</span><br><span class="line"><span class="comment"># 相当于 my1 = my2 </span></span><br><span class="line">sess.run(my1.assign(my2))</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><img src="/img/tech/20190130181751344.png" width="300px" height="150px" title="变量定义示例"> <img src="/img/tech/20190130185417668.png" width="300px" height="150px" title="变量赋值示例"></p><h1 id="Placeholder（数据节点）"><a href="#Placeholder（数据节点）" class="headerlink" title="Placeholder（数据节点）"></a>Placeholder（数据节点）</h1><p>&emsp;&emsp;简单说就是可扩展变量，或者称为占位符，使用步骤为先进行定义，然后再进行赋值或称为填充数据，具体语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义</span></span><br><span class="line">tmp = tf.placeholder(dtype=数据类型,shape=维度,name=变量名称[可选])</span><br><span class="line"><span class="comment"># 赋值或填充数据</span></span><br><span class="line">sess.run(tmp,feed_dict=&#123;tmp:赋值数据&#125;)</span><br></pre></td></tr></table></figure></p><p>实际代码示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmpHolder = tf.placeholder(dtype=tf.float64, shape=[<span class="number">2</span>],name=<span class="string">'suoxd'</span>)</span><br><span class="line">sess.run(tmpHolder,feed_dict=&#123;tmpHolder:[<span class="number">1</span>,<span class="number">2</span>]&#125;)</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><img src="/img/tech/20190130202426199.png" alt="数据节点使用示例"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> Tensor </tag>
            
            <tag> Operation </tag>
            
            <tag> Variable </tag>
            
            <tag> Placeholder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《经济学故事书》</title>
      <link href="/2019/01/29/books/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B%E4%B9%A6/"/>
      <url>/2019/01/29/books/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%95%85%E4%BA%8B%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;这是一本作者在各处搜集素材，然后把一些概念进行拼拼凑凑，最终拼盘整合成的东西（也不知道为什么当初买了这本书）。一直认为这种书只适合初高中学生阅读，对扩大视野和知识面有点帮助，虽然不系统，但确实对一些概念做了解释。<br>&emsp;&emsp;不建议作为经济学概念入门知识学习，毕竟所述内容多而杂且不成系统，所述概念解释又不透彻，而且部分内容生搬硬造。如果从没接触过经济学相关知识，是想对相关概念快速了解，可以买来快速阅读。<br>&emsp;&emsp;有一点比同类书籍好的是，每个概念都会讲个小故事引入，方便小白读者理解概念内容，虽然有部分故事跟概念本身关系不大，甚至跟概念的观点是相反的，但不妨这种通俗易懂的写作方式。</p><h1 id="概念摘录"><a href="#概念摘录" class="headerlink" title="概念摘录"></a>概念摘录</h1><h2 id="关于价值"><a href="#关于价值" class="headerlink" title="关于价值"></a>关于价值</h2><ol><li>使用价值：物品自身的自然属性，是客观的。</li><li>效用价值：人在消费物品时的感受，是主观的，因人而异。</li><li>交换价值：物品的社会属性，依附于商品的交换属性。</li></ol><p>&emsp;&emsp;往往效用价值比使用价值更重要，或者说更容易说服消费者购买，由于消费者很难确定物品本身的成本或其对应的客观价值，但可以明确知道自己的消费的主观感受，后者更容易具有说服力。举个例子，对于两种商品，一种是在500ml容量的杯子里放600ml的商品（超过杯口堆砌起来），另一种是在1000ml容量的杯子里放650ml的商品，如果价格一样，选择前者的人更多，更多人认为第一种的购买体验更开心，也许生活物质丰富的现代人已经不是特别在意多出来的50ml商品带来的边际收益（边际效益递减）。</p><h2 id="常用宏观经济学概念"><a href="#常用宏观经济学概念" class="headerlink" title="常用宏观经济学概念"></a>常用宏观经济学概念</h2><ul><li><h3 id="GDP（国内生产总值）"><a href="#GDP（国内生产总值）" class="headerlink" title="GDP（国内生产总值）"></a>GDP（国内生产总值）</h3><ul><li>来源：国内一年内生产出的全部最终产品和提供劳务的市场价值总和。</li><li>作用：用于衡量一个国家经济活跃程度的指标。</li></ul></li><li><h3 id="CPI（居民消费价格指数）"><a href="#CPI（居民消费价格指数）" class="headerlink" title="CPI（居民消费价格指数）"></a>CPI（居民消费价格指数）</h3><ul><li>来源：由各国根据自身国民消费比重加权得到，我国的CPI指数由食品、烟酒、衣、家用品、医疗、交通、娱乐和居住这8项得到，8项的权重和为100。</li><li>作用：反应与居民生活有关的产品及劳务价格，统计出来的物价变动指数。</li></ul></li><li><h3 id="基尼系统"><a href="#基尼系统" class="headerlink" title="基尼系统"></a>基尼系统</h3><ul><li>来源：全名收入中，不平均分配的那部分占总收入的百分比，最大为1表示全部收入被一人占有，最小为0表示所有人分配完全平均。</li><li>作用：定量测定收入分配的差异程度，或者说贫富差距。</li></ul></li><li><h3 id="恩格尔系数"><a href="#恩格尔系数" class="headerlink" title="恩格尔系数"></a>恩格尔系数</h3><ul><li>来源：食品支出占消费总支出的比例，59%以上为贫困状态，50%-59%可以达到温饱，40%-50%为小康家庭，30%-40%为富裕状态，30%以下几位富豪，这个比例应该是几年前的了，现在仅供参考。</li><li>作用：用于衡量一个国家和地区的生活水平。原理是一个人通常会优先吃饱，如果还有盈余才会开始其它层面的消费。</li></ul></li><li><h3 id="幸福指数"><a href="#幸福指数" class="headerlink" title="幸福指数"></a>幸福指数</h3><ul><li>来源：$\frac{效用}{欲望}$/是一个计算公式，效用表示从消费中得到的满足感。</li><li>作用：用于衡量幸福程度，人有钱后从消费中得到的满足感会降低，但欲望又会增加，所以很多并不幸福。</li></ul></li><li><h3 id="消费者信心指数"><a href="#消费者信心指数" class="headerlink" title="消费者信心指数"></a>消费者信心指数</h3><ul><li>来源：统计消费者对经济形势、就业、物价及利率的预期。</li><li>作用：预测经济走势和消费取向，也可以监测经济周期的变化。</li></ul></li><li><h3 id="房价收入比"><a href="#房价收入比" class="headerlink" title="房价收入比"></a>房价收入比</h3><ul><li>来源：房价占城市居民家庭收入的比例。</li><li>作用：衡量房价高低以及普通民众的购买力。3-6倍比较正常，表示不吃不喝3-6年可以全款购房，我国部分城市的区域甚至超过100。</li></ul></li></ul><h1 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h1><ol><li>如果要读一些略显专业的入门图书，建议直接选择具体专业的图书，系统了解，而不是想着找一本类似故事汇，连点成线的勾勒专业内容。</li><li>如果只是为了作为入门常识了解，可以快速通读。</li><li>如果本身具有相关基础，这本书就不要读了。</li></ol><center><img src="/img/books/经济学故事书.jpg" width="150" height="200" title="经济学故事书 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 经济学故事书 </tag>
            
            <tag> 故事书 </tag>
            
            <tag> 年轻人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影评 之 《霍元甲之精武天下》</title>
      <link href="/2019/01/24/life/movice-hyjzjwtx/"/>
      <url>/2019/01/24/life/movice-hyjzjwtx/</url>
      
        <content type="html"><![CDATA[<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>&emsp;&emsp;尽管消费的是霍元甲的IP，卖的是爱国情怀，但看完后心理上却不舒服。看到霍元甲的名字才打开看，但看完后对心中的英雄形象打了些折扣，也许是人物塑造的不鲜明。<br>&emsp;&emsp;大概率上优势条件必然得到优势的资源和地位，因此默认情况下让外行，或者没有优势资源的人处于鄙视链的末端都是正常的，屌丝逆袭需要不断证明自己。即使看似只需要个人手艺比拼的地方，也并非只是对个人能力的比拼，也有其背后资源的考量。有3点想讲：</p><ol><li>老套的故事情节。情节的老套就是一个不世天才，出身卑微，在公平竞争中输给了自己的仁慈，所有人为了共同的名利选择无视个人能力，选择追随更有权势的人，只有底层的人才敢于提出对其个人认可，当需要真功夫的时候，大家才想起来这位，也许会长更多就是一份荣耀和权力。</li><li>非黑即白的诱导。电影中最后的这种一场定胜负的方式，如果赢了日本人就离开，如果输了自己就离开，也许人生的选择并非这么极端。就像中国的高考，备战了10多年，最终由两天时间来评判10几年的努力。如果把这一次考试当作定了终身，那偶然因素导致关键时刻掉链子就会过于严重。即使高考结果不是最理想的状态，也完全不必将高考作为唯一的未来。毕竟高中生也才过去10几年，未来还有几十年，还有无限的可能。</li><li>叙事逻辑拧巴。不论现在签订合同，还是过去签订协议或生死状，前提是双方具有相对平等的对话角度，或者有共同的制约因素，在一个本就不平等的背景下，这些都是强者对弱者的君子协定。一方面，电影中当日本人处于弱势时，在不断尝试打破规则，另一方面，又签订生死状，想尝试表现双方对契约的遵守。总体来讲，看着别扭。</li></ol><p><strong>情节就不剧透了，其实也不想写。</strong></p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><ol><li>如果想感受爱国主义情怀，可以作为范例看看</li><li>如果对动作片感兴趣，可以看看武打动作</li><li>如果奔着故事情节来的，不建议看，因为人物形象塑造的没特色，看了会莫名其妙</li><li>总体来看不建议看，因为看了影响心情。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 观影感受 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影评 </tag>
            
            <tag> 动作片 </tag>
            
            <tag> 霍元甲 </tag>
            
            <tag> 精武精神 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow开发 之 hello world</title>
      <link href="/2019/01/24/tech/tensorflow-hello-world/"/>
      <url>/2019/01/24/tech/tensorflow-hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="进入虚拟环境"><a href="#进入虚拟环境" class="headerlink" title="进入虚拟环境"></a>进入虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> demo/venv</span><br><span class="line">.\Scripts\activate</span><br></pre></td></tr></table></figure><h1 id="进入python开发环境"><a href="#进入python开发环境" class="headerlink" title="进入python开发环境"></a>进入python开发环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20190124093812208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf;</span><br><span class="line">tmpString = tf.constant(<span class="string">"hello world"</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tmpString)</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="comment">#b'hello world'</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2019012409424546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h2><p>&emsp;&emsp;字符串前面的“b”表示byte，sess.run执行结果的带编码的字符串，在python中是通过bytes来表示的，所以前面的b只是数据类型的标识。<br><img src="/img/tech/20190124111033329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1b3hkMTIz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> ai </tag>
            
            <tag> hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow开发 之 搭建开发环境（Windows、Ubuntu）</title>
      <link href="/2019/01/23/tech/tensorflow-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/01/23/tech/tensorflow-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Windows系统（win7及以上）"><a href="#A-Windows系统（win7及以上）" class="headerlink" title="A. Windows系统（win7及以上）"></a>A. Windows系统（win7及以上）</h1><h2 id="Python-amp-pip"><a href="#Python-amp-pip" class="headerlink" title="Python &amp; pip"></a>Python &amp; pip</h2><p>&emsp;&emsp;这个到处都有说，不再多说<br><img src="/img/tech/20190123210634108.png" alt="## 安装pip"></p><h2 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h2><h3 id="1-安装环境管理包："><a href="#1-安装环境管理包：" class="headerlink" title="1. 安装环境管理包："></a>1. 安装环境管理包：</h3><p>&emsp;&emsp;科学运算比较流行的AnaConda也可以，AnaConda含有非常多的科学计算库，不过由于virtualenv是tensorflow官网推荐的python环境管理包，所以用virtualenv作为管理包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -U pip virtualenv</span><br></pre></td></tr></table></figure></p><p><img src="/img/tech/20190123210519611.png" width="200px" height="100px"></p><h3 id="2-创建虚拟环境："><a href="#2-创建虚拟环境：" class="headerlink" title="2. 创建虚拟环境："></a>2. 创建虚拟环境：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --system-site-packages -p python ./venv</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20190123224845199.png" width="200px" height="100px"></p><h3 id="3-验证虚拟环境："><a href="#3-验证虚拟环境：" class="headerlink" title="3. 验证虚拟环境："></a>3. 验证虚拟环境：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.\Scripts\activate //激活虚拟环境         </span><br><span class="line">pip install --upgrade pip   //更新最新pip</span><br><span class="line">pip list                //展示venv中已安装的软件包</span><br><span class="line">deactivate  //退出虚拟环境</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20190123205942147.png" width="200px" height="100px"></p><h2 id="TensorFlow包"><a href="#TensorFlow包" class="headerlink" title="TensorFlow包"></a>TensorFlow包</h2><h3 id="1-可用版本"><a href="#1-可用版本" class="headerlink" title="1. 可用版本"></a>1. 可用版本</h3><p>&emsp;&emsp;可以用的tensorflow包及对应意义，本文使用第一个tensorflow版本：</p><ul><li>tensorflow：仅支持 CPU 的当前版本（建议新手使用）</li><li>tensorflow-gpu：支持 GPU 的当前版本（Ubuntu 和 Windows）</li><li>tf-nightly：仅支持 CPU 的每夜版（不稳定）</li><li>tf-nightly-gpu：支持 GPU 的每夜版（不稳定，Ubuntu 和 Windows）<h3 id="2-安装（比较久）"><a href="#2-安装（比较久）" class="headerlink" title="2. 安装（比较久）"></a>2. 安装（比较久）</h3>&emsp;&emsp;要安装很多依赖包，我安装等了1个多小时。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade tensorflow</span><br></pre></td></tr></table></figure></li></ul><p><img src="/img/tech/20190123230213177.png" width="200px" height="100px"><img src="/img/tech/20190123232454285.png" width="200px" height="100px"><img src="/img/tech/20190123234643182.png" width="200px" height="100px"></p><h3 id="3-验证安装"><a href="#3-验证安装" class="headerlink" title="3. 验证安装"></a>3. 验证安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import tensorflow as tf; tf.enable_eager_execution(); print(tf.reduce_sum(tf.random_normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20190123234809589.png" alt="在这里插入图片描述"></p><hr><h1 id="B-Ubuntu系统（16-04及以上）"><a href="#B-Ubuntu系统（16-04及以上）" class="headerlink" title="B. Ubuntu系统（16.04及以上）"></a>B. Ubuntu系统（16.04及以上）</h1><p>&emsp;&emsp;由于tensorflow对windows和ubuntu做了相对友好的支持，所以安装流程跟Windows中一样，只是写法上linux命令不同，这里不再多说。</p><h2 id="安装Python-amp-pip"><a href="#安装Python-amp-pip" class="headerlink" title="安装Python &amp; pip"></a>安装Python &amp; pip</h2><h2 id="安装virtualenv"><a href="#安装virtualenv" class="headerlink" title="安装virtualenv"></a>安装virtualenv</h2><p>&emsp;&emsp;这里启动执行可以用linux的source：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure></p><h2 id="安装TensorFlow包"><a href="#安装TensorFlow包" class="headerlink" title="安装TensorFlow包"></a>安装TensorFlow包</h2><hr><h1 id="C-弯路介绍"><a href="#C-弯路介绍" class="headerlink" title="C. 弯路介绍"></a>C. 弯路介绍</h1><h2 id="1-“找不到”错误（python版本问题）"><a href="#1-“找不到”错误（python版本问题）" class="headerlink" title="1. “找不到”错误（python版本问题）"></a>1. “找不到”错误（python版本问题）</h2><p>Could not find a versin that satisfies the requirement tensorflow ( from version:)<br>No matching distribution found for tensorflow<br><img src="/img/tech/20190123214412206.png" alt="在这里插入图片描述"></p><h2 id="2-搜索包可以找到"><a href="#2-搜索包可以找到" class="headerlink" title="2. 搜索包可以找到"></a>2. 搜索包可以找到</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip search tensorflow</span><br></pre></td></tr></table></figure><p><img src="/img/tech/20190123214609156.png" width="200px" height="100px"></p><h2 id="3-查看版本"><a href="#3-查看版本" class="headerlink" title="3. 查看版本"></a>3. 查看版本</h2><p>&ensp;&ensp;可能是python版本不对，tensorflow仅支持64位python，安装了32位python。tensorflow的系统要求如下：</p><ul><li>Ubuntu 16.04 或更高版本（64 位）</li><li>macOS 10.12.6 (Sierra) 或更高版本（64 位）（不支持 GPU）</li><li>Windows 7 或更高版本（64 位）（仅支持 Python 3）</li><li>Raspbian 9.0 或更高版本</li></ul><p><img src="/img/tech/20190123214914538.png" width="200px" height="100px"><img src="/img/tech/20190123214954654.png" width="200px" height="100px"><img src="/img/tech/20190123220318126.png" width="200px" height="100px"></p><h2 id="4-卸载重装python"><a href="#4-卸载重装python" class="headerlink" title="4. 卸载重装python"></a>4. 卸载重装python</h2><p>直接通过控制面板卸载了程序，然后移除了原版本的环境变量。若有安装文件，可以直接双击安装文件，选择其中的卸载选项。<br>然后在官网下载最新版本程序安装，然后重新创建virtualenv的虚拟环境（若原来版本着不需要）。<br><a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">https://www.python.org/downloads/windows/</a></p><p><img src="/img/tech/20190123215559264.png" width="200px" height="100px">&lt;img src=”/img/tech/2019012322314290.png width=200px height=50px /&gt;&lt;img src=”/img/tech/20190123221834255.png width=200px height=50px /&gt;</p><h2 id="5-仅可以-Python-3-4、3-5-或-3-6"><a href="#5-仅可以-Python-3-4、3-5-或-3-6" class="headerlink" title="5. 仅可以 Python 3.4、3.5 或 3.6"></a>5. 仅可以 Python 3.4、3.5 或 3.6</h2><p>发现还是报错，去官网看到目前还没有到3.7，仅支持3.6</p><p><img src="/img/tech/20190123234603459.png" width="200px" height="100px"><img src="/img/tech/20190123223952676.png" width="200px" height="100px"></p><h2 id="6-重新安装3-6版本"><a href="#6-重新安装3-6版本" class="headerlink" title="6. 重新安装3.6版本"></a>6. 重新安装3.6版本</h2><p><a href="https://www.python.org/ftp/python/3.6.5/python-3.6.5-amd64.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.6.5/python-3.6.5-amd64.exe</a></p><p><img src="/img/tech/20190123224212888.png" width="200px" height="100px"></p><h2 id="7-重新创建虚拟环境（同正文）"><a href="#7-重新创建虚拟环境（同正文）" class="headerlink" title="7. 重新创建虚拟环境（同正文）"></a>7. 重新创建虚拟环境（同正文）</h2><hr><h1 id="D-权限问题"><a href="#D-权限问题" class="headerlink" title="D. 权限问题"></a>D. 权限问题</h1><p>安装virtualenv时，提示拒绝访问，管理员权限打开终端即可。</p><p><img src="/img/tech/20190123223039611.png" width="200px" height="100px"><img src="/img/tech/2019012322332869.png" width="200px" height="100px"></p><p>参考自：<a href="https://tensorflow.google.cn/install/pip" target="_blank" rel="noopener">https://tensorflow.google.cn/install/pip</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> ai </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> virtualenv </tag>
            
            <tag> python </tag>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《活着》</title>
      <link href="/2019/01/21/books/%E6%B4%BB%E7%9D%80/"/>
      <url>/2019/01/21/books/%E6%B4%BB%E7%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;整本书通读下来，多次被作者带入了历史现场，跟随者作者的思路形成了一场场画面，为主角的遭遇和心境感动。<br>&emsp;&emsp;书中主人公名叫福贵，其一生的见闻，也是中国近代史演变的缩影，或者说个人经历见证了近现代历史事件的过程。<br>&emsp;&emsp;通过一个人的经历，反应了时代的变迁，反过来，也将历史的兴替也通过主人公的生活的变化进行以小见大。<br>&emsp;&emsp;也许福贵是幸福的，在历史的背景下，他没有选择，但从自身的生活看，他在一次次努力改善生活，也许外人看来他是生活经历了太多苦难，是不幸的，也许福贵从自己角度看他的内心始终充满希望，是幸福的。</p><h1 id="故事情节"><a href="#故事情节" class="headerlink" title="故事情节"></a>故事情节</h1><p>&emsp;&emsp;【父亲去世】开始福贵是地主家公子，好堵成性败了全部家产，赢钱的成了地主，把老爸气死了。<br>&emsp;&emsp;【母亲去世】作为佃户开始为地主做工，老婆被岳父接回娘家，儿子跟了岳父姓，后来儿子半岁时，老婆带着儿子回来了。然后被抓壮丁冲了军，国民党军队管理的混乱和腐败，被共产党军队打败后，给了盘缠回到家里，女儿因高烧成聋哑人，母亲在离开后半年郁郁而终。<br>&emsp;&emsp;【人民公社和大跃进】本以为平静的生活，因为村长收集砸碎了全村的铁锅充公创钢铁产量，全村牲口粮食集中，全村吃大锅饭，也就是大跃进时代的代表，映象深刻是水煮钢铁想，那个年代知识匮乏的见证，其实说愚昧不太公平。<br>&emsp;&emsp;【大饥荒】后来粮食吃完了，各家重新买新锅，各自找粮食，一家有生火造饭全村都会知道，然后来寻吃的，几个月没米，田里的野菜树皮树根都吃完了，就是大饥荒年代。<br>&emsp;&emsp;【儿子去世】好在还是坚持让小孩上学，不过县长老婆生小孩大出血，福贵儿子血型匹配就直接抽干，导致儿子去世，太残酷。<br>&emsp;&emsp;【女儿去世】后来女儿嫁给了一个歪脑袋的城里人，人叫二喜，实在厚道的搬运工，父母双亡。二喜对福贵两口子尊敬孝顺，日子过得开开心心，直到女儿怀孕了，在医院生产结果大出血没能救过来。<br>&emsp;&emsp;【文化大革命】期间也有15.16岁的红卫兵娃娃，一句走私派的帽子扣到队长头上，就可以随意带走年富力强的队长，就是文化大革命时期的验证。<br>&emsp;&emsp;【女婿、外孙去世】女儿生了个儿子保住了，福贵老婆起名叫苦根，表示一个苦命的人，二喜一次搬运意外被水泥板压死了，儿子从此跟着福贵了，一次苦根生病，福贵煮了豆子给外孙吃，太久没吃到好东西，不料被噎死了。<br>&emsp;&emsp;【福贵】最后只剩福贵自己一人，他后来买了头老牛帮自己耕田，老牛是在屠宰场看到，不忍心看到老牛不能耕田就被杀，买来一起相依为命，给老牛起跟自己一样的名字“福贵”。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>这是一部不错的具有历史题材的小说，推荐阅读。</li><li>从福贵的状态可以感受希望对生命的意义</li><li>也许活着才是最简单最基本的需求，也许正如俗话好死不如赖活着</li><li>生命的灿烂或者得意，也许都很短暂，不用太刻意</li><li>人生有起有落，得意时淡然，失意时坦然，一切都会过去</li></ol><center><img src="/img/books/活着.jpg" width="150" height="200" title="活着 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 活着 </tag>
            
            <tag> 历史题材小说 </tag>
            
            <tag> 近现代历史 </tag>
            
            <tag> 余华 </tag>
            
            <tag> 希望 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>self-不要提建议</title>
      <link href="/2019/01/21/self/%E4%B8%8D%E8%A6%81%E6%8F%90%E5%BB%BA%E8%AE%AE/"/>
      <url>/2019/01/21/self/%E4%B8%8D%E8%A6%81%E6%8F%90%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>&emsp;&emsp;最近小朋友吃奶粉过敏，自己考虑换个品牌试试，不过，家里人说还是先不要考虑换品牌，可以先考虑换个系列（之前吃澳新版的爱他美，打算换港版的爱他美试试），理由是小朋友不能随便换奶粉，有朋友推荐吃这个牌子的奶粉。<br>&emsp;&emsp;尽管朋友的推荐并没有什么利益关系，也是出于一片诚心进行答疑解惑，而且亲密的关系更为这种建议增加可信度，但是问题就出在建议本身不一定是客观理性的，也许这个不应该叫做建议，而应该成为资讯。<br>&emsp;&emsp;下面站在提出建议者的角度来解释下，为什么不要轻易提供建议，但可以提供资讯信息和个人经验。</p><h1 id="情景示例"><a href="#情景示例" class="headerlink" title="情景示例"></a>情景示例</h1><p>&emsp;&emsp;【不可以】考虑因素比较多或者目标不唯一的情况：有些事情是需要较多的考虑因素，而自己的经验或者知识，只对其中一部分有了解，甚至对其中关键的因素并不了解。以小朋友吃奶粉为例，奶粉的品牌和规格非常多，即使同一规格也会每个小朋友自身身体素质不同出现不一样的状态，没有哪个人可以自信的说，可以说出哪种奶粉最适合你家宝宝（如果有人打包票，有一个算一个都是诈骗），这个时候只能说自己在吃什么，吃过哪些有什么问题，只是提供资讯而不应该是建议，毕竟她自己并没有对所有品牌奶粉做过专业的对比，更没有对宝宝做过AB测试。如果想提供更多信息帮助朋友，可以帮助其查询相关资料，减少其调研的工作量，而不应该帮助朋友做决定，在有限信息的前提下做出选择是每个人的必修课，想想自己之前的选择是掌握了所有信息吗，一个人的视野和能力都是在有限的事物上寻找局部相对优的方案，即使知道所有信息也不一定可以选择到最优方案，因为人选择是受到情绪影响的，这就是人的非理性特性。<br>&emsp;&emsp;【可以】有固定模式达到目标的情况：有些事情是具有固定的流程和模式的，或者其选项是伸手可数的，比如去办理身份证或者补办证件，或者办理护照出国旅游等，其办理单位的办事流程和该项业务需要准备的材料是固定的，如果你有过办理相关手续和业务的经验，则传授自己的办事流程即为提供了有效信息。如果其中有些特别的注意事项，将该事项告知朋友即为提供了好的建议。<br>&emsp;&emsp;【可以】有多种方案达到目标的情况：有些事情是有一种或几种可行的方案和流程，而朋友的目标是完成目标，并不介意是否高效和走点弯路，这时候可以将自己走过的路告知朋友。比如，朋友目标是从深圳到达珠海，你只是做过高铁也不知道其它方案，那可以提供一个资讯就是可以做高铁绕广州过去珠海；而如果朋友的目标是最高性价比到达，则这个只是一个信息而不能构成建议了，毕竟还可以大巴直达，也可以轮渡直达，如果是建议做高铁，那就不仅是对朋友的误导，也是对自己信用的打折。<br>&emsp;&emsp;【可以】需要推一把的情况：有些事情的前提和目标都比较明确，朋友也许已经有了答案，除非有什么惊天大消息，否则常规对于大家都知道的信息，不论你说什么对方都会那么做，只是需要一个确定的答复来推自己一把。比如，对方想参加成人高考，但总感觉太难了，问你要不要报名。既然对方提出了这个疑问，那一定做过相对详细的调研，只是需要一颗定心丸，只需要大方给出即可。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;大多数人都有惰性，希望别人帮自己做决定，一方面不想思考或自己调研，或者说减少自己走的弯路，另一方面可能不愿意承担责任，所以总会希望别人给自己指出一条明路，但事实上，没有人比你自己更适合拿主意。由于没有平行时空的证据，所以无法进行AB对比，一个选择也没人可以说是对还是错，因为只有这一种是被实现了的，其它都是纸上谈兵。</p><ol><li>除非对方明确提出需要建议，否则不要轻易给自己的建议</li><li>生活中大部分情况是第一种（考虑因素比较多或者目标不唯一），最好只是提供资讯而不是建议</li><li>如果要给建议，重点强调自己建议的逻辑和理由，而不是只给结果</li><li>读书是最快捷的进步方式，听人建议也是，也是一种知识的传承，但基于知识还要根据自身情况思考才能形成智慧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建议 </tag>
            
            <tag> 别轻信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6年保险从业者告诉你，关于保险你应该知道的一些事</title>
      <link href="/2019/01/18/life/life-%E5%A9%B7%E4%BF%9D%E9%99%A9%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/18/life/life-%E5%A9%B7%E4%BF%9D%E9%99%A9%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本人在金融行业摸爬滚打有6年时间了，各类金融产品平日接触很多，对于保险，也简单聊聊自己的想法吧。<br>&emsp;&emsp;90年代，大家对保险更多的是一种嫌弃逃避的想法，认为那些风险事件不会发生在自己身上，所以对保险都是避而远之；而发展到今天，随着国家对保险的教育普及，很多人逐渐接受了保险这个事物，也开始为自己及家人购买保险。但如果问及，您现在持有哪些保险产品？这些产品都会为你规避哪些风险？这些产品是在你目前资金有限的情况下最需要配置的吗？很多人都会哑口无言。<br>&emsp;&emsp;今天，我就跟大家聊聊普通的小康之家，在购买保险的时候，需要注意的点吧：</p><h1 id="最应该买保险的是家庭里赚钱的人"><a href="#最应该买保险的是家庭里赚钱的人" class="headerlink" title="最应该买保险的是家庭里赚钱的人"></a>最应该买保险的是家庭里赚钱的人</h1><p>&emsp;&emsp;很多家庭想要买保险时，第一个会想到的是给自己的未成年子女购买，就像平日省吃俭用，也要给自己子女最好的。但其实，保险这东西，并不应该如此。<br>&emsp;&emsp;给小孩买保险并没错，但在一个家庭里，赚钱、还房贷车贷、子女抚养、赡养老人…这些种种，都是要靠家庭里赚钱的人，而不是未成年子女。试想有一天，万一家里赚钱的人遭到意外突然离世又或是身患重疾，那家庭的收入便会急剧下降甚至丧失收入来源，生活可能无法继续维持下去。而这个时候，给小孩买了再好的保险又有什么用？<br>&emsp;&emsp;买保险，是为了万一风险事件发生时，不至于让整个家庭突然间垮掉，想在风雪中为不幸的家庭送点碳的。一个家庭里谁在赚钱，就更应该给谁买，谁赚的钱越多，谁买的份额就应该越多。</p><h1 id="意外险——医疗险——重疾险——年金险——寿险"><a href="#意外险——医疗险——重疾险——年金险——寿险" class="headerlink" title="意外险——医疗险——重疾险——年金险——寿险"></a>意外险——医疗险——重疾险——年金险——寿险</h1><p>&emsp;&emsp;这是一个在资金有限的情况下，一个家庭最需要购买保险的顺序。</p><h2 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外险</h2><p>&emsp;&emsp;有一句话叫，谁也不知道是明天先来还是意外先来，意外这种东西，谁也预估不了，谁也不知道会不会发生在自己身上。既然无法预测，那为什么不用较少的保险金去把这个风险规避掉呢？目前市面上的意外险也非常便宜，1000来块一年，交5年，就可以保障100万了，满期没有发生意外事故还可以返还所交的钱，相当于用利息来买了一份100万的保障，何乐而不为呢？</p><h2 id="医疗险"><a href="#医疗险" class="headerlink" title="医疗险"></a>医疗险</h2><p>&emsp;&emsp;现在的医院，是一只会吃钱的怪兽，一个小感冒，也有可能要让你没了两套房，各种新闻报道的医疗费高昂的事件，我就不一一赘述了，相信很多朋友偶尔去医院看病一趟，都会深有感受的。医疗险是近几年来相对热门的险种，以前我们大多只有国家医保，但近年来随着医疗水平的不断提高，很多时候大病不是能不能把你救活的问题，而且你能有多少钱就能让你活多久的问题了。没病的时候买个医疗险，30岁左右的成年人500元左右/年，万一有个啥病要住院，找保险公司报销就好了，你只管安心养病，什么药管用就用什么药，不用担心钱的问题。相对比高昂的医疗费用，几百元甚至几千元一年，算什么。但医疗险购买的前提，是要在没病的时候才能购买，有病就买不了了。</p><h2 id="重疾险"><a href="#重疾险" class="headerlink" title="重疾险"></a>重疾险</h2><p>&emsp;&emsp;大病往往会带来超级高昂的医疗费用，再加上带病长时间的无法工作，没有了经济来源，日常生活也会有影响，除了配置了医疗险可以让保险公司帮你报销医疗费用之外，你日常的生活也要用钱，而这，就需要购买重疾险来一次性给你一笔费用，让你有钱来垫支医疗费，加强营养等。重疾险越年轻买越便宜，女性比男性便宜。30岁男性为例，一般20万的保额，20年交，保险费大概5000元/年。</p><h2 id="年金险和寿险"><a href="#年金险和寿险" class="headerlink" title="年金险和寿险"></a>年金险和寿险</h2><p>&emsp;&emsp;我认为是有闲钱的时候可以买，没有闲钱的话，配置以上三种保险基本就可以了。</p><h3 id="年金险"><a href="#年金险" class="headerlink" title="年金险"></a>年金险</h3><p>&emsp;&emsp;就是你现在有钱，每年固定存一笔钱到保险公司，以后老了，再从保险公司每年取一些钱来用，而这些钱，你可以规划为养老金、小孩的教育金等等都可以。</p><h3 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h3><p>&emsp;&emsp;说白了，就是死了就能赔的保险，分定期寿险和终身寿险两种。对于一般小康家庭，在有条件的情况下，可以购买一点点定期寿险，以防家庭主要支柱的离去给家庭带来的损失。而终身寿险，一般是富人用来传承的工具。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保险 </tag>
            
            <tag> 婷 </tag>
            
            <tag> 意外险 </tag>
            
            <tag> 医疗险 </tag>
            
            <tag> 重疾险 </tag>
            
            <tag> 年金险 </tag>
            
            <tag> 寿险 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一日之计在于晨，晨跑带来的不止是健康，还有乐观积极的人生态度</title>
      <link href="/2019/01/18/life/life-%E4%BF%8A%E6%99%A8%E8%B7%91/"/>
      <url>/2019/01/18/life/life-%E4%BF%8A%E6%99%A8%E8%B7%91/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;时光飞逝，不知不觉间一周的晨跑就这样结束了，犹如梦境一般，让我觉得这几天是多么的不真实，但他却是真真切切发生过的，是我亲身经历过的。<br>&emsp;&emsp;五点半开始的晨跑，天还是黑漆漆的，月亮依然清澈透明，睡意朦胧的我就这样伴随着夜深的宁静来到了田径场上，一丝丝的凉风就这样不断的轻抚着我的面庞，吹动着我的衣裳，使我忍不住打了个寒战清醒了几分。我和我的几个小伙伴们在那静静的等候，不久便听到了话语声，影影约约的看到三三两两的身影朝这边走来，使我感到这里终于有了点氛围，不再像开头那样那么的冷清如同世界只有我们几人还存活着。渐渐的黑影成团，七嘴八舌的话语声中不知从哪来了一句党务小组集合，让我们的话语声渐渐的停息了，团学会的、我们党务的都闻声而去，来到师兄师姐面前。等待我们一周的晨跑就这样悄无声息的打响了。<br>&emsp;&emsp;晨跑会是我们在大学一次最重要的经历，这不仅是一次锻炼，还是我们的一次成长，每个清晨在跑步的途中，看到太阳渐渐升起，天一点一点的变亮，心中很有感触，很有成就感，跑步时间很短，但带来的却是一天的清醒，这使得我一天都充满了干劲。在晨跑中我看到了大家的团结，看到了大家的活力，大家都在展现自己的青春。<br>&emsp;&emsp;在晨跑中，每天都有不一样的期待，每天都有不一样的收获。晨跑让我们这个团队变得更加的团结，更加的和谐，更让彼此之间更加的友爱。晨跑让大家找回了集体的感觉，给大家带来了很多欢乐，让大家在寒冷中释放自己的热情，让大家学会了温暖别人。这些天的点点滴滴都会成为大家美好的回忆，成为大家在大学中不可磨灭的一部分。晨跑让大家更加懂得时间的宝贵，也让大家更加懂得珍惜时间，让大家学会了尊重和理解。<br>&emsp;&emsp;在晨跑之前大家都不是很熟悉，彼此之间也都比较陌生，相互话也很少，但自从晨跑开始之后大家的话渐渐多了起来，不再像之前那样默默无语，非常的拘谨，特别是在玩游戏的时候，大家的气氛变得更加的融洽，这也说明了一个晨跑的好处:促进大家沟通、调节气氛、使大家变得更加团结。<br>&emsp;&emsp;玩游戏永远都是最让人愉悦的，也是最能、最快让大家打成一片的。那个数字游戏令我印象最为深刻，再加上师兄话语中内含乾坤、另有玄机，常常使得我们一不留神反应就会慢半拍，以至于没有迅速的抱在一起。当然我们也有一点小小的惩罚，比如原地捏着鼻子转圈后走直线、到对面的阵容里喊话等等。这游戏使得我们其乐融融，欢笑不已，让我们非常迅速的打成一片。<br>&emsp;&emsp;晨跑中我们并不会跑的太快当然也不会跑的过慢，跟着师兄的步伐，大家排面整齐、步伐一致，凸显出我们就是一个整体。超越梦想，追求希望，团结一心，党务最棒。简简单单的十六个字，就已表达出了我们内心的想法、感悟，凸显出我们党务的精神。羽泉的《奔跑》这一首歌，伴随着我们的阵容、步伐在田径场上徘徊着，在我们的口中唱响着，速度七十迈，心情是自由自在，希望终点是爱琴海，全力奔跑梦在彼岸…。<br>&emsp;&emsp;坚持，是一种态度，是大家必有而又难得珍存的一种态度。在晨跑的日子里，我学会了坚持，不在半路退缩，不半途而废。即使再苦再累我也咬牙坚持下来，或许这最后不一定能成为成功者，但那些失败者，就是他们并不知道自己已经多么接近成功，却放弃了努力，唯有那些能够坚持不懈的人才能品尝到甜美的果实。在每天五点半的集合下，很多时候我都想过不起床不去跑步，甚至想过退出,但我坚持了下来，因为部门每位干事都在坚持,每个人都是那么早的去集合包括师兄师姐,所以我的心里就一直给自己打气说着我可以我行的，我可以和大家一样,就这样我一直坚持着。<br>&emsp;&emsp;晨跑的日子虽然只进行了短短的一周，但却让我学到了许多东西，有许多的收获，让我们从一个互不相识的集体里面变成了团结友爱的大家庭，让我们彼此更加的融洽，晨跑真的让我们受益匪浅，深深地烙印在了我的记忆里面。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 所思所察 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿俊 </tag>
            
            <tag> 晨跑 </tag>
            
            <tag> 跑步 </tag>
            
            <tag> 奔跑 </tag>
            
            <tag> 大学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《月亮与六便士》</title>
      <link href="/2019/01/17/books/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/"/>
      <url>/2019/01/17/books/%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h1><p>&emsp;&emsp;这是半年来读到让自己最舒服的一本书，句子表达上简单平淡，偶尔也会让人回味琢磨，故事情节上循序渐进，站在旁观者的角度陈述自己的见闻，内容和情绪上不夸张修辞，也没有矫揉造作，看完却被一种精神感染。<br>&emsp;&emsp;去年一种说走就走的旅行流行了一段时间，连邓超为携程的广告语都是“携程在手，说走就走”，不过，如果把这事做到极致，不知是不是就是小说主角的做法，放弃所有现在的生活去追求自己心里的梦。<br>&emsp;&emsp;回想本书的书名“月亮与六便士”，也许月亮就是代表梦想和美，而六便士则象征金钱和现实。一个人的选择很难从一个极端走向两一个极端，大多数人都是在两者之间寻找一个平衡，只是不同人的选择距离两端的距离不同。</p><h1 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h1><p>&emsp;&emsp;书中讲述了一位大半辈子生活在伦敦的股票交易员，在外人看来日子过的平淡幸福，有老婆和一双儿女，老婆喜欢社交，儿女乖巧符合正常价值观。<br>&emsp;&emsp;有一天，主角忽然放弃所有到了巴黎，开始追随自己的理想去画画，在巴黎没收入日子过得有上顿没下顿，住在破旧邋遢的屋子。有位画家非常欣赏他的才能，有次差点病死在自己家中，那位画家就把他接到了自己家，后来那位画家的妻子跟着主角走了，后来受不了主角自杀了。再后来主角去到一些欧洲的海边和岛上流浪，然后跟一位本地姑娘结婚后隐居在山中，最后病死在山里的木屋里，最终在房屋内完成了巨作。<br>&emsp;&emsp;主角生前画作不被认可，几乎没真正卖出去过一幅，但死后几乎所有作品都价值连城，被人通过各种渠道寻找生前画作，也有作家找到他伦敦的老婆采访之前的故事。</p><h1 id="喜欢句子摘抄"><a href="#喜欢句子摘抄" class="headerlink" title="喜欢句子摘抄"></a>喜欢句子摘抄</h1><ul><li>我们很珍视我们对那些在乎我们对他们看法的人的影响力，讨厌那些我们对其没有这种影响力的人。</li><li>与人打交道时，他只给你一个希望世人接受的表面，你只能通过他无意中做的某个小动作以及某人掠过他脸上的某个他不经意的表情才能对他有一个真实的认识。</li><li>有时候，人们把面具带的完美无缺了，真的会变成他们说装扮的那个人。</li><li>在这个世界上，完美每个人都是孤独的，每个人都被关在一座铜塔之中，只能靠符号与他人交流，而这些符号并没有共同的价值，因此它们的意义是模糊的、不确定的。</li><li>我觉得有些人生错了地方，命运将他们扔到了某种环境中，但他们心中始终怀着一种连他们自己也不知道的乡愁。他们在他们的出生地是外乡客，从小变熟识的林荫小道或者玩耍过的喧闹的大街始终只是一条过道。</li><li>有时候，一个人会偶然碰到某个让他莫名觉得他应该归属的地方，这里便是他寻找的故园，他会在那些他从未见过的风景中生活下来，和他不认识的人相处，就好像他从出身之际就熟悉了这一切。在这里，他终于找到了平静。</li><li>这个世界充满了做怪事的怪人，或许一个人现在的样子并不是他想要的，而是不得不这样。</li><li>上帝的磨坊磨得很慢，却磨的很细。</li></ul><center><img src="/img/books/月亮与六便士.jpg" width="150" height="200" title="月亮与六便士 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 月亮与六便士 </tag>
            
            <tag> 追随自己内心 </tag>
            
            <tag> 梦想 </tag>
            
            <tag> 金钱 </tag>
            
            <tag> 现实 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老人、保姆还是自己带宝宝</title>
      <link href="/2019/01/15/baby/%E8%B0%81%E5%B8%A6%E5%AE%9D%E5%AE%9D/"/>
      <url>/2019/01/15/baby/%E8%B0%81%E5%B8%A6%E5%AE%9D%E5%AE%9D/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;由于历史原因，我国有一种老人帮忙带小孩的习惯或传统，很多年轻人有了孩子后，会让一方父母或双方父母轮流帮忙带，本文说一下老人（外公外婆、爷爷奶奶）帮忙带小孩的一些思考，可以在评论区说说你的看法。<br>&emsp;&emsp;俗话说，一样的米养百的样人，即使同样的情况发生在不同的家庭中，也会出现不一样的结果，因此本文只是就事情本身说一些自己的理解，并对搜集的素材进行梳理，不一定所有人会有完全一致的结果，其实有时同样的事可能导致完全相反的两种结果。</p><h1 id="支持老人带"><a href="#支持老人带" class="headerlink" title="支持老人带"></a>支持老人带</h1><p>&emsp;&emsp;本人是从农村出来的，在农村邻里乡亲大多都是让老人带小孩，其实在农村本身对小孩的教育相对来说没城市里那么重视；不过，其实城市中，也不少人选择让父母帮忙带；另外，自己身边也有不少朋友，是孤身在城市打拼，让自己父母过来城市帮助自己带小孩，比如有名的“老漂族”。关于让老人带的一些想法和思考，有这几方面：</p><ol><li>自己没有时间带。这两天看新闻，自己宝宝生病了，但妈妈无法请假回家照顾，大意是说要陪你就无法赚钱养你，要赚钱就无法时刻陪着你。听起来挺心酸，但确实生活中城市中青年人真实的生活写照，如果没有全职带宝宝，确实不太可能每天陪着。</li><li>自己没有精力带。小孩需要陪伴，尤其上学之前的小朋友，除了睡觉时间都需要有人陪着，尤其刚出生婴儿晚上也在哭闹，全程照顾会导致自己晚上休息不好，第二天影响工作状态。如果只是一两周还可以克服，但长达半年或一年则可能会让自己丢掉工作。</li><li>让父母有事可做。父母退休在家里闲来无事，需要做一些事情，刚好娃需要有人花时间和精力带；而且父母自己也没有什么生活奔头，有了带娃作为日常事务，生活有明确的目标和奔头，正所谓人是需要意义的，或者说需要“被需要的感觉”的。</li><li>不放心保姆带。新闻上已经报出很多保姆虐待小孩的事件了，虽然这种情况相对是少数，但这样的案例已经在大家心中生根发芽，观念的转变还需要一定时间的改变，加上自己对宝宝的宠爱，并不放心交给陌生人。</li><li>生活成本高，不能全职带娃。在城市中生活的工薪阶层，需要面对的不止是自己日常的柴米油盐，还有宝宝的衣食住行和教育医疗，只是自己简单点甚至委屈点都可以接受，但父母都希望自己宝宝拥有条件内最好的。</li></ol><h1 id="支持自己带"><a href="#支持自己带" class="headerlink" title="支持自己带"></a>支持自己带</h1><p>&emsp;&emsp;不论在城市里还是农村，都有自己带小孩的案例，但相对来讲确实是少数，自己身边也有自己带小孩的朋友，有家庭条件优越的选择保姆进行照顾的，也有经济拮据的选择将小孩送去托儿所等机构的，有为了小孩的未来教育主动选择的全职在家带小孩的宝妈，也有被迫无奈选择离职在家带小孩的妈妈，其实这几类情况自己身边都有。关于自己带的一些想法和思考，有这几方面：</p><ol><li>老人年纪大了。很多老人当爷爷奶奶时，基本上已经近60了，身体状况一直在走下坡路，很多老人都有力不从心的感觉，照顾孩子太累，也很有压力，在本该颐养天年的年龄承受了太多压力，很容易产生心理问题。</li><li>跟老人的价值观不同。每一辈人的成长环境、所受的教育都是不同的，育儿理念也会有所区别。这也是时代造就的，做子女的有时会埋怨和嫌弃，因此而寒了老人家的心，最终产生家庭摩擦和矛盾。</li><li>老人会溺爱孩子。老人通常见不得宝宝哭闹，有什么要求只要哭闹立马满足，而且经常什么事情都替孩子或帮忙处理，时间长了就养成了娇生惯养或刁蛮任性、依赖性强或生活自理能力弱等坏习惯。</li><li>可以更好的促进亲子关系。自己带就会让孩子天天陪在身边，孩子平时受到了各方面的照顾，就会更依赖和信任自己。如果让老人带，自己就会错过很多孩子成长的瞬间，等到孩子长大后，再后悔也于事无补了。</li><li>老人更自由。老人已经为家里付出了一生，需要自己管理时间享受生活，可以培养自己的爱好和圈子。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 带宝宝 </tag>
            
            <tag> 老人带 </tag>
            
            <tag> 自己带 </tag>
            
            <tag> 保姆带 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老人带宝宝给钱吗</title>
      <link href="/2019/01/15/baby/%E8%80%81%E4%BA%BA%E5%B8%A6%E7%BB%99%E9%92%B1%E5%90%97/"/>
      <url>/2019/01/15/baby/%E8%80%81%E4%BA%BA%E5%B8%A6%E7%BB%99%E9%92%B1%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p> &emsp;&emsp;相信目前绝大多数人还是选择了让老人（一方父母或双方父母轮流）帮忙，那关于是否给老人钱有很多种说法，对比来看给钱的方案相对关系更容易处理，钱不在于多少而是在于有无，主要有以下几个维度进行分析，可以在评论区说说你的看法。</p><h1 id="给"><a href="#给" class="headerlink" title="给"></a>给</h1><ol><li>带小孩不是老人的义务。抚养子女是自己的义务，老人的义务是抚养他们自己的子女（自己），并没有义务和责任来照顾孙子孙女。老人辛苦把自己拉扯大，也该退休享清福了，可是还得为自己带小孩，给钱就当作是劳动的报酬。</li><li>这是自己态度的体现。即使父母自身的经济实力强过自己太多，从经济能力角度完全不用给，但自己力所能及的付出一些金钱，表达了自己对父母的感激，而不是把这件事当作是父母理所应当的义务。</li><li>一份心意融洽婆媳关系。一方面，有的婆婆认为带自己孙子孙女是应该的，儿子媳妇给钱后，会认为孝顺自己，更容易减少婆媳之间摩擦，婆婆对儿媳的眼神里会有更多的包容和关爱；另一方面，大多婆婆也会以其它方式将钱给回儿子媳妇，比如过年给孙子孙女包个大红包，看着钱只是走了一圈，但却巩固了相互连接的纽带。<h1 id="不给"><a href="#不给" class="headerlink" title="不给"></a>不给</h1></li><li>老人拿着钱也没什么用。一方面，老人自己没什么地方需要用钱，给钱也是存在银行，还不如自己管理的收益高，老人需要花钱的时候找自己要；另一方面，现在骗子也多，老人比较容易被各种保健品或按摩椅的广告营销，买来一堆没用的产品。</li><li>父母不要自己给的钱。一方面，父母担心儿女在城市生活成本高，刚生小孩后开支又增加，不愿意再增加自己的负担，甚至会自掏腰包补贴自己突增的开支；另一方面，有的父母不想收钱后，让自己感觉是为儿女工作，只是希望基于感情自己在照顾孙子孙女。</li><li><p>具体金额不好把握。一方面，钱给的多了自己负担重，毕竟现在年轻人除了要管自己一家人现在所有开销，还要为小孩未来教育和老人的养老治病做些储备；另一方面，给的少了担心父母有意见，以为自己给点钱就想把责任撇清，或者说对老人的不尊重。</p><p>&emsp;&emsp;给或不给，没有绝对的对与错，也没有一个标准的答案，不过，懂得感恩父母是一种美德，不论是给钱，还是平时送礼物，或者经常嘘寒问暖，都可以表达对老人的感谢和尊重。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 老人 </tag>
            
            <tag> 父母 </tag>
            
            <tag> 带小孩 </tag>
            
            <tag> 给钱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《乌合之众》</title>
      <link href="/2019/01/14/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/"/>
      <url>/2019/01/14/books/%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读感受"><a href="#阅读感受" class="headerlink" title="阅读感受"></a>阅读感受</h1><p>&emsp;&emsp;这本书对大众心理学做了个探索和设想，通读完整本书，感觉作者在表达上不是特别易懂，也许语言表达之间的逻辑关系所致，本书是从法语原著翻译过来的，书中内容和观点其实算精彩，主要将群体的非理性特点以及作者的思考，如果想了解一些关于群体如何被影响方面的内容，本书可以作为读物开阔思维。<br>&emsp;&emsp;如果有其它可以选择的译本，可以优先选择别人的译作，如果只是想快速通读了解其中内容，这不建议读我选择的这本。翻译者（赵丽慧）在句子的表达上读起来有点生涩，估计是大多直译了原作者的话语，但不同语言的表达习惯和思维方式本来不太一样，所以看起来会不太习惯。主要有三点：</p><ol><li>句子经常太长，一句话经常反复读几遍才能知道在说什么。</li><li>句子之间的逻辑关系经常比较混乱，不像译者自己理解之后的翻译。</li><li>句子本身很多地方的用词感觉不太好理解。</li></ol><h1 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h1><p>&emsp;&emsp;书中分三章，标题是分别是1.群体心理；2.群体的意见与信念；3.不同群体的分类及其特点。书中观点不一定对，但作者也并非进行断言，是基于一些确切的历史事实，提供了一种设想和分析角度</p><ol><li>第一章，主要从概念和观点层面描述群体的心里特征和行为模式，描述一群人在一起后形成的一般特征，主要体现在情绪和感性能力的提升，以及对立的判断力和理性能力的降低。</li><li>第二章，主要从多个维度描述影响群体的观点的行为，首先在群体内传播的高效方式是图像而非逻辑，其次使用跟群体接近的传统观念、制度、教育等背景更容易进入大众内心，最后在表达上使用简短有力的惯用语而非冗长的词语更容易有感染力。</li><li>第三章，主要针对不同类型群体的属性进行针对性的描述，分别对法庭陪审团，议会选民等群体的背景和行为现象进行了展示，有个观点挺有意思，就是演讲者的可信度通常在于其个人的威望，而非内容本身的可信度和逻辑性。</li></ol><h1 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h1><ol><li>若对大众心理学有兴趣，本书值得一读。</li><li>若是想学习控制大众心理的技巧，就不建议读了</li><li>可以作为开阔视野的素材快速翻阅</li><li>当前译者（赵丽慧）表达生涩，建议选择其它译者的书</li></ol><center><img src="/img/books/乌合之众.jpg" width="150" height="200" title="乌合之众 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乌合之众 </tag>
            
            <tag> 大众心理 </tag>
            
            <tag> 群体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝哭怎么办</title>
      <link href="/2019/01/11/baby/%E5%93%AD%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>/2019/01/11/baby/%E5%93%AD%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;哭是新生儿与外界沟通的唯一方式，不像大孩子一般是由于伤痛或伤心而哭，新生儿哭的含义要广泛的多，妈妈们学习分析宝宝的哭也算是一个“必修课”吧。</p><h1 id="病理原因"><a href="#病理原因" class="headerlink" title="病理原因"></a>病理原因</h1><p>&emsp;&emsp;如果因生病而哭闹，就不难发现宝宝还伴随着其他症状和体征，检查下身体各部位有没有异常，发现异常需要尽快就医诊治。</p><h2 id="1-身上有异样"><a href="#1-身上有异样" class="headerlink" title="1. 身上有异样"></a>1. 身上有异样</h2><ol><li>宝宝是不是出疹子了？</li><li>打预防针的地方是不是有红肿现象。</li><li>有没有被蚊虫叮咬。</li><li>脐部是否发炎</li><li>臀部是否有尿布疹</li><li>身上是否有小脓疱</li><li>四肢运动是否异常</li></ol><h2 id="2-可能腹胀"><a href="#2-可能腹胀" class="headerlink" title="2. 可能腹胀"></a>2. 可能腹胀</h2><ol><li>来得突然，第一声又长又响，之后屏息，接着大哭。</li><li>摸摸小肚子是不是硬邦邦的，可能消化不良引起。</li><li>可以吃一些助消化的药物。</li></ol><h1 id="生理原因"><a href="#生理原因" class="headerlink" title="生理原因"></a>生理原因</h1><h2 id="1-饿了"><a href="#1-饿了" class="headerlink" title="1. 饿了"></a>1. 饿了</h2><ol><li>哭声短而有力，比较有规律，渐渐急促。</li><li>3～4个小时需要喂奶一次，间隔时间不能太久。</li><li>经常性1～2小时就哭闹，有可能是一次性奶量不够。</li></ol><h2 id="2-拉屎撒尿"><a href="#2-拉屎撒尿" class="headerlink" title="2. 拉屎撒尿"></a>2. 拉屎撒尿</h2><ol><li>如果纸尿裤太沉，宝宝会很不舒服的。</li><li>如果有红屁股的现象，抹点护臀霜。</li><li>衣裤如果湿了，一定要及时更换。</li></ol><h2 id="3-呼吸不畅"><a href="#3-呼吸不畅" class="headerlink" title="3. 呼吸不畅"></a>3. 呼吸不畅</h2><ol><li>宝宝鼻子堵塞，需要清理。</li><li>宝宝吃完有嗝打不出，需要拍嗝。</li><li>可以借助小工具，比如小棉签，吸鼻器等。</li></ol><h2 id="4-情绪宣泄（交流）"><a href="#4-情绪宣泄（交流）" class="headerlink" title="4. 情绪宣泄（交流）"></a>4. 情绪宣泄（交流）</h2><ol><li>几声缓慢而拖长的哭声打头阵，声音较低发自喉咙。</li><li>经常陪宝宝玩耍，消除他的寂寞感。</li><li>一般情况下，抱起来就没事了。</li></ol><h2 id="5-想睡觉"><a href="#5-想睡觉" class="headerlink" title="5. 想睡觉"></a>5. 想睡觉</h2><ol><li>想睡觉睡不着</li><li>让他做一些缓慢的或有节奏的运动。</li><li>讲一些抚慰的话帮助他放松或让他睡觉。</li></ol><h2 id="6-穿的太多或太少"><a href="#6-穿的太多或太少" class="headerlink" title="6. 穿的太多或太少"></a>6. 穿的太多或太少</h2><ol><li>要根据室内的温度及时给宝宝增减衣物。</li><li>太多或太少都会让宝宝感到不适。</li><li>原则上宝宝的衣服和大人同步即可。</li></ol><h2 id="7-接种完疫苗"><a href="#7-接种完疫苗" class="headerlink" title="7. 接种完疫苗"></a>7. 接种完疫苗</h2><ol><li>部分疫苗接种后宝宝会长时间甚至持续整晚哭闹，正常情况，安慰下过两天就好了</li><li>刚出生时候的<a href="https://blog.csdn.net/suoxd123/article/details/86025363" target="_blank" rel="noopener">卡介疫苗</a>可能哭闹整晚</li><li>自费的<a href="https://blog.csdn.net/suoxd123/article/details/86029495" target="_blank" rel="noopener">13价肺炎疫苗</a>晚上哭的撕心裂肺<h1 id="常见哭声分类"><a href="#常见哭声分类" class="headerlink" title="常见哭声分类"></a>常见哭声分类</h1><h2 id="1-健康的哭声"><a href="#1-健康的哭声" class="headerlink" title="1. 健康的哭声"></a>1. 健康的哭声</h2>&emsp;&emsp;宝宝啼哭的声扬顿挫，不刺耳，响亮有节奏而且无泪，这种哭声每天正常4-5次，没有任何不良症状，不影响睡眠、吃饭、睡眠，而且每次哭时较短，如果这时候妈妈用手轻轻地触摸或者朝着宝宝说说话笑一下，还可以将宝宝的小手放在胸前轻轻摇两下就会停止啼哭。<h2 id="2-饥饿的哭声"><a href="#2-饥饿的哭声" class="headerlink" title="2. 饥饿的哭声"></a>2. 饥饿的哭声</h2>&emsp;&emsp;当宝宝出现饥饿的时候，他的哭声带有乞求，由小变大，很有节奏，不急不躁，当妈妈把手放在他的脸颊或者嘴巴附近，宝宝会做出吸允的动作，如果此时妈妈的手离开，宝宝就会大发脾气，哭声更加厉害，一旦给宝宝喂奶后，这种哭声会立刻停止，当宝宝吃饱后就会漏出笑容。 <h2 id="3-积食的哭声"><a href="#3-积食的哭声" class="headerlink" title="3. 积食的哭声"></a>3. 积食的哭声</h2>&emsp;&emsp;如果宝宝出现哭声尖锐，两腿屈曲乱蹬，嘴角有出现吐奶，那肯定是积食了，这时候需要妈妈把宝宝腹部贴住妈妈的胸部抱起来，如果宝宝哭声加重，甚至出现呕吐，妈妈先不要哄宝宝，哭可以加快消化，但妈妈要注意宝宝溢奶。<h2 id="4-口渴的哭声"><a href="#4-口渴的哭声" class="headerlink" title="4. 口渴的哭声"></a>4. 口渴的哭声</h2>&emsp;&emsp;宝宝口渴时会表现出不耐烦的感觉，嘴唇比较干燥，宝宝还会时长伸舌头，舔嘴唇，但妈妈把水瓶放在宝宝嘴巴里的时候，宝宝哭声立刻停止。<h2 id="5-尿湿的哭声"><a href="#5-尿湿的哭声" class="headerlink" title="5. 尿湿的哭声"></a>5. 尿湿的哭声</h2>&emsp;&emsp;一般宝宝尿湿裤子或者尿布时，哭声比较轻无泪，这种哭声大多都是宝宝睡醒或吃奶后，一边哭一边还会双腿蹬被，当妈妈或者爸爸给宝宝换一块干净的，哭声立刻停止。<h2 id="6-燥热的哭声"><a href="#6-燥热的哭声" class="headerlink" title="6. 燥热的哭声"></a>6. 燥热的哭声</h2>&emsp;&emsp;当宝宝感觉非常燥热的时候，哭声很大，而且四肢舞动，颈部有汗，这时如果妈妈或者爸爸减少一下衣服或者被子，宝宝体验到凉爽后，宝宝就会立刻停止啼哭<h2 id="7-犯困的哭声"><a href="#7-犯困的哭声" class="headerlink" title="7. 犯困的哭声"></a>7. 犯困的哭声</h2>&emsp;&emsp;宝宝犯困哭声呈阵发性，很不耐烦的嗷嗷大叫，这时候家里人多，声音嘈杂，空气又不流畅，宝宝的哭声会越发厉害，如果此时给宝宝安排一个舒适又安静的环境，宝宝会停止哭泣，安然入睡。<h2 id="8-害怕的哭声"><a href="#8-害怕的哭声" class="headerlink" title="8. 害怕的哭声"></a>8. 害怕的哭声</h2>&emsp;&emsp;当宝宝出现害怕的时候，他的哭声突然发作，刺耳，伴有间断性号叫， 特别是有的宝宝害怕黑暗、害怕噪音、害怕小动物、害怕打针吃药等等，如果 宝宝突如其来的出现哭啼，家长一定要细心地安抚宝宝恐惧心里，想方设法的打破宝宝的恐惧心。　　</li></ol><hr><p>参考自：<br><a href="https://www.mmbang.com/ask/q1900341" target="_blank" rel="noopener">https://www.mmbang.com/ask/q1900341</a><br><a href="https://baobao.baidu.com/article/52b10309669be90cde873b6856d3aabb.html" target="_blank" rel="noopener">https://baobao.baidu.com/article/52b10309669be90cde873b6856d3aabb.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哭闹 </tag>
            
            <tag> 生理 </tag>
            
            <tag> 病理 </tag>
            
            <tag> 哭的原因 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝怎么吃维生素</title>
      <link href="/2019/01/11/baby/%E7%BB%B4%E7%94%9F%E7%B4%A0/"/>
      <url>/2019/01/11/baby/%E7%BB%B4%E7%94%9F%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="维生素AD代替鱼肝油"><a href="#维生素AD代替鱼肝油" class="headerlink" title="维生素AD代替鱼肝油"></a>维生素AD代替鱼肝油</h1><p>前面一篇文章介绍了”<a href="https://blog.csdn.net/suoxd123/article/details/86103798" target="_blank" rel="noopener">新生儿应该吃维生素AD而不是鱼肝油</a>“（<a href="https://blog.csdn.net/suoxd123/article/details/86103798" target="_blank" rel="noopener">点击查看</a>），主要从三个方面解释：</p><h2 id="1-为什么之前吃（老一辈）"><a href="#1-为什么之前吃（老一辈）" class="headerlink" title="1. 为什么之前吃（老一辈）"></a>1. 为什么之前吃（老一辈）</h2><blockquote><p>&emsp;&emsp;在过去的70-80年代，由于鱼肝油价格便宜，那个时候也没有更为规范的维生素AD制剂，因此也常用鱼肝油进行预防补充，因此即便是现在，也有医生为了各位宝爸宝妈、爷爷奶奶方便理解，就将维生素AD制剂简单说为鱼肝油。</p></blockquote><h2 id="2-为什么现在不建议吃"><a href="#2-为什么现在不建议吃" class="headerlink" title="2. 为什么现在不建议吃"></a>2. 为什么现在不建议吃</h2><blockquote><p>&emsp;&emsp;按照我国的营养情况，维生素A和维生素D的比例在3:1比较好，因此，国内企业生产的维生素AD药品是直接做成3:1的配比；但是鱼肝油使用的是食品标准，维生素A、D的配比不合理，含量达不到营养学会推荐标准，起不到预防疾病的作用。</p></blockquote><h2 id="3-那现在吃什么（维生素AD）"><a href="#3-那现在吃什么（维生素AD）" class="headerlink" title="3. 那现在吃什么（维生素AD）"></a>3. 那现在吃什么（维生素AD）</h2><blockquote><p>&emsp;&emsp;根据《儿童微量营养素缺乏防治建议》中对于维生素A和D缺乏的预防建议：0-3岁婴幼儿需要每日补充维生素A 1500-2000单位，维生素D400-800单位，但是因为鱼肝油保健品中两种成分的比例可能造成维生素A蓄积中毒却仍达不到维生素D需求量，所以喝母乳的宝宝应该选用A：D为2：1或4：1胶囊进行补充，而不是鱼肝油。</p></blockquote><h1 id="具体食用比例表"><a href="#具体食用比例表" class="headerlink" title="具体食用比例表"></a>具体食用比例表</h1><p>&emsp;&emsp;基于计算结果，为了方便直接查询，列了一个简单的表格，表示建议的食用数量进行对比查看。由于实际食用过程都会有各种意外，比如某一天忘记吃，或者吃的过程并没有全部使用，或者每一滴分量不同，以及宝宝平时吃的一些辅食等等，因此表格仅为参考。<br>&emsp;&emsp;由表格可见，当宝宝较小的时候食量较小可以适量补充维生素AD，当食量达到700及以上时可以不再吃维生素AD，可以适量补充维生素D制剂。不过，由于这个食量的宝宝通常已经添加了辅食，很多食物中也富含维生素A和维生素D，所以如果平时食物丰富不再补充也可以。<br>每天奶粉量（ml）|每周维AD（粒数）|每周维D（滴数）|说明<br>—|—|—|—<br>200|5|[0,6]|AD吃5天时，D不吃或6天内<br>200|6|[0,5]|AD吃6天时，D不吃或5天内<br>200|7|[0,4]|AD每天吃，D不吃或4天内<br>300|4|[1,7]|AD吃4天时，D最少一天、最多每天吃<br>300|5|[0,5]|AD吃5天时，D不吃或5天内<br>300|6|[0,4]|AD吃6天时，D不吃或4天内<br>400|3|[1,7]|AD吃3天时，D最少一天、最多每天吃<br>400|4|[0,5]|AD吃4天时，D不吃或5天内<br>400|5|[0,2]|AD吃5天时，D不吃或2天内<br>500|2|[2,8]|AD吃2天时，D最少2天、最多每天吃且有1天吃两次<br>500|3|[1,7]|AD吃3天时，D最少1天、最多每天吃<br>500|4|[0,5]|AD吃4天时，D不吃或5天内<br>600|1|[2,9]|AD吃1天时，D最少2天、最多每天吃且有3天吃两次<br>600|2|[1,7]|AD吃2天时，D最少1天、最多每天吃<br>600|3|[0,6]|AD吃3天时，D不吃或6天内<br>700|0|[3,9]|AD不吃时，D最少1天、最多每天吃<br>700|1|[2,9]|AD吃1天时，D最少2天、最多每天吃且有3天吃两次<br>700|2|[1,7]|AD吃2天时，D最少1天、最多每天吃<br>800|0|[3,9]|AD不吃，D最少3天、最多每天吃且有2天吃两次</p><h1 id="食用比例计算原理"><a href="#食用比例计算原理" class="headerlink" title="食用比例计算原理"></a>食用比例计算原理</h1><p>&emsp;&emsp;为了计算数据的有效，数据仅考虑只吃配方奶粉的宝宝，有额外辅食（尤其含有较高维生素AD的食物）的宝宝需要自行根据当量来评估。</p><h2 id="变量解释"><a href="#变量解释" class="headerlink" title="变量解释"></a>变量解释</h2><p>$V_{dk}$：维生素D k天用量（建议400-800IU），$V_{ak}$：维生素A k天用量（建议1500-2000IU）<br>$V_{d-n}$：奶粉中维生素D含量，$V_{a-n}$：奶粉中维生素A含量（奶粉包装上有标注，不同品牌的配方不完全一样）<br>$V_{d-ad}$：维生素VD制剂中维生素D含量（$IU/每粒$），$V_{a-ad}$：奶粉中标注的维生素A含量（$IU/每粒$）<br>$V_{d-d}$：维生素D制剂中维生素D含量（$IU/每滴$）<br>$C_n$：每天吃奶粉总量<br>$C_{ad}$：每周维生素VD制剂食用量<br>$C_{d}$：每周维生素D制剂食用量</p><h2 id="公式计算"><a href="#公式计算" class="headerlink" title="公式计算"></a>公式计算</h2><h3 id="已知"><a href="#已知" class="headerlink" title="已知"></a>已知</h3><p>$V_{d-n}=0.89(ug/100ml)$    //爱他美，新西兰版，一段<br>$V_{a-n}=68(ug-RE/100ml)$       //爱他美，新西兰版，一段<br>$C_n = 400$ //一日2餐，每餐200ml，则共400ml<br>$V_{a-ad}=1500(IU)$//伊可新，<br>$V_{d-ad}=500(IU)$//伊可新<br>$V_{d-d}=400(IU)$ // baby DDrops，美版<br>$V_{d7}=V_{d-n}/100<em>C_n</em>7 +V_{d-ad} <em>C_{ad} + V_{d-d}</em>C_{d}$<br>$V_a7=V_{a-n}/100<em>C_n</em>7 +V_{a-ad} *C_{ad}$ </p><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>$400 &lt; V_d1 &lt; 800，1500 &lt; V_a1 &lt; 2000$<br>$2800 &lt; V_d7 &lt; 5600，10500 &lt; V_a7 &lt; 14000$<br>// 维生素A：1ug-RE=1ug视黄醇当量＝3.3IU视黄醇<br>// 维生素D：1ug=40IU</p><h3 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h3><p>$2800 &lt; 249.2<em>(C_n/100) + 500 </em> C_{ad} + 400 <em> C_{d} &lt; 5600$<br>$10500 &lt; 1570.8</em>(C_n/100) + 1500 <em> C_{ad} &lt; 14000$<br><strong>方案1（推荐）</strong><br>$C_{ad}=4$<br>$C_{d}=3$<br>$V_{d7}=(0.89</em>40)<em>(400/100) </em> 7 + 500 <em> 4 + 400 </em> 3=4196.8(IU)$<br>$V_{a7}=(68<em>3.3)</em>(400/100) <em> 7 + 1500 </em> 4 =12283.2(IU)$<br><strong>方案2</strong><br>$C_{ad}=7$<br>$C_{d}=0$<br>$V_{d7}=(0.89<em>40)</em>(400/100) <em> 7 + 500 </em> 7 + 400 <em> 0=4496.8(IU)$<br>$V_{a7}=(68</em>3.3)<em>(400/100) </em> 7 + 1500 <em> 7 =16783.2(IU)$<br><strong>方案2</strong><br>$C_{ad}=0$<br>$C_{d}=7$<br>$V_{d7}=(0.89</em>40)<em>(400/100) </em> 7 + 500 <em> 0 + 400 </em> 7=3796.8(IU)$<br>$V_{a7}=(68<em>3.3)</em>(400/100) <em> 7 + 1500 </em> 0 =6283.2(IU)$<br><strong>方案对比说明</strong><br>&emsp;&emsp;对于当前情况下（每天吃两餐奶粉，每餐200ml量，如果变了需要调整食用量），建议方案1即每周4天吃维生素AD，3天吃维生素D，可以考虑单数（周1、3、5、日）吃一粒维AD，双数（周2、4、6）吃一滴维D；如果方案1每周7天都吃AD长时间会导致维生素A超标中毒，如果方案3每周7天只吃维生素D可能会维生素A不足。</p><center><img src="/img/baby/aitamei.png" width="150" height="200" title="爱他美，新西兰版，一段"></center>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 维生素 </tag>
            
            <tag> 维D </tag>
            
            <tag> 维AD </tag>
            
            <tag> 食量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝办理身份证</title>
      <link href="/2019/01/09/baby/%E8%BA%AB%E4%BB%BD%E8%AF%81/"/>
      <url>/2019/01/09/baby/%E8%BA%AB%E4%BB%BD%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;新生儿身份证就是在未满16周岁的少年儿童自愿的情况下，申请办理的身份证，这类证件必须由家长陪同才能办理，而且有效期限只有五年。<br>&emsp;&emsp;拍摄照片的时候，是要求孩子可以独立坐正的，因此3个月内或无法自己坐起来的的宝宝不太适合办理身份证。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ol><li>父母双方身份证原件、复印件</li><li>家庭户口簿原件、复印件（有宝宝的户口簿）</li><li>一起到户口所在地派出所去拍照</li><li>缴纳工本费20元</li><li>身份证申请表（现场填写确认）<h2 id="时效"><a href="#时效" class="headerlink" title="时效"></a>时效</h2></li><li>办理完手续，一个月左右带着领取凭证领取身份证</li><li>根据办理年龄不同，身份证有效期不同：<ul><li>未满16岁周岁：5年</li><li>16周岁至25周岁：10年</li><li>26周岁至45周岁：20年</li><li>46周岁以上办理：身份证长期有效<h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2></li></ul></li><li>需要身份证明的场合（出行、办其他证件等）不需要随身带着户口本</li><li>方便办理护照、港澳台通行证（出国）</li><li>开启银行账户（方便建立储蓄及教育基金）</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>&emsp;&emsp;<strong>办理流程</strong>相对固定也比较简单，只要带齐材料，到现场会有工作人员指引填表，并确认父母双方的个人信息以及宝宝的个人信息，所有内容确认完毕后，会派发申请回执，在一个月左右返回去派出所即可取回身份证。现在的公共及事业单位的办事效率非常高，之前需要很多流程排很久队的事情，现在大部分在几分钟内搞定。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 身份证 </tag>
            
            <tag> 有效期5年 </tag>
            
            <tag> 出国方便 </tag>
            
            <tag> 开通银行账户 </tag>
            
            <tag> 派出所办理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝怎么吃鱼肝油</title>
      <link href="/2019/01/08/baby/%E9%B1%BC%E8%82%9D%E6%B2%B9/"/>
      <url>/2019/01/08/baby/%E9%B1%BC%E8%82%9D%E6%B2%B9/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;鱼肝油是一种从鲨鱼、鳕鱼等海洋鱼类肝脏中提取的脂肪，通常为黄色到橙红色的透明油状液体，带有鱼腥味，主要含有维生素A和维生素D，一般用于预防和治疗维生素D缺乏引起的佝偻病以及维生素A缺乏引起的夜盲症等。</p><h2 id="易混淆说明"><a href="#易混淆说明" class="headerlink" title="易混淆说明"></a>易混淆说明</h2><h3 id="1-鱼肝油"><a href="#1-鱼肝油" class="headerlink" title="1. 鱼肝油"></a>1. 鱼肝油</h3><p>&emsp;&emsp;鱼肝油，则专指从鲨鱼、鳕鱼等的肝脏中提炼出来的脂肪，主要含有维生素A和维生素D。与鱼油不同，鱼肝油具有食用量上的限制，一旦大量摄入则难以在短期内排出体外，过多摄入容易导致中毒。</p><h3 id="2-鲨鱼肝油"><a href="#2-鲨鱼肝油" class="headerlink" title="2. 鲨鱼肝油"></a>2. 鲨鱼肝油</h3><p>&emsp;&emsp;鲨鱼肝油，主要成分为角鲨烯和烷氧基甘油，可用于提高机体免疫力，尤其是被用来放疗后所引起的放射性疾病和传染病。</p><h3 id="3-鱼油"><a href="#3-鱼油" class="headerlink" title="3. 鱼油"></a>3. 鱼油</h3><p>&emsp;&emsp;是鱼身上的所有油类的总称，它的主要成分是多不饱和脂肪酸。多不饱和脂肪酸在近年的研究中已经被证实能降低甘油三酯总量，可能有助于预防动脉粥样硬化、脑卒中、心肌梗塞。</p><h3 id="4-维生素AD"><a href="#4-维生素AD" class="headerlink" title="4. 维生素AD"></a>4. 维生素AD</h3><p>&emsp;&emsp;维生素AD和鱼肝油其实是两码事，二者的生产标准不一样。在过去的70-80年代，由于鱼肝油价格便宜，那个时候也没有更为规范的维生素AD制剂，因此也常用鱼肝油进行预防补充，因此即便是现在，也有医生为了各位宝爸宝妈、爷爷奶奶方便理解，就将维生素AD制剂简单说为鱼肝油。</p><ol><li>标准不同。鱼肝油是食品，使用的是食品的标准；而维生素AD滴剂属于药品，是按照国家药典的标准生产的。</li><li>成分比例不同。按照我国的营养情况，维生素A和维生素D的比例在3:1比较好，因此，国内企业生产的维生素AD药品是直接做成3:1的配比；但是鱼肝油使用的是食品标准，维生素A、D的配比不合理，含量达不到营养学会推荐标准，起不到预防疾病的作用。</li><li>如果鱼肝油真是海鱼提取，还有重金属超标的风险。<h2 id="该不该吃"><a href="#该不该吃" class="headerlink" title="该不该吃"></a>该不该吃</h2>&emsp;&emsp;先说个人建议：<strong>不该吃</strong>，如果要吃，建议直接补充维生素AD制剂，而且最好听取医生专业的建议（通常情况需要适量补充），下面是理由：<h3 id="1-普通人"><a href="#1-普通人" class="headerlink" title="1. 普通人"></a>1. 普通人</h3>&emsp;&emsp;生活在都市里的普通成年人，并不需要通过鱼肝油补充维生素A、D，只是老年人建议每天吃一粒鱼肝油进行补充。《中华预防医学杂志》上提供了我国不同人群维生素A、D缺乏情况，虽然有70.9%城市居民存在摄入不足的风险，但缺乏较为突出的是贫困地区的儿童和大城市的老年人及高龄段老年人。<h3 id="2-孕妇"><a href="#2-孕妇" class="headerlink" title="2. 孕妇"></a>2. 孕妇</h3>&emsp;&emsp;孕妇对维生素A、D需要量略增多，但也要根据体检结果和医生指导来补充维生素，而非自行服用。孕妇摄入大量维生素A、D反而有可能致胎儿畸形。有研究发现某些使用鱼肝油治疗皮肤病的妊娠妇女，生下的畸形胎儿多，可能与维生素A、D在体内蓄积有关。只要孕妇饮食得当，不需要长期服用鱼肝油，也完全可以保证胎儿正常发育。<h3 id="3-婴幼儿"><a href="#3-婴幼儿" class="headerlink" title="3. 婴幼儿"></a>3. 婴幼儿</h3>&emsp;&emsp;对于吃配方乳粉的宝宝来说，对此大可放心，配方乳粉中维生素A、D的含量已经足够了，不需要额外补充；而喝母乳的宝宝，有补充维生素的需求，由于中国妈妈母乳中维生素A、D含量与宝宝实际的营养需要量相差甚远，不能满足宝宝的生长发育需要。<br>&emsp;&emsp;根据《儿童微量营养素缺乏防治建议》中对于维生素A和D缺乏的预防建议：0-3岁婴幼儿需要每日补充维生素A 1500-2000单位，维生素D400-800单位，但是因为鱼肝油保健品中两种成分的比例可能造成维生素A蓄积中毒却仍达不到维生素D需求量，所以喝母乳的宝宝应该选用A：D为2：1或4：1胶囊进行补充，而不是鱼肝油。<h2 id="日常补充"><a href="#日常补充" class="headerlink" title="日常补充"></a>日常补充</h2>&emsp;&emsp;实际上在日常生活中，我们可以通过饮食搭配进行补充。<h3 id="1-维生素A"><a href="#1-维生素A" class="headerlink" title="1. 维生素A"></a>1. 维生素A</h3>&emsp;&emsp;富含维生素A的食物有个识别方法超简单，那就是选择黄颜色的水果和蔬菜，如南瓜、木瓜、芒果、橙子、胡萝卜、杏干、西红柿、菠菜等。<h3 id="2-维生素D"><a href="#2-维生素D" class="headerlink" title="2. 维生素D"></a>2. 维生素D</h3></li><li>维生素D主要来源于动物性食物，植物性食物几乎不含有维生素D，食物主要如鱼子酱、动物肝脏、蛋黄、脱脂牛奶、奶酪和瘦肉。</li><li>晒太阳。维生素D合成多少和裸露皮肤的面积、日晒时间长短都有关系。能够产生维生素D的紫外线主要为UVB，波长短，穿透力差，玻璃、塑料薄膜、甚至是纸张都对其有很大的阻挡力，所以隔着玻璃晒是补不了维生素D的。<h2 id="2014年-3-15事件"><a href="#2014年-3-15事件" class="headerlink" title="2014年 3.15事件"></a>2014年 3.15事件</h2>&emsp;&emsp;2014 年3.15晚会对鱼肝油进行了曝光。节目中对鱼肝油婴儿天天吃鱼肝油提出质疑，提出鱼肝油是药物，不能用于食品。国家食品安全评估中心标准三部副部长韩军花表示：“婴幼儿配方食品中，这两种维生素的成分已经足够，无需额外补充。如果你已经吃了这些东西，再额外去补，这个量可能就不在可控范围之内了。”协和医院主任药师张继春表示：“它不是补品，它是药，是药就有根据它的适应症。”<br>&emsp;&emsp;另一方面，节目曝光多家企业所生产销售的鱼肝油既非药品也非保健食品，采用的水产加工品、糖果的标准。个别企业在产品包装和标示上故意贴近儿童鱼肝油且没有按照食品备案要求组织生产 。国家食品药品监督管理局发言人对此表示此案例中确实存在逃避监管、误导消费者的违规行为  。</li></ol><hr><p>参考自：<br><a href="http://news.163.com/17/1107/18/D2LLESQ700018LP9.html" target="_blank" rel="noopener">http://news.163.com/17/1107/18/D2LLESQ700018LP9.html</a><br><a href="http://www.sohu.com/a/46918946_114607" target="_blank" rel="noopener">http://www.sohu.com/a/46918946_114607</a><br><a href="https://baobao.baidu.com/article/6167e6e8a0d5f6b9b40c43d72243a112.html?lz=1" target="_blank" rel="noopener">https://baobao.baidu.com/article/6167e6e8a0d5f6b9b40c43d72243a112.html?lz=1</a><br><a href="http://baijiahao.baidu.com/s?id=1603679227278987702&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1603679227278987702&amp;wfr=spider&amp;for=pc</a><br><a href="https://baike.baidu.com/item/%E9%B1%BC%E8%82%9D%E6%B2%B9/425491?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%B1%BC%E8%82%9D%E6%B2%B9/425491?fr=aladdin</a><br><a href="https://baike.baidu.com/item/2014%E5%B9%B4%E4%B8%AD%E5%A4%AE%E7%94%B5%E8%A7%86%E5%8F%B03%C2%B715%E6%99%9A%E4%BC%9A/13333591?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/2014%E5%B9%B4%E4%B8%AD%E5%A4%AE%E7%94%B5%E8%A7%86%E5%8F%B03%C2%B715%E6%99%9A%E4%BC%9A/13333591?fr=aladdin</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鱼肝油 </tag>
            
            <tag> 维生素AD </tag>
            
            <tag> 鱼油 </tag>
            
            <tag> 鲨鱼肝油 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝办理户口</title>
      <link href="/2019/01/08/baby/%E6%88%B7%E5%8F%A3%E6%9C%AC/"/>
      <url>/2019/01/08/baby/%E6%88%B7%E5%8F%A3%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;孩子出生以后（最好一个月内），爸爸妈妈给宝宝上户口是非常重要的，虽然办理过程相对简单，但如果信息填写错误再来修改的话就非常麻烦，所以还是要认真准备。<br>&emsp;&emsp;宝宝出生时，父母双方或一方是本市户籍居民，可在本市父(母)<strong>户籍所在地派出所</strong>申报出生登记，一般会有专门的户口办理相关窗口。过去前需要确定是根据爸爸还是妈妈的户口入户。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ol><li>宝宝的出生医学证明</li><li>父母双方身份证原件、复印件</li><li>父母双方户口簿原件、复印件（如果是集体户口需要首页复印件）</li><li>父母双方结婚证原件、复印件</li><li>出生登机申请表（现场填写）</li><li>入户地址（父母户口不同时，需要确定宝宝是随父还是随母入户）</li></ol><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol><li>宝宝 从法律上成为了家庭一员</li><li>办理后就有了身份证号</li><li>用于为宝宝办理身份证</li><li>宝宝入学时候要用</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>&emsp;&emsp;<strong>办理流程</strong>相对固定也比较简单，只要带齐材料，到现场会有工作人员指引填表，并确认父母双方的个人信息以及宝宝的个人信息，所有内容确认完毕后，会在户口簿上新的一页中增加宝宝的信息，上面包含了宝宝跟户主的关系。<br>&emsp;&emsp;另外，如果户口簿丢失了，需要及时补办。<strong>补办流程</strong>也相对简单，直接去派出所，一般会有专门的窗口办理（跟入户时候一样），带着身份证，一般现场即可办理并拿证，需要工本费。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 身份证 </tag>
            
            <tag> 户口 </tag>
            
            <tag> 身份证号码 </tag>
            
            <tag> 入户 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝办理出生证</title>
      <link href="/2019/01/08/baby/%E5%87%BA%E7%94%9F%E8%AF%81/"/>
      <url>/2019/01/08/baby/%E5%87%BA%E7%94%9F%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;出生证明，也被叫做《出生医学证明》，是按照《中华人民共和国母婴保健法》开出的一项证明。这份证明详细记录了宝宝的出生情况、与父母的血亲关系，对宝宝而言至关重要。出生证在宝宝出生时候的医院去办理，询问医院出生证明办理的地方，一般是办公楼。</p><h2 id="准备材料"><a href="#准备材料" class="headerlink" title="准备材料"></a>准备材料</h2><ol><li>宝宝名字（先想好，办理后不能改）</li><li>父母双方身份证原件</li><li>父母结婚证</li><li>出院通知单（<strong>重要</strong>）</li><li>户口地址（如果父母双方户口地不同，先想好跟随谁的户口地址）</li></ol><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ol><li>记录了宝宝出生信息</li><li>为宝宝办理接种证（打疫苗）</li><li>为宝宝落户口</li><li>亲人关系证明文件（方便证明我妈是我妈）</li><li>儿童时期部分学校和组织可能会需要</li></ol><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>&emsp;&emsp;<strong>办理流程</strong>相对固定也比较简单，只要带齐材料，到现场会有工作人员指引填表，并确认父母双方的个人信息以及宝宝的个人信息，所有内容确认完毕后，会打印一份出生证明书，证明书有该有红章，等红墨水干了后收好纸质文件即可。<br>&emsp;&emsp;另外，如果证明书丢失了，需要及时补办。<strong>补办流程</strong>也相对简单，首先去原先为宝宝办理出生证的单位索取出生医学记录证明等相关资料，然后向所在地县或区级以上的卫生部门请求重新补一份。在卫生部门接收申请后，经过核查，证明情况是真实的，就会补发《出生医学证明》并盖公章。</p>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 出生证明 </tag>
            
            <tag> 身份证 </tag>
            
            <tag> 户口 </tag>
            
            <tag> 亲人关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝办理社保（医保）</title>
      <link href="/2019/01/07/baby/%E7%A4%BE%E4%BF%9D%EF%BC%88%E5%8C%BB%E4%BF%9D%EF%BC%89/"/>
      <url>/2019/01/07/baby/%E7%A4%BE%E4%BF%9D%EF%BC%88%E5%8C%BB%E4%BF%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;如果妈妈有社保，新生儿出生的花费是有社保报销的，不过出生后的费用则需要为新生儿购买社保才可以享受医保报销。<br>&emsp;&emsp;新生儿跟成人工作后的社保（养老保险、医疗保险、失业保险、工伤保险和生育保险）不一样，新生儿社保仅体现医疗保险，建议出身后立即为宝宝办理。在新生儿参保后，就可以获得医保财政补助，其实就是财政补助一部分钱，个人缴纳一部份钱，这些钱是可以拿到药店给宝宝买药的，如果是宝宝生病住院的话，则可按照报销比例进行报销。</p><h1 id="办理时间"><a href="#办理时间" class="headerlink" title="办理时间"></a>办理时间</h1><p>&emsp;&emsp;所谓种一棵树的最好时间是十年前和现在，如果由于不知道情况办理晚了，则知道以后应该尽快办理，按优先顺序办理的时间分别如下：</p><h3 id="出身三个月内"><a href="#出身三个月内" class="headerlink" title="出身三个月内"></a>出身三个月内</h3><p>&emsp;&emsp;三个月内办理可以<strong>从出身就享受</strong>医保待遇，因此如果三个月内有购买社保，则出生后宝宝自己住院的花销可以进行报销，比如需要住保温箱的花费（一天2000左右还是挺高的），黄疸高的宝宝照蓝灯的花费等。<br>&emsp;&emsp;如果宝宝跟妈妈一起出院，并且之后没有去医院住院，则没有需要医保报销的费用，这种情况没交社保也没有什么损失，所以也不需要有太大心里压力和负担，只要在知道可以办理社保后，去马上办理社保享受之后医保报销服务即可。<br>&emsp;&emsp;如果新生儿妈妈参加了城镇居民医疗保险，那么三个月内的新生儿是可以享受妈妈的医疗待遇的，如果妈妈参加的是新农合医疗保险，则是在生产的缴费当年，新生儿都可享受妈妈的医保。</p><h3 id="三个月到一岁"><a href="#三个月到一岁" class="headerlink" title="三个月到一岁"></a>三个月到一岁</h3><p>&emsp;&emsp;如果是超过三个月不到一岁才去办理，那么就是从办理<strong>次月开始享受</strong>医保待遇，前面已经发生的医疗费用就不在医保受理范围了。</p><h3 id="一岁后"><a href="#一岁后" class="headerlink" title="一岁后"></a>一岁后</h3><p>&emsp;&emsp;如果是超过一岁才去办理，那么就要等到投保的<strong>次年1月1日起</strong>，才能享受医保待遇。</p><h1 id="办理类型"><a href="#办理类型" class="headerlink" title="办理类型"></a>办理类型</h1><h3 id="住院医疗"><a href="#住院医疗" class="headerlink" title="住院医疗"></a>住院医疗</h3><p>&emsp;&emsp;最基本（必须）的医保，主要用于住院报销，报销需要超过最低报销额度，具体额度根据各地一级、二级、三级医院来确定。如下图，中山18年分别为600元、800元和1000元。</p><h3 id="社区门诊"><a href="#社区门诊" class="headerlink" title="社区门诊"></a>社区门诊</h3><p>&emsp;&emsp;用于在指定社区医院进行门诊看病报销，基于基本医疗报销增加用于的门诊（买药、看病）。</p><h3 id="医院门诊"><a href="#医院门诊" class="headerlink" title="医院门诊"></a>医院门诊</h3><p>&emsp;&emsp;这个可用于所有支持社保卡消费的医院（通常都支持），可以用于门诊，可以向工作后单位给交的社保一样进行消费。</p><h1 id="办理方式"><a href="#办理方式" class="headerlink" title="办理方式"></a>办理方式</h1><ol><li>需准备材料：<ol><li>宝宝户口本原件及复印件</li><li>户口本复印首页和登记宝宝信息的那一页、</li><li>宝宝身份证和复印件（如没办理身份证则不需要带）</li><li>家长和宝宝的合影的2寸照片（背景无要求）</li></ol></li><li>办理流程如下：<ol><li>给宝宝报户口，拿到宝宝的身份证号码，复印户口页首页和宝宝页</li><li>去医保管理中心的网站下载相关表格 (居民医保表格)</li><li>填写居民申请表，贴宝宝照片</li><li>拿到宝宝户口所在社区盖章</li><li>到医保管理中心取号排队办理审核，完毕后，工作人员会提供一个缴费单据到缴费窗口缴费</li><li>缴费之后，工作人员告知，半年后到社区拿卡<h1 id="报销"><a href="#报销" class="headerlink" title="报销"></a>报销</h1>&emsp;&emsp;如果宝宝生病住院，办理医保卡之后，就可以按照一定比例来进行报销。报销比例一、二、三级医院分别为80%、70%、60%，统筹基金最高支付限额5万元，大病医疗保险最高支付限额达到10万元。</li></ol></li></ol><center>&lt;img src=”/img/baby/shebao.png” width=”200” height=”150” title=”医保对比/&gt;</center>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社保 </tag>
            
            <tag> 医保 </tag>
            
            <tag> 出院报销 </tag>
            
            <tag> 三个月 </tag>
            
            <tag> 一年 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝怎么打自费疫苗</title>
      <link href="/2019/01/07/baby/%E8%87%AA%E8%B4%B9%E7%96%AB%E8%8B%97/"/>
      <url>/2019/01/07/baby/%E8%87%AA%E8%B4%B9%E7%96%AB%E8%8B%97/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;自费项目各地项目和价格都不相同，本文价格以2019年中山为例。另外，即使即使一类的免费疫苗（默认国产），也可以自费换成进口疫苗，本文主要讨论需要付费的种类而非换为付费的免费疫苗。<br>&emsp;&emsp;打疫苗原理，就是通过将灭活、减毒或去毒的病毒打入体内，使得实体产生免疫细胞，从而对该病毒形成免疫能力，因此即使有些疫苗不打，也不是一定会得该种疾病，甚至很多人认为没必要打疫苗来攻击自己的免疫系统。对于本身免疫能力较差的宝宝，在打疫苗时，需要多咨询医生，防止因为打疫苗反而被感染。</p><table><tbody><br>    <tr><br>        <th>接种时间</th><br>        <th>疫苗名称</th><br>        <th> 价格（元）</th><br>        <th>预防的传染病</th><br>    </tr><br>    <tr><br>        <td>2.5月龄</td><br>        <td>HIB(1/4)</td><br>        <td>83.12/126.2</td><br>        <td>严重细菌感染（脑膜炎、肺炎、菌血症、会厌炎、蜂窝织炎和关节炎）</td><br>    </tr><br>    <tr><br>        <td>3.5月龄</td><br>        <td>13价肺炎疫苗(1/3)</td><br>        <td>860</td><br>        <td>肺炎链球菌（肺炎、脑膜炎、中耳炎和败血症）</td><br>    </tr><br>    <tr><br>        <td>4.5月龄</td><br>        <td>HIB(2/4)</td><br>        <td>83.14/126.2</td><br>        <td>严重细菌感染（脑膜炎、肺炎、菌血症、会厌炎、蜂窝织炎和关节炎）</td><br>    </tr><br>    <tr><br>        <td>7月龄</td><br>        <td>HIB(3/4)</td><br>        <td>83.14/126.2</td><br>        <td>严重细菌感染（脑膜炎、肺炎、菌血症、会厌炎、蜂窝织炎和关节炎）</td><br>    </tr><br>    <tr><br>        <td>7.5月龄</td><br>        <td>13价肺炎疫苗(2/3)</td><br>        <td>860</td><br>        <td>肺炎链球菌（肺炎、脑膜炎、中耳炎和败血症）</td><br>    </tr><br>    <tr><br>        <td>10.5月龄</td><br>        <td>口服轮状病毒疫苗(1/3)</td><br>        <td>172.5</td><br>        <td>A群轮状病毒（腹泻）</td><br>    </tr><br>    <tr><br>        <td>12月龄</td><br>        <td>水痘疫苗</td><br>        <td>141</td><br>        <td>水痘-带状疱疹病毒（斑疹、丘疹、水疱疹和痂疹）</td><br>    </tr><br>    <tr><br>        <td>13月龄</td><br>        <td>兰菌净(1/3)</td><br>        <td>336</td><br>        <td>上呼吸道细菌感染（鼻炎、鼻咽炎、鼻窦炎、扁桃体炎和支气管炎）</td><br>    </tr><br>    <tr><br>        <td>15月龄</td><br>        <td>13价肺炎疫苗(3/3)</td><br>        <td>860</td><br>        <td>肺炎链球菌（肺炎、脑膜炎、中耳炎和败血症）</td><br>    </tr><br>    <tr><br>        <td>16月龄</td><br>        <td>兰菌净(2/3)</td><br>        <td>336</td><br>        <td>上呼吸道细菌感染（鼻炎、鼻咽炎、鼻窦炎、扁桃体炎和支气管炎）</td><br>    </tr><br>    <tr><br>        <td>18.5月龄</td><br>        <td>脊灰灭活</td><br>        <td>159</td><br>        <td>脊髓灰质炎1型、2型和3型病毒（小儿麻痹）</td><br>    </tr><br>    <tr><br>        <td>20.5月龄</td><br>        <td>HIB(4/4)</td><br>        <td>83.14/126.2</td><br>        <td>严重细菌感染（脑膜炎、肺炎、菌血症、会厌炎、蜂窝织炎和关节炎）</td><br>    </tr><br>    <tr><br>        <td>23月龄</td><br>        <td>口服轮状病毒疫苗(2/3)</td><br>        <td>172.5</td><br>        <td>A群轮状病毒（腹泻）</td><br>    </tr><br>    <tr><br>        <td>25月龄</td><br>        <td>甲肝灭活疫苗</td><br>        <td>105.8/254.4</td><br>        <td>甲肝病毒（甲型肝炎）</td><br>    </tr><br>    <tr><br>        <td>28月龄</td><br>        <td>兰菌净(3/3)</td><br>        <td>336</td><br>        <td>上呼吸道细菌感染（鼻炎、鼻咽炎、鼻窦炎、扁桃体炎和支气管炎）</td><br>    </tr><br>    <tr><br>        <td>35月龄</td><br>        <td>口服轮状病毒疫苗(3/3)</td><br>        <td>172.5</td><br>        <td>A群轮状病毒（腹泻）</td><br>    </tr><br></tbody></table><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&emsp;&emsp;我国把宝宝疫苗分为两大类，两类都是国家推荐接种的，第一类是公共机构免费提供的，第二类得家长自己选择自费接种，第一类的疫苗以国产为主，部分也可以自费换成进口的。<br>&emsp;&emsp;各个地方的疫苗接种站系统和政策不一定相同，且未实现全国联网，可能查询不到外地的信息，尽量在一个地方接种疫苗。如果到新地方接种的话，一定问清楚当地的接种人员，因为有的地方是只打第一类疫苗，而对一些收费的则不强求，但有的地方是推荐第二类疫苗。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="接种前"><a href="#接种前" class="headerlink" title="接种前"></a>接种前</h2><ol><li>接种前一周照顾好宝宝，防止宝宝生病。</li><li>接种前一天晚上，给宝宝洗个澡，确保身体洁净。</li><li>接种当天，建议给宝宝穿宽松易脱的棉质衣服，便于撩起衣服</li></ol><h2 id="接种后"><a href="#接种后" class="headerlink" title="接种后"></a>接种后</h2><ol><li>接种完要用酒精棉按住伤口，等到不出血再拿开，不要去揉搓伤口。</li><li>接种后在医院或诊所观察30分钟，宝宝没有异常反应在回家，不良反应通常在接种后30分钟内出现。</li><li>接种后等待30分钟，再喂奶、喂水</li><li>注意接种部位清洁不要弄湿，以防感染。</li><li>接种当天宝宝饮食主要以清淡为主，多喝水、多休息、注意保暖。<h2 id="禁忌（以下情况需暂缓接种）"><a href="#禁忌（以下情况需暂缓接种）" class="headerlink" title="禁忌（以下情况需暂缓接种）"></a>禁忌（以下情况需暂缓接种）</h2></li><li>重大疾病<ol><li>患有皮肤病（比如皮炎、严重湿疹等）的宝宝</li><li>内脏（诸如心脏、肝肾）有重大疾病，或者有活动型结核病的宝宝</li><li>大脑发育不良，或者是身患癫痫、脑炎后遗症的宝宝</li><li>营养不良、佝偻病等或罹患重度先天性免疫缺陷的宝宝</li><li>有哮喘或者是其它过敏疾病（比如荨麻疹）的宝宝</li></ol></li><li><p>其它</p><ol><li>宝宝发烧（＞37.5℃），腋下或淋巴结出现肿大，需要查清情况并且痊愈之后方可接种。</li><li>如果宝宝有严重腹泻（每日大便达到四次以上），建议让宝宝恢复两个星期后再服用脊灰疫苗。</li><li>如果宝宝短期内注射过一些药物（比如多价免疫球蛋白），那么要间隔六个星期才能注射麻疹疫苗。</li><li>如果宝宝感冒且轻度的低烧，需要根据发病情况选择是否接种，必要的时候推迟接种。</li><li><p>切勿在宝宝饥饿时进行接种。接种之前一定要给宝宝吃些东西，它不像验血需要空腹。</p><center>&lt;img src=”/img/baby/yimiao.png” width=”200” height=”150” title=”中山市儿童疫苗接种/&gt;</center></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自费疫苗 </tag>
            
            <tag> 二类 </tag>
            
            <tag> 接种时间 </tag>
            
            <tag> 疫苗价格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝宝怎么打免费疫苗</title>
      <link href="/2019/01/07/baby/%E5%85%8D%E8%B4%B9%E7%96%AB%E8%8B%97/"/>
      <url>/2019/01/07/baby/%E5%85%8D%E8%B4%B9%E7%96%AB%E8%8B%97/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;打疫苗原理，就是通过将灭活、减毒或去毒的病毒打入体内，使得实体产生免疫细胞，从而对该病毒形成免疫能力，因此即使有些疫苗不打，也不是一定会得该种疾病，甚至很多人认为没必要打疫苗来攻击自己的免疫系统。对于本身免疫能力较差的宝宝，在打疫苗时，需要多咨询医生，防止因为打疫苗反而被感染。</p><table><tbody><br>    <tr><br>        <th>接种时间</th><br>        <th>疫苗名称</th><br>        <th>预防的传染病</th><br>    </tr><br>    <tr><br>        <td rowspan="2">出生24小时内</td><br>        <td>乙肝疫苗(1/3)</td><br>        <td>乙型病毒性肝炎</td><br>    </tr><br>    <tr><br>        <td>卡介苗</td><br>        <td>结核病</td><br>    </tr><br>    <tr><br>        <td>1月龄</td><br>        <td>乙肝疫苗(2/3)</td><br>        <td>乙型病毒性肝炎</td><br>    </tr><br>    <tr><br>        <td>2月龄</td><br>        <td>口服脊灰疫苗(1/4)</td><br>        <td>小儿麻痹</td><br>    </tr><br>    <tr><br>        <td rowspan="2">3月龄</td><br>        <td>口服脊灰疫苗(2/4)</td><br>        <td>小儿麻痹</td><br>    </tr><br>    <tr><br>        <td>百白破三联疫苗(1/4)</td><br>        <td>百日咳、白喉、破伤风</td><br>    </tr><br>        <tr><br>        <td rowspan="2">4月龄</td><br>        <td>口服脊灰疫苗(3/4)</td><br>        <td>小儿麻痹</td><br>    </tr><br>    <tr><br>        <td>百白破三联疫苗(2/4)</td><br>        <td>百日咳、白喉、破伤风</td><br>    </tr><br>    <tr><br>        <td>5月龄</td><br>        <td>百白破三联疫苗(3/4)</td><br>        <td>百日咳、白喉、破伤风</td><br>    </tr><br>    <tr><br>        <td>6月龄</td><br>        <td>乙肝疫苗(3/3)</td><br>        <td>乙型病毒性肝炎</td><br>    </tr><br>    <tr><br>        <td>6.5月龄</td><br>        <td>A群流脑疫苗(1/4)</td><br>        <td>脑膜炎 </td><br>    </tr><br>    <br>     <tr><br>        <td rowspan="2">8月龄</td><br>        <td>乙肝病毒活疫苗(1/2)</td><br>        <td>乙型病毒性肝炎</td><br>    </tr><br>    <tr><br>        <td>麻风二联疫苗</td><br>        <td>麻疹</td><br>    </tr><br>    <tr><br>        <td>10月龄</td><br>        <td>A群流脑疫苗(2/4)</td><br>        <td>脑膜炎</td><br>    </tr><br>    <tr><br>        <td>18月龄</td><br>        <td>麻腮风二联疫苗</td><br>        <td>麻疹、腮腺炎、风疹</td><br>    </tr><br>    <tr><br>        <td>19月龄</td><br>        <td>甲肝病毒活疫苗</td><br>        <td>甲型肝炎的疫苗</td><br>    </tr><br>    <tr><br>        <td>20月龄</td><br>        <td>百白破三联疫苗(4/4)</td><br>        <td>百日咳、白喉、破伤风</td><br>    </tr><br>    <tr><br>        <td>24月龄</td><br>        <td>乙肝病毒活疫苗(1/2)</td><br>        <td>乙型病毒性肝炎</td><br>    </tr><br>    <tr><br>        <td>36月龄</td><br>        <td>流脑A+C疫苗(3/4)</td><br>        <td>脑膜炎</td><br>    </tr><br>    <tr><br>        <td>4岁龄</td><br>        <td>口服脊灰疫苗(4/4)</td><br>        <td>小儿麻痹</td><br>    </tr><br>    <tr><br>        <td rowspan="2">6岁龄</td><br>        <td>白破二联疫苗</td><br>        <td>白喉、破伤风</td><br>    </tr><br>    <tr><br>        <td>流脑A+C疫苗(4/4)</td><br>        <td>脑膜炎</td><br>    </tr><br><br></tbody></table><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>&emsp;&emsp;我国把宝宝疫苗分为两大类，两类都是国家推荐接种的，第一类是公共机构免费提供的，第二类得家长自己选择自费接种，第一类的疫苗以国产为主，部分也可以自费换成进口的。<br>&emsp;&emsp;各个地方的疫苗接种站系统和政策不一定相同，且未实现全国联网，可能查询不到外地的信息，尽量在一个地方接种疫苗。如果到新地方接种的话，一定问清楚当地的接种人员，因为有的地方是只打第一类疫苗，而对一些收费的则不强求，但有的地方是推荐第二类疫苗。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="接种前"><a href="#接种前" class="headerlink" title="接种前"></a>接种前</h2><ol><li>接种前一周照顾好宝宝，防止宝宝生病。</li><li>接种前一天晚上，给宝宝洗个澡，确保身体洁净。</li><li>接种当天，建议给宝宝穿宽松易脱的棉质衣服，便于撩起衣服</li></ol><h2 id="接种后"><a href="#接种后" class="headerlink" title="接种后"></a>接种后</h2><ol><li>接种完要用酒精棉按住伤口，等到不出血再拿开，不要去揉搓伤口。</li><li>接种后在医院或诊所观察30分钟，宝宝没有异常反应在回家，不良反应通常在接种后30分钟内出现。</li><li>接种后等待30分钟，再喂奶、喂水</li><li>注意接种部位清洁不要弄湿，以防感染。</li><li>接种当天宝宝饮食主要以清淡为主，多喝水、多休息、注意保暖。<h2 id="禁忌（以下情况需暂缓接种）"><a href="#禁忌（以下情况需暂缓接种）" class="headerlink" title="禁忌（以下情况需暂缓接种）"></a>禁忌（以下情况需暂缓接种）</h2></li><li>重大疾病<ol><li>患有皮肤病（比如皮炎、严重湿疹等）的宝宝</li><li>内脏（诸如心脏、肝肾）有重大疾病，或者有活动型结核病的宝宝</li><li>大脑发育不良，或者是身患癫痫、脑炎后遗症的宝宝</li><li>营养不良、佝偻病等或罹患重度先天性免疫缺陷的宝宝</li><li>有哮喘或者是其它过敏疾病（比如荨麻疹）的宝宝</li></ol></li><li>其它<ol><li>宝宝发烧（＞37.5℃），腋下或淋巴结出现肿大，需要查清情况并且痊愈之后方可接种。</li><li>如果宝宝有严重腹泻（每日大便达到四次以上），建议让宝宝恢复两个星期后再服用脊灰疫苗。</li><li>如果宝宝短期内注射过一些药物（比如多价免疫球蛋白），那么要间隔六个星期才能注射麻疹疫苗。</li><li>如果宝宝感冒且轻度的低烧，需要根据发病情况选择是否接种，必要的时候推迟接种。</li><li>切勿在宝宝饥饿时进行接种。接种之前一定要给宝宝吃些东西，它不像验血需要空腹。</li></ol></li></ol><pre><code>&lt;center&gt;&lt;img src=&quot;/img/baby/yimiao.png&quot; width=&quot;200&quot; height=&quot;150&quot; title=&quot;中山市儿童疫苗接种/&gt;&lt;/center&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常生活 </category>
          
          <category> 新生儿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疫苗 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 一类 </tag>
            
            <tag> 新生儿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《反脆弱·做一个内心强大的人》</title>
      <link href="/2018/12/25/books/%E5%8F%8D%E8%84%86%E5%BC%B1%C2%B7%E5%81%9A%E4%B8%80%E4%B8%AA%E5%86%85%E5%BF%83%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%BA/"/>
      <url>/2018/12/25/books/%E5%8F%8D%E8%84%86%E5%BC%B1%C2%B7%E5%81%9A%E4%B8%80%E4%B8%AA%E5%86%85%E5%BF%83%E5%BC%BA%E5%A4%A7%E7%9A%84%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;坦白讲，这本书的大标题《反脆弱》是别人推荐的，但买书时小标题自己没注意，最终决定买这本书，是被书中“一生只能爱一个人”这个章节吸引的，想看看作者的思考角度，不过，整体内容上自己也还是有所共鸣。当然，后来知道别人推荐的书的小标题是“从不确定性中获益”，作者是纳西姆·尼古拉斯·塔勒布。<br>&emsp;&emsp;当前这本书从书名看有点心灵鸡汤的意思，不过，通读一遍后，除了鸡汤的慰藉也能有一些实质性的收获，不止多了一点思考问题的维度，也对我在有些行为上有了些影响，有几个观点自己认为比较受用，接下来我将分别解释和分享下。</p><ol><li>什么都想要的人，往往什么也得不到<br>&emsp;&emsp;没有任何人可以得到想要的一切，不论是金钱的富有还是精神的富有，因此，让自己拥有放弃的能力和勇气，将自己有限的精力集中在最重要的事情上，甚至敢于砍掉生活中80%的无效部分。</li><li><p>最重要的事，只有一件<br>&emsp;&emsp;这个观点是猎豹CEO傅盛推荐的一本书中的关键，书名即为观点本身。28法则是大家耳熟能详的一个观点，真正把这个观点应用到自己的工作生活中，需要从自己的计划中找出那80%的无用功，砍掉工作中90%可以做但不应该做的事情，你将比原来更轻松的方式获得更高的产出。<br>&emsp;&emsp;对待具体工作上，也要做到将长期重要的事情（大局）和目前重要的事情（焦点）进行结合。</p></li><li><p>再糟糕的事情，也能从中找到积极的意义<br>&emsp;&emsp;文中描述了几个观点，其中有一个“负能量的朋友是自己吸引来的”，即如果你发现大家最近总是向你抱怨生活、工作中的一些烦心事，那么可能是你给了别人这个权利，因为你也从中获得了好处，可能是享受这种给别人提建议时高高在上的感觉，可能是满足于自己被需要的感觉，可能在给别人贴了标签时候，标榜自己在标签相反方向的特质等等，一旦自己判断满足感已经低于为此得到的痛苦，可以果断中止。如果在一段关系中不能说“不”，那这段关系一定是取悦的或者说控制的，这种情况更要敢于说“不”。</p></li><li>其它<br>&emsp;&emsp;自己读到这一章节时，跟自己生活中的一些细节产生了共鸣，因此特别有感触，所以写了一些自己的心得，回头看文章写的有点激烈，但那就是那个时候自己强烈的感受，感兴趣可以点击查看：</li></ol><ul><li><a href="https://blog.csdn.net/suoxd123/article/details/85221575" target="_blank" rel="noopener">不自觉的向人展示自我，是来自内心的渴望认同</a>（你需要多少攒，才能相信自己真的攒）</li><li><a href="https://blog.csdn.net/suoxd123/article/details/85253171" target="_blank" rel="noopener">跟父母还是要保持一定的距离感</a>（再亲近的人，彼此也要有界限感）</li></ul><h1 id="读书总结"><a href="#读书总结" class="headerlink" title="读书总结"></a>读书总结</h1><p>&emsp;&emsp;本书分6章，每章由几个小节组成，每个一个小节分别由不同行业的人行文，可能是作者根据章节对应的主题，在行业内找到不错的文章或者对主题表达比较有助力的角度，对观点进行了集中和整合。<br>&emsp;&emsp;书中6个章节，章节本身的命名和布局不是特别合理，但细品各文章的内容，还是有不少精彩的观点。6章的标题分别为：</p><ol><li>“心态决定一切”，讲述价值观的一些观点。</li><li>“做一个会折腾的人”，这章的标题起的牵强，说了几个案例而已。</li><li>“不平庸的活法”，讲人生观的一些思考。</li><li>“所谓强大，就是管好自己的情绪”，讲调节个人情绪的思考维度。</li><li>“一生只能爱一个人吗”，讲在爱情和家庭关系中角色和特点。</li><li>“有什么样的父母，就有什么样的‘复印件’”，讲家庭中父母对子女的影响。</li></ol><h1 id="读书建议"><a href="#读书建议" class="headerlink" title="读书建议"></a>读书建议</h1><ul><li>建议有小孩的家长，买来看看最后一章，讲述家庭成员之间关系的剖析和建议。</li><li>辛苦工作的年轻人，可以买来看看第三、四章，看看别人生活还可以有不同的状态。</li><li>小朋友就不建议看了，没什么特别的东西</li><li>成年人可以买来快速通读一遍，可以拓宽知识面</li><li>可以买来作为自我心理建设的工具书</li><li>由于各个章节由不同作者独立成文，因此吸收了各方精华</li><li>整体来看，还是难逃鸡汤的命运</li></ul><center><img src="/img/books/反脆弱·做一个内心强大的人.jpg" width="150" height="200" title="反脆弱·做一个内心强大的人 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反脆弱 </tag>
            
            <tag> 心态 </tag>
            
            <tag> 最重要的事，只有一件 </tag>
            
            <tag> 心灵鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《冰与火之歌》</title>
      <link href="/2018/12/22/books/%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C/"/>
      <url>/2018/12/22/books/%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;这套书是读研时候一位当时关系密切老师推荐的，后来买了全部（一共5部-15本，随书还有5个别致的金属徽章）纸质版的书，现在具体书里的情节已经基本全忘了。最近在写一些书的读书感受，之前的书原本不打算写，不过看到书架上这部大部头的书还是决定写一点。即使要写也是一些朦胧的东西，或者经过时间的洗礼剩下的东西。<br>&emsp;&emsp;整体感受就是前面基本特别枯燥和无聊，全是人物关系的介绍，尤其一堆外国人的名字，音译为汉字特别长，所以前面在介绍小说的各种人物时，特别想放弃。若不是因为买了实体书，估计就放弃了，可见虽然书不借不读，但买书有时也有正向的鞭策作用。<br>&emsp;&emsp;这是目前为止读过的唯一一部这么大部头的国外文学小说，虽然开始读起来无趣，但随着故事的推进，经常对情节欲罢不能，那段时间几乎被小说占据了所有课余时间，不过，那时候只有这5部出版了，看完觉得不过瘾，感觉故事才刚开始不久，特别期待作者继续开脑洞。这部小说拿起来就不太容易放得下，情节的特别精彩。<br>&emsp;&emsp;全书已出版的共5卷，从前到后的小标题依次为《权力的游戏》、《列王的纷争》、《冰雨的风暴》、《群鸦的盛宴》、《魔龙的狂舞》，最近查看小说的更新情况，好像第六卷确定了叫《凛冬的寒风》，只是今年还无法出版，不知道作者本人或者其继承人能否继续推进小说。前几年听说根据小说拍了一部美剧，不过一直没敢看，担心电视无法传达小说中的宏大场面以及细腻的情节，或者将小说中的内容改动较多接受不了，毕竟有成本和条件的限制，通过影视传达多少都会有些失真。</p><h1 id="读书总结"><a href="#读书总结" class="headerlink" title="读书总结"></a>读书总结</h1><p>&emsp;&emsp;时间过去太久，无法对书中内容做条理清晰的总结，那么就根据一些片段描写自己有印象的部分情节，然后写一些自己的心得。</p><ol><li>前面章节北境的出场率特别高，以为北境之王是主角，不料后来被刽子手砍下了头。</li><li>随着北境之王被杀，其长子称王重新统领北方，私生子成为了长城的边防统领，以及其他家族成员艰难的生存故事依次展开。</li><li>前朝公主养了几条龙威慑八方，长城外沉寂了很久的厉鬼开始重新出现，国王旧部复仇力量集结，多方力量渐成规模，一场决战势在必行。</li><li>一旦跟政治发生牵连，即使只是个人参与，整个家族都难免一荣俱荣，只要还有人在这摊水里，所有家族成员都无法撇清关系。</li><li>一个人除非站在金字塔尖，否则一旦山洪暴发，所有一切必将全部灰飞烟灭。</li><li>权力的游戏里，或者在政治的斗争中，只能赢才能活，输了就是死路一条。</li><li>政治中的斗争，全是权谋和心计，讲证据和评道理是行不通的。</li><li>当你轻装上阵时，也许是有人在帮你负重前行。</li></ol><h1 id="读书建议"><a href="#读书建议" class="headerlink" title="读书建议"></a>读书建议</h1><ul><li>这本书老少皆宜。</li><li>把书当作现在的清宫剧或者三国演义来看，只是场面相对宏大、故事虚构。</li><li>如果无法记住其中较长的人名，只要通过别名对主要人物能区分即可。</li><li>内容有点多，小说这种事情，普通人不用太着急，放本书在床头慢慢看。</li><li>大部头的小说可以先看故事，不用精度。</li><li>如果对情节特别喜欢，建议做个思维导图缕清人物关系后，再读一遍。</li></ul><center><img src="/img/books/冰与火之歌.jpg" width="150" height="200" title="冰与火之歌 - 全五部 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权力的游戏 </tag>
            
            <tag> 列王的纷争 </tag>
            
            <tag> 冰雨的风暴 </tag>
            
            <tag> 群鸦的盛宴 </tag>
            
            <tag> 魔龙的狂舞 </tag>
            
            <tag> 科幻小说 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《AI·未来》</title>
      <link href="/2018/12/21/books/AI%C2%B7%E6%9C%AA%E6%9D%A5/"/>
      <url>/2018/12/21/books/AI%C2%B7%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h2><p>&emsp;&emsp;李开复老师是AI领域顶级的科学家，本书是其对AI的认知总结和未来预想<br>&emsp;&emsp;整本书读完特别舒服，整本书逻辑递进，也是最近为数不多让自己想读第二遍的书，从此被圈粉，之后一定会再买李开复老师别的书来读。<br>&emsp;&emsp;本书开始先讲了人工智能行业特有的属性和特点，然后描述中国创业环境和互联网特点，接着以国内企业特色来展示人工智能在国内的巨大潜力和优势，最后也提出了可能的潜在问题以及在癌症痊愈后对人生的思考和转变。<br>&emsp;&emsp;高中时候看过李开复老师写的激励年轻人努力的几封公开信，再后来就是查看NLP时了解到李开复老师10年前研发的，基于隐马尔科夫模型的语音识别系统，再之后知道其创建了创新工场，做了投资人，本身没什么特别的印象。书中对其个人经历的描述，才知道李开复老师之所以让这么多人追随绝非浪得虚名，简直让人倾倒膜拜，尤其为其作为华人在美国的科技圈达到如此地位，也为其归国创业的情怀。<br>&emsp;&emsp;不论想了解AI发展，还是对国内环境，甚至只是想了解下人工智能，本书都值得一读。</p><h2 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h2><p>&emsp;&emsp;书中描述人工智能对人类的冲击这一章节，对自己的触动还是挺大的。第一次工业革命和第二次工业革命分别以蒸汽机和电力为动力，带来了工业制造的全面升级代替了传统的手工业，提升了整体社会的生产力；但是人工智能带来的不止是效率的提升，可能是直接对人类工作的摧毁。类比前两次工业革命，是根据人类自身工作特点研发特定的机械部件代替人类的重复性工作，但是人工智能可能直接颠覆人类的工作流程和模式。基于人类跟人工智能的对比，让人在大多数领域很难有竞争优势，从而导致大面积的失业或者对部分职业资源的争夺，最终整体收入水平下降。虽然给出了几个方案（见这篇文章“凛冬将至，准备好接下来的寒冬吧”），但最终怎么执行人类还要再摸索。</p><p>&emsp;&emsp;书中最后章节描写了李开复老师对人生意义的探寻，让自己颇受感染，尤其对于家人亲情的回归，自己读完后的感想就是要花多一点时间陪伴自己的家人，将工作上的优先级往后放一点点。</p><p>&emsp;&emsp;具体技术上的进步是永无止境的，跟大神之间的差距可能终其一生也无法企及，甚至无法获得其很早就有的荣誉，而且随着代代人才的精进，自己不可能永远跟上时代的节奏，那就在保持知识更新的同时，寻求多角度、全方面的视野和历练，让自己在今天比昨天更值得，明天始终值得期待吧。</p><center><img src="/img/books/AI未来.jpg" width="150" height="200" title="AI未来 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 李开复 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《好好说话2》</title>
      <link href="/2018/12/21/books/%E5%A5%BD%E5%A5%BD%E8%AF%B4%E8%AF%9D2/"/>
      <url>/2018/12/21/books/%E5%A5%BD%E5%A5%BD%E8%AF%B4%E8%AF%9D2/</url>
      
        <content type="html"><![CDATA[<h2 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h2><p>&emsp;&emsp;读的这本是第二版，第一版没读过，不过这是在说话或者关系处理类的书里面，目前读的最棒的一本，不过价格55块在同类书里面算贵的了。这本书的读法，可以作为一本人际关系处理的字典，当遇到不太好面对的问题时，通过目录定位到相应话题，看看别人怎么说怎么想，供自己借鉴。<br>&emsp;&emsp;这本书被认为是媒体中最会说话，或者最知道如何揣摩人心的几个人一起合编的，在喜马拉雅FM也有对应的音频课程，那个课程没听，扫了一眼标题，有点人生导师喂鸡汤的意思，而且价格200块也不便宜，所以没听。<br>&emsp;&emsp;书中应该是不同人分别负责不同专栏或者主题的文章（在每篇文章的开头有个人脸形象的简笔，我猜应该是文章对应的作者），然后统一由某个人最终校对和修改，我猜后者是由马薇薇做的，当然肯定不止是她一个人做，甚至主要都是其他人做的，但至少她做过一遍。猜测的理由有两点，第一，她是主编，内容她要把关；第二，整本书扫一遍明显感觉那个有扎头（女孩子形象）的人那些章节写的不那么引人入胜（观点和主题有些牵强），我猜这个人就是马薇薇，因为作者中女孩子就三个，她是唯一长发尖脸的。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>&emsp;&emsp;本书通过改变、化解、提升、维护、拉近、理解六个章节分别从六个维度来展示如何进行有效沟通，不止包含自我表达，也需要听话听音。六个章节分别从三个维度来体现作者的思路：分别为，第一、提升自己：强化语言效率（提升）、巩固自身利益（维护）、用情商表达自己（理解）；第二、处理关系：克服无言困境（化解）、促进人际关系（拉近）；第三、影响他人：影响他人决策（改变）。<br>&emsp;&emsp;说话的的方式，书中很多场景都是生活中经常会遇到的，所以也特别有实用性，就像哆啦A梦的宝贝口袋，遇到生活中犯难的事情，可以随手放开来看，不一定书中描述的方案是合适的，但提供的思考方式确实有助于自己执行。<br>&emsp;&emsp;确实有很多事情的角度是多方面的，每种情况下不同人的思维也不能完全听书里的，但书中给出了一个大家普遍可以接受的一种心态和处理方式，是可以作为一种策略的，哪怕还有别的可能性，在自己没有其它思路时，跟着书中建议来操作未尝不可，尤其生活本来就是在不断成长和摸索，本来就不像数学题会有唯一正确答案。<br>&emsp;&emsp;从主题角度说，整本书中说的核心就是把人和事分开，把情绪和事情分离，该使用情绪的时候使用情绪，该说事儿的时候不要带情绪，围绕这个主题进行展开和解释各位作者的思路，基本都针对每一个具体的问题，使用方法和技巧来应对和分解。</p><h2 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h2><ul><li>不论是否情商高，为了增强同理心或者理解能力，这本书都值得一读。</li><li>书中邱晨（短发女形象）的表达明显比马薇薇（扎头女形象）有逻辑，但两者的内容都值得借鉴。</li><li>可以将目录读一遍，只是针对自己的情况再读具体章节。</li><li>如果时间充裕，也可以先通读一遍，再针对自己特别感兴趣的精读消化。</li></ul><center><img src="/img/books/好好说话2.jpg" width="150" height="200" title="好好说话2 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沟通 </tag>
            
            <tag> 理解 </tag>
            
            <tag> 化解矛盾 </tag>
            
            <tag> 拉近关系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《如何说客户才会听，如何听客户才肯说》</title>
      <link href="/2018/12/18/books/%E5%A6%82%E4%BD%95%E8%AF%B4%E5%AE%A2%E6%88%B7%E6%89%8D%E4%BC%9A%E5%90%AC%EF%BC%8C%E5%A6%82%E4%BD%95%E5%90%AC%E5%AE%A2%E6%88%B7%E6%89%8D%E8%82%AF%E8%AF%B4/"/>
      <url>/2018/12/18/books/%E5%A6%82%E4%BD%95%E8%AF%B4%E5%AE%A2%E6%88%B7%E6%89%8D%E4%BC%9A%E5%90%AC%EF%BC%8C%E5%A6%82%E4%BD%95%E5%90%AC%E5%AE%A2%E6%88%B7%E6%89%8D%E8%82%AF%E8%AF%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h3><ul><li>书中分两部分，第一部分是说如何说客户才会听，第二部分是说怎么听客户才肯说。读完有种强烈的感觉，是这种书就是抄一些的励志类或者成功学之类的书，或者直接翻译的国外的成功学，当然也有可能（极小）是作者自身个人心得的积累和总结。</li><li>书中主要通过讲道理和举例子的方式来展示作者的思路，这些例子也许小学生会相信吧，我只是当做作者对道理的一个解释工具，也许是比喻或者想象。不过说的内容比较分散和具体，没有系统的整理和分析，这应该也是讲销售类书籍的通病吧，毕竟关于跟人沟通的道理也比较难进行系统化的梳理。</li><li>第一部分关于如何说，主要分两个思路进行讲道理和举例子，第一个思路是讲，要根据不同客户自身特有的性格特点和状态，来进行针对性的营销和对话，里面讲了很多客户的不同特点的案例（可能很多是作者自己杜撰或者从其他地方未经考证直接拿过来的例子），当然案例都特别简短易懂，其实给小学生读也可以，用于培养小孩沟通的同理心。</li><li>第一部分的第二个思路是讲，使用一些技巧来提高销售人员自身的销售素质，比如要做一个造梦高手、要讲一个好故事、要说对产品卖点、要巧用价格对比等，这种内容相对比较具体，但说的东西或许是有效的，但还是好大一股心灵鸡汤的味道。</li><li>第二部分也基本从两个类似的思路进行讲道理和举例子，只是讲述的道理和例子不同。</li><li>整体来讲，看起来比较轻松，没什么特别出彩的地方，大部分故事看看基本秒忘，有些书中讲述的道理还是过于空泛，停留在说教和理论层面。</li></ul><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>&emsp;&emsp;有时候我在想，类似故事的东西是当事人自己讲了然后作者记录的吗，或者作者本人即为当事人，还是作者自己想像的当事人应该是怎样的过程呢？但不论哪一种方式，故事都会被美化、甚至神话，但形成结果的真实原因和当事人的难言之隐，甚至其中背后的一些交易和猫腻，也许永远都不会跟人说（也不会在书中写，至少不会给这种教人销售的书中展开）。<br>&emsp;&emsp;我认为的好书应该是跟读者平视，为读者输出自己的判断和逻辑，甚至帮读者进行系统化的梳理，或者通过有条理的故事为读者展示一个逻辑，而不是站在高处俯视，更不是站在道德制高点评价各种道理的好坏</p><h3 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h3><ul><li>我知道做销售的特别不容易，可以把本书当做鸡汤来慰藉自己。</li><li>销售也可以看看，别人眼里的销售是怎样的</li><li>有读小学的家长，可以给小孩读，道理浅显易懂，故事简单明了，也锻炼小朋友的同理心；上了初中就不建议了。</li></ul><center><img src="/img/books/如何说客户才会听，如何听客户才肯说.jpg" width="150" height="200" title="如何说客户才会听，如何听客户才肯说 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心灵鸡汤 </tag>
            
            <tag> 沟通 </tag>
            
            <tag> 听人说 </tag>
            
            <tag> 商务交流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《数学之美》</title>
      <link href="/2018/12/15/books/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/"/>
      <url>/2018/12/15/books/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;这本书是吴军老师整理，描述Google在搜索引擎中使用到的部分数学模型及算法原理，尽管书中包含大量晦涩的数学公式（本人数学专业出身，对很多公式仍然无法快速理解），但依旧能让没有相关知识背景的读者感受在日常生活中不经意间对数学的应用，以及数学模型对现代生活便利的重要意义。<br>&emsp;&emsp;看到自然语言识别相关的几个章节，了解到自然语言从语法升级到统计模型，为社会进步奉献一生聪明才智的科学家震撼，多少代了也因此走了数不尽的弯路。在大家都选择使用文法规则进行语音识别的年代，多少人费尽一生的心血也无法得到显著的成果，跟他们相比选择基于统计方式的科学家就幸运的多，现实中的选择大于努力的例子。<br>&emsp;&emsp;统计模型刚出现时，其效果跟当时已经被广泛认可且也有一定成果的规则模型相比，简直不能相提并论，但只要方向是对的，就终有一天会走出困局，一旦方向错了，眼前的彩虹终究只是徒劳。<br>&emsp;&emsp;自然语言处理方向虽然有不少国内的科学家，但大部分都来自国外，虽然希望国内的学者可以静下心来做研究，但大家都是凡人，所在的社会环境和价值体系都会对个人产生影响，期待国家可以有更多掌握前沿知识的科学家。</p><h1 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h1><ol><li>对部分算法的应用有了初步的认识</li><li>学习吴军老师这种写法，将较深的数学知识作为拓展部分</li><li>了解了自然语言处理及文本识别的历史及相关原理和算法</li><li>虽然早知道余弦在文章相似性中的应用，看到数学公式还是深受震撼</li><li>马太效应在搜索引擎中的体现（越是搜索效果好越是用户多，用户越多产生的搜索数据越多，数据越多模型参数越好，参数越好搜索效果越好）</li><li>科学的进步绝非一朝一夕的，需要太多代科学家的专研，现在国内这种大部分人向钱看齐的做法感觉有点浮躁啊，现在清华北大的毕业生挺多去做金融（当然金融工具也在推动社会进步，但金融的基础得有社会价值），虽然最多还是深造。</li></ol><h1 id="个人建议"><a href="#个人建议" class="headerlink" title="个人建议"></a>个人建议</h1><ol><li>本书最好有概率论及线性代数相关的数学背景，否则会比较晦涩</li><li>如果对搜索引擎、语音识别及自然语言处理相关原理有兴趣，可以看看</li><li>如果知识想了解自然语音处理相关的故事，忽略所有数学公式依然可以享受书中内容</li><li>如果对算法和数学模型感兴趣，本书深入浅出的解释值得一读</li></ol><center><img src="/img/books/数学之美.jpg" width="150" height="200" title="数学之美 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学之美 </tag>
            
            <tag> 搜索引擎 </tag>
            
            <tag> 吴军 </tag>
            
            <tag> 硅谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 中流程图语法及示例</title>
      <link href="/2018/12/13/tech/md%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
      <url>/2018/12/13/tech/md%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp; <strong>本博客对流程图的支持还不太好，若看起来有点乱，可以移步到<a href="https://blog.csdn.net/suoxd123/article/details/84992282" target="_blank" rel="noopener">CSDN</a>了解详细语法：（<a href="https://blog.csdn.net/suoxd123/article/details/84992282" target="_blank" rel="noopener">点击查看</a>）。</strong></p><p>&emsp;&emsp; markdown有不同的插件实现，对应的语法也不太一样，对于插件就是把引用的语法对应成相应的标签，本文以CSDN中写作为例进行分别对mermaid和flowchart进行实例说明和语法解释。</p><h1 id="1-Mermaid-流程图"><a href="#1-Mermaid-流程图" class="headerlink" title="1. Mermaid 流程图"></a>1. Mermaid 流程图</h1><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[Apple]--&gt;B&#123;Boy&#125;</span><br><span class="line">A---C(Cat)</span><br><span class="line">B.-&gt;D((Dog))</span><br><span class="line">C==喵==&gt;D</span><br><span class="line">style A fill:#2ff,fill-opacity:0.1,stroke:#faa,stroke-width:4px</span><br><span class="line">style D stroke:#000,stroke-width:8px;</span><br></pre></td></tr></table></figure></code></pre> <center><br>    <img src="/img/tech/Mermaid流程图.png" title="Mermaid流程图"><br>    </center><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph 方向</span><br><span class="line">节点以及节点连线（定义和连线步骤可以分开）</span><br><span class="line">（样式调整）</span><br></pre></td></tr></table></figure></code></pre><h3 id="显示方向"><a href="#显示方向" class="headerlink" title="显示方向"></a>显示方向</h3><ul><li>TB/TD（ top bottom/top down）表示从上到下 </li><li>BT（bottom top）表示从下到上 </li><li>RL（right left）表示从右到左</li><li>LR（left right）表示从左到右 <h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3>&emsp;&emsp; 节点本身的展现形式，是通过不同括号来代表各自不同的形状，默认为矩形。<ul><li>默认节点： A</li><li>矩形节点： B[矩形]</li><li>圆角矩形节点： C(圆角矩形)</li><li>圆形节点： D((圆形))</li><li>非对称节点： E&gt;非对称]</li><li>菱形节点： F{菱形}<br><center><img src="/img/tech/节点类型.png" title="节点类型"></center><h3 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h3><h5 id="节点连线"><a href="#节点连线" class="headerlink" title="节点连线"></a>节点连线</h5>&emsp;&emsp; 线条本身的形式有多种，通过常规的英文格式的格式来标识，具体如下：</li><li>箭头连接 A1- -&gt;B1</li><li>开放连接 A2- - -B2</li><li>虚线箭头连接 A3.-&gt;B3 或者 A3-.-&gt;B3</li><li>虚线连接 A4.-B4 或者 A4-.-B4</li><li>粗线箭头连接 A5==&gt;B5</li><li>粗线开放连接 A6===B6</li><li>标签虚线箭头连接 A7-.text.-&gt;B7</li><li>标签开放连接 A8- -text- - -B8<br><center><img src="/img/tech/节点连线.png" title="节点连线"></center><h5 id="节点样式"><a href="#节点样式" class="headerlink" title="节点样式"></a>节点样式</h5>&emsp;&emsp; 样式写法跟矢量图（SVG）中CSS的写法一致，含有的属性有：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style 节点  样式</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="2-Flowchart流程图"><a href="#2-Flowchart流程图" class="headerlink" title="2. Flowchart流程图"></a>2. Flowchart流程图</h1><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op1=&gt;operation: 操作1 | past</span><br><span class="line">op2=&gt;operation: 操作2 | current</span><br><span class="line">op3=&gt;operation: 操作3 | future</span><br><span class="line">pa=&gt;parallel: 多输出操作4 | approved</span><br><span class="line">cond=&gt;condition: 确认？ | rejected</span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(true)-&gt;e   </span><br><span class="line">cond(no)-&gt;op2(right)-&gt;op3-&gt;pa(path1,right)-&gt;op1</span><br><span class="line">pa(path2,left) -&gt;e</span><br><span class="line">st@&gt;op1(&#123;&quot;stroke&quot;:&quot;Blue&quot;&#125;)@&gt;cond(&#123;&quot;stroke&quot;:&quot;Green&quot;&#125;)@&gt;e(&#123;&quot;stroke&quot;:&quot;Red&quot;,&quot;stroke-width&quot;:6,&quot;arrow-end&quot;:&quot;classic-wide-long&quot;&#125;)</span><br></pre></td></tr></table></figure></code></pre><center><img src="/img/tech/Flowchart流程图.png" title="Flowchart流程图"></center><h3 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">定义节点</span><br><span class="line">连接节点</span><br><span class="line">（样式调整）</span><br></pre></td></tr></table></figure></code></pre><h3 id="节点类型-1"><a href="#节点类型-1" class="headerlink" title="节点类型"></a>节点类型</h3><p>&emsp;&emsp;目前官网提供7种节点，其实还有很多别的节点类型，但可能插件脚本还没支持。</p><ul><li>开始（椭圆形）：start</li><li>结束（椭圆形）：end</li><li>操作（矩形）：operation</li><li>多输出操作（矩形）：parallel</li><li>条件判断（菱形）：condition</li><li>输入输出（平行四边形）：inputoutput</li><li>预处理/子程序（圣旨形）：subroutine</li></ul><h3 id="语法详解-1"><a href="#语法详解-1" class="headerlink" title="语法详解"></a>语法详解</h3><h5 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=&gt;节点标识: 节点显示名</span><br></pre></td></tr></table></figure><h5 id="节点连线-1"><a href="#节点连线-1" class="headerlink" title="节点连线"></a>节点连线</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名1-&gt;变量名2-&gt;...-&gt;变量名n</span><br></pre></td></tr></table></figure><h5 id="连线样式"><a href="#连线样式" class="headerlink" title="连线样式"></a>连线样式</h5><p>&emsp;&emsp;设置变量m和变量n之间连线的样式，具体样式由变量n后面key-value控制，需要两个变量之间有直接连线。语法中的连接符为（@&gt;）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名m@&gt;变量名n(&#123;&quot;key&quot;:&quot;value&quot;&#125;)</span><br></pre></td></tr></table></figure></p><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><ul><li>yes/true：condition类型变量连接时，用于分别表示yes条件的流向</li><li>no/false：同上，表示否定条件的流向</li><li>left/right：表示连线出口在节点位置（默认下面是出口，如op3），可以跟condition变量一起用：cond(yes,right)</li><li>path1/path2/path3：parallel变量的三个出口路径（默认下面是出口）<h5 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h5>&emsp;&emsp;为节点设置不同的状态，可以通过不同的颜色显示，其中状态包括下面6个，含义如英文所示，不过CSDN中好像目前还不支持：</li><li>past</li><li>current</li><li>future</li><li>approved</li><li>rejected</li><li>invalid</li></ul><hr><h1 id="3-时序图"><a href="#3-时序图" class="headerlink" title="3. 时序图"></a>3. 时序图</h1><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 张 as 张三</span><br><span class="line">participant 李 as 李四</span><br><span class="line">participant 王 as  王五   </span><br><span class="line">张 -&gt;&gt; +李: 你好！李四, 最近怎么样?</span><br><span class="line">李--&gt;&gt; 王: 你最近怎么样，王五？</span><br><span class="line">李--x -张: 我很好，谢谢!</span><br><span class="line">activate 王</span><br><span class="line">李-x 王: 我很好，谢谢!   </span><br><span class="line">Note over 李,王: 李四想了很长时间, 文字太长了&lt;br/&gt;不适合放在一行.</span><br><span class="line">deactivate 王</span><br><span class="line">loop 李四再想想</span><br><span class="line">李--&gt;&gt;王: 我还要想想</span><br><span class="line">王--&gt;&gt;李: 想想吧</span><br><span class="line">end</span><br><span class="line">李--&gt;&gt;张: 打量着王五...</span><br><span class="line">张-&gt;&gt;王: 很好... 王五, 你怎么样?</span><br></pre></td></tr></table></figure></code></pre><center><img src="/img/tech/sequenceDiagram时序图.png" title="sequenceDiagram时序图"></center><br>### 语法结构<br><br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 别名 as 对象显示名（全部直接用显示名时可以不写）</span><br><span class="line">顺序增加图表中消息</span><br><span class="line">（可以加入标签提示）</span><br></pre></td></tr></table></figure><br><br>### 语法详解<br>##### 消息格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【对象1】【箭头类型】【对象2】 : 消息内容</span><br></pre></td></tr></table></figure><br><br>##### 连接样式<br>一共6种箭头类型的样式：<br> - 实线：-&gt;<br> - 虚线：- -&gt;<br> - 带箭头的实线：-&gt;&gt;<br> - 带箭头的虚线：- -&gt;&gt;<br> - 带<font color="red">x</font>的实线：-x<br> - 带<font color="red">x</font>的虚线：- -x<br>##### 激活方块<br>&emsp;&emsp;这部分有两种写法，第一种是显示通过语法实现，语法如下，会在指定对象的消息中增加，示例中李四；第二种直接在对象前面增加加减号（开始时用加号“+”，结束时用减号“-”），则在加号对应的对象上开始，减号对应的时间结束，示例中王五。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始：activate 【对象】</span><br><span class="line">结束：deactivate 【对象】</span><br></pre></td></tr></table></figure><br><br>##### 注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Note 【位置】 【对象】</span><br></pre></td></tr></table></figure><br><br>注释显示的位置有三个，以被标记的对象中心为参考系，基于横跨多个时，可以都逗号分隔，如示例：<br>- right of<br>- left of<br>- over<br>##### 循环（while）<br>见示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 循环说明</span><br><span class="line">【消息流】</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>##### 条件（if/else）<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alt 条件说明</span><br><span class="line">【消息流】</span><br><span class="line">else</span><br><span class="line">【消息流】</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opt 条件说明</span><br><span class="line">【消息流】</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br>示例内容太多了，为了防止太臃肿，把条件内容独立出来进行演示，当有else时，用alt，否则用opt。<br><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant 张 as 张三</span><br><span class="line">participant 李 as 李四</span><br><span class="line">张 -&gt;&gt; 李: 你好！李四, 最近怎么样?</span><br><span class="line">alt 如果感冒了</span><br><span class="line">李-&gt;&gt; 张: 不太好，生病了。</span><br><span class="line">else 挺好的</span><br><span class="line">李-&gt;&gt; 张: 我很好，谢谢。</span><br><span class="line">end</span><br><span class="line">    opt 另外补充</span><br><span class="line">    李-&gt;&gt; 张: 谢谢问候。</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><br><center><img src="/img/tech/条件.png" title="条件"></center><p>参考自：<br><a href="https://mermaidjs.github.io/" target="_blank" rel="noopener">https://mermaidjs.github.io/</a><br><a href="http://flowchart.js.org/" target="_blank" rel="noopener">http://flowchart.js.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流程图 </tag>
            
            <tag> 时序图 </tag>
            
            <tag> mermaid </tag>
            
            <tag> flowchart </tag>
            
            <tag> sequenceDiagram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《一本书读懂·金融常识》</title>
      <link href="/2018/12/08/books/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E6%87%82%C2%B7%E9%87%91%E8%9E%8D%E5%B8%B8%E8%AF%86/"/>
      <url>/2018/12/08/books/%E4%B8%80%E6%9C%AC%E4%B9%A6%E8%AF%BB%E6%87%82%C2%B7%E9%87%91%E8%9E%8D%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;书中分两部分，前面2/3讲金融学概念，后面1/3讲理财的知识<br>&emsp;&emsp;前面讲金融学常识部分将多个易混淆概念进行整理对比，方便对概念的理解<br>&emsp;&emsp;后面对理财方式的讲解也有眼前一亮的感受，但整体来讲没有前半部分精彩<br>&emsp;&emsp;若有金融基础，则更容易理解书中内容，对零基础朋友也是本不错的金融通识书<br>&emsp;&emsp;有一个概念虽然一直知道，但真正看到有人总结出来还是值得分享下的，书中说要分清资产和消费，资产包括：</p><ol><li>那些不需要自己到场就可以正常运作的业务，自己拥有他们，但是本身的经营和管理由别人来操作。如果是自己一定要参与运作或者在那儿工作，这个就不是自己的事业而是职业。</li><li>股票</li><li>债券</li><li>能够产生收入的房地产</li><li>票据</li><li>办税（音乐、手稿、专利等）</li><li>其他任何有价值，可以产生收入或有增值潜力且有销路的东西</li></ol><h1 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h1><p>&emsp;&emsp;金融学属于二级学科，上面的一级学科是经济学，再往上是数学，因此如果想对金融学有专业系统的学习，常规的学习路径应该是本科学习数学，硕士学经济学，博士读金融学，这个是听上海财经大学老师讲行为金融学里说的，说这个是金融学学习的固定模式。从阅读过程确实可以感受到处处是在讲经济，深入理解其原理和影响就需要数学计算。</p><p>&emsp;&emsp;自己在几年前考了证券从业资格证，虽然考完后就几年没再接触过相关的知识和公司，但书中大部分概念还是一看就明白，书中内容整理的比较系统，阅读过程相当于复习一下利率、汇率、通胀等金融工具概念，同时也对金融工具的使用做了说明和解释。这本书是一本不错的金融概念的通识读物，也学习到一些基本的理财方式。</p><p>&emsp;&emsp;如果有闲钱，一定不要把钱只是存在银行，要按比例将钱分别用于储蓄、理财投资和日常生活，这个对不同的人比例不一样，不过，即使年纪大也要有理财意识，书中描述的比例不一定合适自己，但思路是自己认可的，自己读完本书后的改变是，将自己的日常生活开销购买了，可以实时提现的理财产品，其实收入不多完全可以忽略，一个月就多了几块钱，但这算是一种思维的转变。很多大的变动大多是由很多小小转变一点点累积，由量变最终形成质变的。</p><center><img src="/img/books/一本书读懂金融常识.jpg" width="150" height="200" title="一本书读懂金融常识 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融常识 </tag>
            
            <tag> 资产配置 </tag>
            
            <tag> 金融学 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《心理学入门》</title>
      <link href="/2018/12/08/books/%E5%BF%83%E7%90%86%E5%AD%A6%E5%85%A5%E9%97%A8/"/>
      <url>/2018/12/08/books/%E5%BF%83%E7%90%86%E5%AD%A6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>书中内容比较浅显易懂，适合中小学生阅读，拓宽视野<br>两页一个小故事或者一个心理学的概念的阐述<br>这种书本人比较难耐着性子看完，感觉它就像一本词典<br>信息比较琐碎，内容前后没有关联，就是一些心理学概念的聚集<br>偶尔有部分概念会吸引一下注意力，大部分都可以一扫而过<br>适合亲子阅读，家长带着小孩，一边读一边讲故事并发散思维<br>可以快速读完，本人2个小时就读完了整本书<br>如果想从知识体系层面对自己有所提升，这本书不适合</p><h1 id="个人收获"><a href="#个人收获" class="headerlink" title="个人收获"></a>个人收获</h1><p>被这本书的书名骗了，它应该改名叫《99个心理学现象》，也许可以匹配到更适合的读者。买来是想了解下心理学相关的知识体系，也不是想有多深的了解，只是作为认知的拓展，但买来这本书，感觉买了本心理学概念的词典，这种书不是自己的目标，也不太适合现在的自己。</p><p>尽管书看完了有点失望，没有对心理学的知识体系有什么特别的帮助，也许是自己太过于急于求成了，本身一个领域的知识体系也不太容易通过一本大众类的书籍传达，其实常识概念也算是心理学入门的一种，适合培养心理学兴趣。看完书，并没有对书中内容记住什么，不过，对一些概念在读的时候有了认知，也许之后别人聊天时，有人如果说这个现象自己会有点印象，自己的书架上多了一本心理学词典。</p><p>本人是短期记忆，特别不容易形成长期记忆，即使生活中发生的一些事情，很少有事情我可以记住超过一天的，很多事情讲给我听后，或者交待给我，如果我没有持续在想或者计划，半小时后就好像什么也没发生一样，这个也不是不重视，也许本能使然。我家人一直觉得我这是个病，还为此去做过脑部CT扫描，也没发现任何问题。知道自己有这个问题，所以也有个习惯，就是把想法写下来，所以会随时带笔和便利贴，也经常在日历中设置闹钟提醒，暂时也没有特别的APP推荐，因为用日历基本够用了，之后如果需要APP辅助，到时再进行调研，会把结果进行分享。</p><center><img src="/img/books/心理学入门.jpg" width="150" height="200" title="心理学入门 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 沟通相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 故事汇 </tag>
            
            <tag> 心理学 </tag>
            
            <tag> 词语解释 </tag>
            
            <tag> 心理学小故事 </tag>
            
            <tag> 心理学小词典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《创能量·28位传奇企业家的口述创业史》</title>
      <link href="/2018/12/07/books/%E5%88%9B%E8%83%BD%E9%87%8F%C2%B728%E4%BD%8D%E4%BC%A0%E5%A5%87%E4%BC%81%E4%B8%9A%E5%AE%B6%E7%9A%84%E5%8F%A3%E8%BF%B0%E5%88%9B%E4%B8%9A%E5%8F%B2/"/>
      <url>/2018/12/07/books/%E5%88%9B%E8%83%BD%E9%87%8F%C2%B728%E4%BD%8D%E4%BC%A0%E5%A5%87%E4%BC%81%E4%B8%9A%E5%AE%B6%E7%9A%84%E5%8F%A3%E8%BF%B0%E5%88%9B%E4%B8%9A%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h1><p>&emsp;&emsp;前两天读翻了一遍《创能量》，写了28位创业者的成长故事，具体内容不做过多剧透，写点自己的几点感受，分享一下：</p><ul><li>书中基本都是白手起家的创业者，也有夫妻档起步</li><li>书中创业者主要集中在深圳地区</li><li>书中对象集中在75-85年代出生</li><li>书中创业者有个主要的特质：为人真诚（也许自述容易美化自己）、吃苦耐劳（也许跟时代和行业有关）</li><li>书中创业者起点各不相同，有高学历，有公务员，也有穷途末路者</li><li>书中创业者都敢于承担责任</li><li>书中创业者的第一桶金相对都不容易</li></ul><h1 id="自己的收获"><a href="#自己的收获" class="headerlink" title="自己的收获"></a>自己的收获</h1><ul><li><p>作为一个普通人，在读部分章节时确实可以感同身受，虽然文笔并没特别修饰，也从朴实的表达中跟随对方的情绪，几度哽咽。或许，我是一个容易受到情绪感染的人，尤其容易被亲情、义气等情节打动。</p></li><li><p>作为一名创业者，印象深刻的是书中创业者的坚韧和坦然。虽然每个人的成功是无法复制的，但通过他人做事的态度，领略做人的成长，对自己有所借鉴和学习，这应该也是很多人喜欢看各路名人名家自传的原因吧。</p></li><li><p>人生路很长，每段路都有各自的精彩，路上遇到的每个人、每件事都有其特有的价值，不必太纠结一时的得失。也许人生的精彩就在他的不确定性和各种可能性，如果未来是确定的模式和不变的节奏，也许也不是你说追求的。当对未来迷茫时，不妨抬头想想，低头看看。抬头看浩瀚的宇宙中，银行系也只是其中一个光点，光点中的太阳、地球、国家、生命以及那些追求的名利，简直太不值一提。低头看身边的朋友、陌生人、动物、植物、微生物都有其各自的价值和追求，当有一个自己的梦可以追寻，就是幸运的，就应该为自己骄傲。</p></li></ul><center><img src="/img/books/创能量.jpg" width="150" height="200" title="创能量 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 工作相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创能量 </tag>
            
            <tag> 创业故事汇 </tag>
            
            <tag> 创业者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记 之 《三体》</title>
      <link href="/2018/12/02/books/%E4%B8%89%E4%BD%93/"/>
      <url>/2018/12/02/books/%E4%B8%89%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>&emsp;&emsp;一共三本书，分别为：《三体》、《三体2：黑暗森林》、《三体3：死神永生》，第一本比较无聊，第二本比较精彩刺激，第三本比较开脑洞，各种天马行空。小说获得了15年的雨果奖，被评为硬科幻的一部标志性的小说，但读第三部感觉很多东西还是应分为软科幻。<br>&emsp;&emsp;小说既然被归类为硬科幻，那其中肯定是有关于科学合理的推理，不过，科学概念还是比较高深，如果完全没有物理学的理论基础，读起来对不太容易建立起因果关系，对连接的逻辑会有些不知所云，但如果只是关注故事情节，也是完全可以理解其中梗概的。<br>&emsp;&emsp;小说的厉害之处，应该就是基于科学的合理且大胆的想象，如果只是关注故事情节，也许会丢失很大一部分精彩。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;小说第一部，描述了作者在网游中的一些游戏体验，游戏中说的东西比较虚幻，其中的场景类似后面三体世界的真实场景，全是为了后面做铺垫，所以读取来会感觉不知所云，如果只是读了第一步，就太亏了，基本上第一步整本都是在铺垫。<br>&emsp;&emsp;小说第二部，讲人类基础科学遇到了，来自三体世界先进文明的技术封锁，科研不再可以获得突破，然后人来选择了3位地球上德高望重和1位无所事事的人来想办法解除封锁，主角光环是那位无所事事的人，想出了黑暗森林的策略打破了魔咒。黑暗森林的原理就是，在一个黑暗的森林里，所有人互相都不知道，一旦看到有人出现，最安全的做法就是开枪把对方消灭，所以暴露自己的位置的人会被其他人攻击。<br>&emsp;&emsp;小说第三部，讲三体世界和地球短暂的和平没有持续太久，在双方斗争的摸索中选择了孤注一掷，最终都暴露了自己星球在宇宙中的位置，最终自己的星球都被其他更高级的文明毁灭了，然后整个宇宙一片静悄悄，所有文明都小心翼翼。<br>&emsp;&emsp;整部小说，提到了很多非常有想象力的画面和场景，包括外星文明和科技的存在，很多也都是基于真实的科学背景，而不只是一味的对外星人的想象。所以，读起来也不会感觉到尴尬，反而觉得如果有平行世界，确实有可能是书中描述的情况。虽然整体故事在回味的时候非常精彩，但书中好多章节比较拖沓，铺垫太多。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ul><li>不推荐小朋友读这本科幻小说，成年人才可以考虑。</li><li>第一部如果有些章节不喜欢可以跳过，但如果读了第一部，一定要读第二部。</li><li>我认为第一部是铺垫，第二部才是高潮，第三部是升华。</li><li>读书的时候可以多关注下书中关于科学的描述，真实又有想象力。</li></ul><center><img src="/img/books/三体.jpg" width="150" height="200" title="三体 - 全三册 图书封面"></center>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 一些小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三体 </tag>
            
            <tag> 硬科幻 </tag>
            
            <tag> 刘慈欣 </tag>
            
            <tag> 黑暗森林 </tag>
            
            <tag> 死神永生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow开发 之 mnist文件解析</title>
      <link href="/2018/04/24/tech/tensorflow-mnist/"/>
      <url>/2018/04/24/tech/tensorflow-mnist/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;mnist本身是将数字手写体图像，归一化后信息合成的文件，分训练集和测试集两部分，每部分包含图片和标签两个文件，本文使用C++写的Demo将文件解码，并通过opencv将数据存储为常规的图像文件。源码下载地址：<a href="https://github.com/zacSuo/mnist" target="_blank" rel="noopener">https://github.com/zacSuo/mnist</a></p><ul><li>t10k-images.idx3-ubyte</li><li>t10k-labels.idx1-ubyte </li><li>train-images.idx3-ubyte</li><li>train-labels.idx1-ubyte</li></ul><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>visual studio 2012及以上版本</li><li>opencv 2.4及以上版本<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>启动前先通过项目属性，设置本地opencv的路径。<br><img src="/img/tech/20190124114552686.png" width="200px" height="100px"></li></ul><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>&emsp;&emsp;在目录的两个文件夹，分别将测试集（test_images）和训练集（train_images）的图片保存到其中。<br><img src="/img/tech/2019012411555929.png" width="200px" height="100px"><img src="/img/tech/20190124115621785.png" width="200px" height="100px"><img src="/img/tech/20190124115638142.png" width="200px" height="100px"><br><img src="/img/tech/20190124115841654.png" width="400px" height="200px"></p><h1 id="程序说明"><a href="#程序说明" class="headerlink" title="程序说明"></a>程序说明</h1><h2 id="解码图像"><a href="#解码图像" class="headerlink" title="解码图像"></a>解码图像</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_Mnist</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> filename, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number_of_images = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">file</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.is_open()) &#123;</span><br><span class="line">        <span class="keyword">int</span> magic_number = <span class="number">0</span>;       </span><br><span class="line">        <span class="keyword">int</span> n_rows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n_cols = <span class="number">0</span>;</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;magic_number, <span class="keyword">sizeof</span>(magic_number));</span><br><span class="line">        magic_number = ReverseInt(magic_number);</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;number_of_images, <span class="keyword">sizeof</span>(number_of_images));</span><br><span class="line">        number_of_images = ReverseInt(number_of_images);</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;n_rows, <span class="keyword">sizeof</span>(n_rows));</span><br><span class="line">        n_rows = ReverseInt(n_rows);</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;n_cols, <span class="keyword">sizeof</span>(n_cols));</span><br><span class="line">        n_cols = ReverseInt(n_cols);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_images; ++i) &#123;</span><br><span class="line">            cv::Mat tp = cv::Mat::zeros(n_rows, n_cols, CV_8UC1);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n_rows; ++r) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n_cols; ++c) &#123;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">char</span> temp = <span class="number">0</span>;</span><br><span class="line">                    file.read((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">                    tp.at&lt;uchar&gt;(r, c) = (<span class="keyword">int</span>)temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vec.push_back(tp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number_of_images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解码图像对应数值"><a href="#解码图像对应数值" class="headerlink" title="解码图像对应数值"></a>解码图像对应数值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_Mnist_Label</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> filename, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">ifstream <span class="title">file</span><span class="params">(filename, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.is_open()) &#123;</span><br><span class="line">        <span class="keyword">int</span> magic_number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> number_of_images = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n_rows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n_cols = <span class="number">0</span>;</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;magic_number, <span class="keyword">sizeof</span>(magic_number));</span><br><span class="line">        magic_number = ReverseInt(magic_number);</span><br><span class="line">        file.read((<span class="keyword">char</span>*)&amp;number_of_images, <span class="keyword">sizeof</span>(number_of_images));</span><br><span class="line">        number_of_images = ReverseInt(number_of_images);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number_of_images; ++i) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> temp = <span class="number">0</span>;</span><br><span class="line">            file.read((<span class="keyword">char</span>*)&amp;temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">            vec[i] = (<span class="keyword">int</span>)temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成图像文件"><a href="#生成图像文件" class="headerlink" title="生成图像文件"></a>生成图像文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decodeDatabase</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> filenameImages,<span class="built_in">std</span>::<span class="built_in">string</span> filenameLabels,<span class="built_in">std</span>::<span class="built_in">string</span> imagesPathSave)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read MNIST image into OpenCV Mat vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Mat&gt; vec_train_images;</span><br><span class="line">    <span class="keyword">int</span> number_of_train_images = read_Mnist(filenameImages, vec_train_images);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read MNIST label into int vector</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_train_labels(number_of_train_images);</span><br><span class="line">    read_Mnist_Label(filenameLabels, vec_train_labels);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vec_train_images.size() != vec_train_labels.size()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"parse MNIST train file error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save images</span></span><br><span class="line">    <span class="keyword">int</span> count_digits[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">std</span>::fill(&amp;count_digits[<span class="number">0</span>], &amp;count_digits[<span class="number">0</span>] + <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec_train_images.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> number = vec_train_labels[i];</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> image_name = GetImageName(number, count_digits);</span><br><span class="line">        image_name = imagesPathSave + image_name + <span class="string">".jpg"</span>;</span><br><span class="line"></span><br><span class="line">        cv::imwrite(image_name, vec_train_images[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="每个数值各选20张图像合并成一个图像文件"><a href="#每个数值各选20张图像合并成一个图像文件" class="headerlink" title="每个数值各选20张图像合并成一个图像文件"></a>每个数值各选20张图像合并成一个图像文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergeSomeImages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> images_path = <span class="string">".././mnistFile/train_images/"</span>;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">28</span> * <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">28</span> * <span class="number">10</span>;</span><br><span class="line">    cv::<span class="function">Mat <span class="title">dst</span><span class="params">(height, width, CV_8UC1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = (j<span class="number">-1</span>) * <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">int</span> y = i * <span class="number">28</span>;</span><br><span class="line">            cv::Mat part = dst(cv::Rect(x, y, <span class="number">28</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="built_in">std</span>::to_string(j);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">10</span>)</span><br><span class="line">                str = <span class="string">"0000"</span> + str;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str = <span class="string">"000"</span> + str;</span><br><span class="line"></span><br><span class="line">            str = <span class="built_in">std</span>::to_string(i) + <span class="string">"_"</span> + str + <span class="string">".jpg"</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> input_image = images_path + str;</span><br><span class="line"></span><br><span class="line">            cv::Mat src = cv::imread(input_image, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (src.empty()) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read image error: %s\n"</span>, input_image.c_str());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            src.copyTo(part);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> output_image = images_path + <span class="string">"result.png"</span>;</span><br><span class="line">    cv::imwrite(output_image, dst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术资料 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> ai </tag>
            
            <tag> mnist </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
